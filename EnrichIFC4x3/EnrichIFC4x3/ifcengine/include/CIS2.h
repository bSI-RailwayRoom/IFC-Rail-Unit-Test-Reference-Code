//
// Early-binding C++ API for SDAI (C++ wrappers)
//
#ifndef __RDF_LTD__CIS2_H
#define __RDF_LTD__CIS2_H

#include    <assert.h>
#include    <list>
#include    <string>

#include	"ifcengine.h"

namespace CIS2
{
    ///
    typedef int_t SdaiModel;
    typedef int_t SdaiInstance;

    typedef const char* TextValue;
    typedef int_t       IntValue;

    class StringValue : public std::string
    {
    public:
        StringValue(TextValue str) : std::string(str) {}
        operator const char* () const { return c_str(); }
    };

    /// <summary>
    /// 
    /// </summary>
    template <typename T> class Nullable
    {
    protected:
        T* m_value;

    public:
        Nullable<T>() : m_value(NULL) {}
        Nullable<T>(T value) { m_value = new T(value); }
        Nullable<T>(const Nullable<T>& src) { if (src.m_value) m_value = new T(*src.m_value); else m_value = NULL; }

        virtual ~Nullable<T>() { if (m_value) { delete m_value; } };

        bool IsNull() const { return !m_value; }
        T Value() const { assert(m_value); if (m_value) return *m_value; else return (T) 0; }

        virtual Nullable<T>& operator=(const Nullable<T>& src)
        {
            if (m_value) { delete m_value; }
            m_value = NULL;
            if (src.m_value) { m_value = new T(*(src.m_value)); }
            return *this;
        }
    };

    //
    //
    enum class LOGICAL_VALUE { False = 0, True, Unknown };
    static TextValue LOGICAL_VALUE_[] = {"F", "T", "U", NULL};

    //
    //
    static int EnumerationNameToIndex(TextValue rEnumValues[], TextValue value)
    {
        if (value) {
            for (int i = 0; rEnumValues[i]; i++) {
                if (0 == _stricmp(value, rEnumValues[i])) {
                    return i;
                }
            }
        }
        return -1;
    }

    /// <summary>
    /// Helper class to handle and access SELECT instance data
    /// </summary>
    class Select
    {
    protected:
        SdaiInstance m_instance;
        TextValue m_attrName;

    private:
        void* m_adb;
        Select* m_outerSelect;

    public:
        void* ADB()
        {
            if (m_outerSelect) {
                return m_outerSelect->ADB();
            }

            if (!m_adb && m_instance && m_attrName) {
                m_adb = sdaiCreateEmptyADB();
                if (!sdaiGetAttrBN(m_instance, m_attrName, sdaiADB, &m_adb)) {
                    sdaiDeleteADB(m_adb);
                    m_adb = NULL;
                }
            }

            return m_adb;
        }

    protected:
        Select(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL)
            : m_instance(instance), m_attrName(attrName), m_adb(adb), m_outerSelect(NULL)
        {
            assert(instance);
        }

        Select(Select* outer)
            : m_instance(NULL), m_attrName(NULL), m_adb(NULL), m_outerSelect(outer)
        {
            assert(outer);
            if (m_outerSelect) {
                m_instance = m_outerSelect->m_instance;
            }
        }

        void SetADB(void* adb)
        {
            if (m_outerSelect) {
                m_outerSelect->SetADB(adb);
            }
            else {
                //???sdaiDeleteADB(m_adb);
                m_adb = adb;

                if (m_instance && m_attrName) {
                    sdaiPutAttrBN(m_instance, m_attrName, sdaiADB, m_adb);
                }
            }
        }

        //
        template <typename T> Nullable<T> getSimpleValue(TextValue typeName, IntValue sdaiType)
        {
            Nullable<T> ret;
            if (void* adb = ADB()) {
                char* path = sdaiGetADBTypePath(adb, 0);
                if (typeName == NULL || path && 0 == _stricmp(path, typeName)) {
                    T val = (T) 0;
                    if (sdaiGetADBValue(adb, sdaiType, &val)) {
                        ret = val;
                    }
                }
            }
            return ret;
        }

        //
        template <typename T> void putSimpleValue(TextValue typeName, IntValue sdaiType, T value)
        {
            void* adb = sdaiCreateADB(sdaiType, &value);
            sdaiPutADBTypePath(adb, 1, typeName);
            SetADB(adb);
        }

        //
        TextValue getTextValue(TextValue typeName, IntValue sdaiType)
        {
            TextValue ret = NULL;
            if (void* adb = ADB()) {
                char* path = sdaiGetADBTypePath(adb, 0);
                if (typeName == NULL || path && 0 == _stricmp(path, typeName)) {
                    if (!sdaiGetADBValue(adb, sdaiType, &ret)) {
                        ret = NULL;
                    }
                }
            }
            return ret;
        }

        //
        void putTextValue(TextValue typeName, IntValue sdaiType, TextValue value)
        {
            void* adb = sdaiCreateADB(sdaiType, value);
            sdaiPutADBTypePath(adb, 1, typeName);
            SetADB(adb);
        }

        //
        int getEnumerationValue(TextValue typeName, TextValue rEnumValues[])
        {
            int ret = -1;
            if (void* adb = ADB()) {
                char* path = sdaiGetADBTypePath(adb, 0);
                if (typeName == NULL || path && 0 == _stricmp(path, typeName)) {
                    TextValue value = NULL;
                    if (sdaiGetADBValue(adb, sdaiENUM, &value)) {
                        ret = EnumerationNameToIndex(rEnumValues, value);
                    }
                }
            }
            return ret;
        }

        //
        void putEnumerationValue(TextValue typeName, TextValue value)
        {
            void* adb = sdaiCreateADB(sdaiENUM, value);
            sdaiPutADBTypePath(adb, 1, typeName);
            SetADB(adb);
        }

        //
        SdaiInstance getEntityInstance(TextValue typeName)
        {
            SdaiInstance ret = 0;
            if (auto adb = ADB()) {
                SdaiInstance inst = 0;
                if (sdaiGetADBValue(adb, sdaiINSTANCE, &inst)) {
                    if (typeName == NULL || sdaiIsKindOfBN(inst, typeName)) {
                        ret = inst;
                    }
                }
            }
            return ret;
        }

        //
        void putEntityInstance(TextValue typeName, SdaiInstance inst)
        {
            if (inst == 0 || sdaiIsKindOfBN(inst, typeName)) {
                auto adb = sdaiCreateADB(sdaiINSTANCE, (void*) inst);
                SetADB(adb);
            }
            else {
                assert(0);
            }
        }

        //
        SdaiAggr getAggrValue(TextValue typeName)
        {
            SdaiAggr ret = NULL;
            if (void* adb = ADB()) {
                char* path = sdaiGetADBTypePath(adb, 0);
                if (typeName == NULL || path && 0 == _stricmp(path, typeName)) {
                    if (!sdaiGetADBValue(adb, sdaiAGGR, &ret)) {
                        ret = NULL;
                    }
                }
            }
            return ret;
        }

        //
        void putAggrValue(TextValue typeName, SdaiAggr value)
        {
            void* adb = sdaiCreateADB(sdaiAGGR, value);
            sdaiPutADBTypePath(adb, 1, typeName);
            SetADB(adb);
        }

        //
        bool IsADBType(TextValue typeName)
        {
            if (void* adb = ADB()) {
                char* path = sdaiGetADBTypePath(adb, 0);
                if (0 == _stricmp(path, typeName)) {
                    return true;
                }
            }
            return false;
        }

        bool IsADBEntity(TextValue typeName)
        {
            if (void* adb = ADB()) {
                IntValue inst = 0;
                if (sdaiGetADBValue(adb, sdaiINSTANCE, &inst)) {
                    if (sdaiIsKindOfBN(inst, typeName)) {
                        return true;
                    }
                }
            }
            return false;
        }
    };

    /// <summary>
    /// Aggregations templates
    /// </summary>
    /// 

    template <typename TArrayElem, typename TList> void ArrayToList(TArrayElem arrayElems[], IntValue numOfElems, TList& lst)
    {
        for (IntValue i = 0; i < numOfElems; i++) {
            lst.push_back(arrayElems[i]);
        }
    }

    template <typename TList> class AggrSerializer
    {
    public:
        //
        void FromAttr(TList& lst, SdaiInstance instance, TextValue attrName)
        {
            SdaiAggr aggr = NULL;
            sdaiGetAttrBN(instance, attrName, sdaiAGGR, &aggr);
            if (aggr) {
                FromSdaiAggr(lst, instance, aggr);
            }
        }

        //
        virtual void FromSdaiAggr(TList& lst, SdaiInstance inst, SdaiAggr aggr) = 0; 
        virtual SdaiAggr ToSdaiAggr(TList& lst, SdaiInstance instance, TextValue attrName) = 0;
    };

    /// <summary>
    /// 
    /// </summary>
    template <typename TList, typename TElem, IntValue sdaiType> class AggrSerializerSimple : public AggrSerializer<TList>
    {
    public:
        AggrSerializerSimple() { assert(sdaiType == sdaiINTEGER || sdaiType == sdaiREAL || sdaiType == sdaiBOOLEAN); }

        //
        virtual void FromSdaiAggr(TList& lst, SdaiInstance /*unused*/, SdaiAggr aggr) override
        {
            IntValue  cnt = sdaiGetMemberCount(aggr);
            for (IntValue i = 0; i < cnt; i++) {
                TElem val = 0;
                engiGetAggrElement(aggr, i, sdaiType, &val);
                lst.push_back(val);
            }
        }

        //
        virtual SdaiAggr ToSdaiAggr(TList& lst, SdaiInstance instance, TextValue attrName) override
        {
            SdaiAggr aggr = sdaiCreateAggrBN(instance, attrName);
            for (auto const& v : lst) {
                TElem val = v;
                sdaiAppend((IntValue) aggr, sdaiType, &val);
            }
            return aggr;
        }
    };

    /// <summary>
    /// 
    /// </summary>
    template <typename TList, typename TElem, IntValue sdaiType> class AggrSerializerText : public AggrSerializer<TList>
    {
    public:
        AggrSerializerText() { assert(sdaiType == sdaiSTRING || sdaiType == sdaiBINARY); }

        virtual void FromSdaiAggr(TList& lst, SdaiInstance /*unused*/, SdaiAggr aggr) override
        {
            IntValue  cnt = sdaiGetMemberCount(aggr);
            for (IntValue i = 0; i < cnt; i++) {
                TextValue val;
                engiGetAggrElement(aggr, i, sdaiType, &val);
                lst.push_back(val);
            }
        }

        virtual SdaiAggr ToSdaiAggr(TList& lst, SdaiInstance instance, TextValue attrName) override
        {
            SdaiAggr aggr = sdaiCreateAggrBN(instance, attrName);
            for (auto& val : lst) {
                TextValue v = val;
                sdaiAppend((IntValue) aggr, sdaiType, v);
            }
            return aggr;
        }

    };

    /// <summary>
    /// 
    /// </summary>
    template <typename TList, typename TElem> class AggrSerializerInstance : public AggrSerializer <TList>
    {
    public:
        //
        virtual void FromSdaiAggr(TList& lst, SdaiInstance /*unused*/, SdaiAggr aggr) override
        {
            auto  cnt = sdaiGetMemberCount(aggr);
            for (IntValue i = 0; i < cnt; i++) {
                SdaiInstance val = 0;
                engiGetAggrElement(aggr, i, sdaiINSTANCE, &val);
                TElem elem(val);
                if (val) {
                    lst.push_back(val);
                }
            }
        }

        //
        virtual SdaiAggr ToSdaiAggr(TList& lst, SdaiInstance instance, TextValue attrName) override
        {
            auto aggr = sdaiCreateAggrBN(instance, attrName);
            for (auto& val : lst) {
                SdaiInstance v = val;
                sdaiAppend((IntValue) aggr, sdaiINSTANCE, (void*) v);
            }
            return aggr;
        }
    };


    /// <summary>
    /// 
    /// </summary>
    template <typename TList, typename TElem, TextValue* rEnumValues, IntValue sdaiType> class AggrSerializerEnum : public AggrSerializer<TList>
    {
    public:
        AggrSerializerEnum() { assert(sdaiType == sdaiENUM || sdaiType == sdaiLOGICAL); }

        //
        virtual void FromSdaiAggr(TList& lst, SdaiInstance /*instance*/, SdaiAggr aggr) override
        {
            IntValue  cnt = sdaiGetMemberCount(aggr);
            for (IntValue i = 0; i < cnt; i++) {
                TextValue value = NULL;
                engiGetAggrElement(aggr, i, sdaiType, &value);
                int val = EnumerationNameToIndex(rEnumValues, value);
                if (val >= 0) {
                    lst.push_back((TElem) val);
                }
            }
        }

        //
        virtual SdaiAggr ToSdaiAggr(TList& lst, SdaiInstance instance, TextValue attrName) override
        {
            SdaiAggr aggr = sdaiCreateAggrBN(instance, attrName);
            for (auto const& val : lst) {
                TextValue value = rEnumValues[(IntValue) val];
                sdaiAppend((IntValue) aggr, sdaiType, value);
            }
            return aggr;
        }
    };

    /// <summary>
    /// 
    /// </summary>
    template <typename TList, typename TNestedAggr, typename TNestedSerializer> class AggrSerializerAggr : public AggrSerializer<TList>
    {
    public:
        //
        virtual void FromSdaiAggr(TList& lst, SdaiInstance instance, SdaiAggr aggr) override
        {
            IntValue  cnt = sdaiGetMemberCount(aggr);
            for (IntValue i = 0; i < cnt; i++) {
                SdaiAggr nested = 0;
                engiGetAggrElement(aggr, i, sdaiAGGR, &nested);
                if (nested) {
                    lst.push_back(TNestedAggr());
                    TNestedSerializer nestedSerializer;
                    nestedSerializer.FromSdaiAggr(lst.back(), instance, nested);
                }
            }
        }

        //
        virtual SdaiAggr ToSdaiAggr(TList& lst, SdaiInstance instance, TextValue attrName) override
        {
            SdaiAggr aggr = sdaiCreateAggrBN(instance, attrName);
            for (TNestedAggr& val : lst) {
                TNestedSerializer nestedSerializer;
                SdaiAggr nested = nestedSerializer.ToSdaiAggr(val, instance, NULL);
                sdaiAppend((IntValue) aggr, sdaiAGGR, nested);
            }
            return aggr;
        }
    };

    template<typename TList, typename TElem> class AggrSerializerSelect : public AggrSerializer<TList>
    {
    public:
        //
        virtual void FromSdaiAggr(TList& lst, SdaiInstance instance, SdaiAggr aggr) override
        {
            IntValue  cnt = sdaiGetMemberCount(aggr);
            for (IntValue i = 0; i < cnt; i++) {
                void* adb = 0;
                engiGetAggrElement(aggr, i, sdaiADB, &adb);
                if (adb) {
                    lst.push_back(TElem(instance, NULL, adb));
                }
            }
        }

        //
        virtual SdaiAggr ToSdaiAggr(TList& lst, SdaiInstance instance, TextValue attrName) override
        {
            SdaiAggr aggr = sdaiCreateAggrBN(instance, attrName);
            for (auto& val : lst) {
                void* adb = val.ADB();
                if (adb) {
                    sdaiAppend((IntValue) aggr, sdaiADB, adb);
                }
            }
            return aggr;
        }
    };


    /// <summary>
    /// Provides utility methods to interact with a generic SDAI instnace
    /// You also can use object of this class instead of SdaiInstance handle in any place where the handle is required
    /// </summary>
    class Entity
    {
    protected:
        SdaiInstance m_instance;

    public:
        Entity(SdaiInstance instance, TextValue entityName)
        {
            m_instance = instance;

            if (m_instance != 0 && entityName != NULL) {
                if (!sdaiIsKindOfBN(m_instance, entityName)) {
                    m_instance = 0;
                }
            }
        }


        /// <summary>
        /// Conversion  to instance handle, so the object of the class can be used anywhere where a handle required
        /// </summary>
        operator SdaiInstance() const { return m_instance; }

    protected:
        //
        //
        int getENUM(TextValue attrName, TextValue rEnumValues[])
        {
            TextValue value = NULL;
            sdaiGetAttrBN(m_instance, attrName, sdaiENUM, (void*) &value);
            return EnumerationNameToIndex(rEnumValues, value);
        }
    };


    //
    // Entities forward declarations
    //

    class action;
    class action_directive;
    class action_method;
    class address;
    class analysis_method;
    class analysis_method_documented;
    class analysis_method_dynamic;
    class analysis_method_pseudo_dynamic;
    class analysis_method_static;
    class analysis_model;
    class analysis_model_2D;
    class analysis_model_3D;
    class analysis_model_child;
    class analysis_model_located;
    class analysis_model_mapping;
    class analysis_model_relationship;
    class analysis_result;
    class analysis_result_element;
    class analysis_result_element_curve;
    class analysis_result_element_node;
    class analysis_result_element_point;
    class analysis_result_element_surface;
    class analysis_result_element_surface_stresses;
    class analysis_result_element_surface_tractions;
    class analysis_result_element_volume;
    class analysis_result_element_volume_stress_tensor;
    class analysis_result_node;
    class analysis_results_set;
    class analysis_results_set_basic;
    class analysis_results_set_combined;
    class analysis_results_set_envelope;
    class analysis_results_set_redistributed;
    class applied_load;
    class applied_load_dynamic;
    class applied_load_dynamic_acceleration;
    class applied_load_dynamic_velocity;
    class applied_load_static;
    class applied_load_static_displacement;
    class applied_load_static_force;
    class applied_load_static_pressure;
    class approval;
    class approval_status;
    class area_measure_with_unit;
    class area_unit;
    class assemble;
    class assembly;
    class assembly_design;
    class assembly_design_child;
    class assembly_design_structural_connection;
    class assembly_design_structural_connection_external;
    class assembly_design_structural_connection_internal;
    class assembly_design_structural_frame;
    class assembly_design_structural_member;
    class assembly_design_structural_member_cubic;
    class assembly_design_structural_member_linear;
    class assembly_design_structural_member_linear_beam;
    class assembly_design_structural_member_linear_brace;
    class assembly_design_structural_member_linear_cable;
    class assembly_design_structural_member_linear_cambered;
    class assembly_design_structural_member_linear_cambered_absolute;
    class assembly_design_structural_member_linear_cambered_relative;
    class assembly_design_structural_member_linear_column;
    class assembly_design_structural_member_planar;
    class assembly_design_structural_member_planar_plate;
    class assembly_design_structural_member_planar_slab;
    class assembly_design_structural_member_planar_wall;
    class assembly_manufacturing;
    class assembly_manufacturing_child;
    class assembly_map;
    class assembly_relationship;
    class assembly_with_bounding_box;
    class assembly_with_shape;
    class axis1_placement;
    class axis2_placement_2d;
    class axis2_placement_3d;
    class b_spline_curve;
    class b_spline_curve_with_knots;
    class b_spline_surface;
    class b_spline_surface_with_knots;
    class b_spline_volume;
    class b_spline_volume_with_knots;
    class bend;
    class bezier_curve;
    class bezier_surface;
    class bezier_volume;
    class block;
    class block_volume;
    class boolean_result;
    class boundary_condition;
    class boundary_condition_logical;
    class boundary_condition_skewed;
    class boundary_condition_spring_linear;
    class boundary_condition_spring_non_linear;
    class boundary_condition_warping;
    class boundary_curve;
    class bounded_curve;
    class bounded_pcurve;
    class bounded_surface;
    class bounded_surface_curve;
    class box_domain;
    class boxed_half_space;
    class braze;
    class brep_2d;
    class brep_with_voids;
    class building;
    class building_complex;
    class building_with_shape;
    class calendar_date;
    class cartesian_point;
    class cartesian_transformation_operator;
    class cartesian_transformation_operator_2d;
    class cartesian_transformation_operator_3d;
    class certification;
    class certification_type;
    class chemical_mechanism;
    class circle;
    class circular_area;
    class closed_shell;
    class clothoid;
    class coating;
    class composite_curve;
    class composite_curve_on_surface;
    class composite_curve_segment;
    class conic;
    class conical_surface;
    class connected_edge_set;
    class connected_face_set;
    class context_dependent_unit;
    class contract;
    class contract_type;
    class conversion_based_unit;
    class convex_hexahedron;
    class coord_system;
    class coord_system_cartesian_2d;
    class coord_system_cartesian_3d;
    class coord_system_child;
    class coord_system_cylindrical;
    class coord_system_spherical;
    class coordinated_universal_time_offset;
    class csg_solid;
    class currency_measure_with_unit;
    class currency_rate_with_unit;
    class currency_unit;
    class curve;
    class curve_bounded_surface;
    class curve_replica;
    class cut;
    class cyclide_segment_solid;
    class cylindrical_point;
    class cylindrical_surface;
    class cylindrical_volume;
    class date;
    class date_and_time;
    class definitional_representation;
    class degenerate_pcurve;
    class degenerate_toroidal_surface;
    class derived_measure_with_unit;
    class derived_unit;
    class derived_unit_element;
    class description_attribute;
    class design_criterion;
    class design_criterion_documented;
    class design_joint_system;
    class design_part;
    class design_result;
    class design_result_connection;
    class design_result_joint_system;
    class design_result_mapped;
    class design_result_member;
    class design_result_part;
    class design_result_resolved;
    class dimensional_exponents;
    class directed_action;
    class direction;
    class dispatch;
    class document;
    class document_relationship;
    class document_representation_type;
    class document_standard;
    class document_type;
    class document_usage;
    class document_usage_constraint;
    class document_with_class;
    class eccentric_cone;
    class eccentric_conical_volume;
    class edge;
    class edge_based_wireframe_model;
    class edge_curve;
    class edge_loop;
    class effective_buckling_length;
    class element;
    class element_curve;
    class element_curve_complex;
    class element_curve_simple;
    class element_eccentricity;
    class element_mapping;
    class element_node_connectivity;
    class element_point;
    class element_point_grounded_damper;
    class element_point_grounded_spring;
    class element_point_stationary_mass;
    class element_surface;
    class element_surface_complex;
    class element_surface_plane;
    class element_surface_profiled;
    class element_surface_simple;
    class element_volume;
    class element_volume_complex;
    class element_volume_simple;
    class element_with_material;
    class elementary_surface;
    class ellipse;
    class ellipsoid;
    class ellipsoid_volume;
    class elliptic_area;
    class evaluated_degenerate_pcurve;
    class executed_action;
    class extruded_area_solid;
    class extruded_face_solid;
    class face;
    class face_based_surface_model;
    class face_bound;
    class face_outer_bound;
    class face_surface;
    class faceted_brep;
    class faceted_primitive;
    class fastener;
    class fastener_complex;
    class fastener_mechanism;
    class fastener_mechanism_with_position;
    class fastener_simple;
    class fastener_simple_bolt;
    class fastener_simple_bolt_circular_head;
    class fastener_simple_bolt_hexagonal_head;
    class fastener_simple_bolt_square_head;
    class fastener_simple_countersunk;
    class fastener_simple_curved;
    class fastener_simple_nail;
    class fastener_simple_nut;
    class fastener_simple_nut_circular;
    class fastener_simple_nut_closed;
    class fastener_simple_nut_hexagonal;
    class fastener_simple_nut_square;
    class fastener_simple_pin;
    class fastener_simple_screw;
    class fastener_simple_screw_machine;
    class fastener_simple_screw_self_drilling;
    class fastener_simple_screw_self_tapping;
    class fastener_simple_screw_tapered;
    class fastener_simple_shear_connector;
    class fastener_simple_stud;
    class fastener_simple_washer;
    class fastener_simple_washer_load_indicating;
    class fastener_simple_washer_tapered;
    class feature;
    class feature_cutting_plane;
    class feature_edge_chamfer;
    class feature_edge_chamfer_fillet;
    class feature_edge_chamfer_rounding;
    class feature_edge_chamfer_straight;
    class feature_surface;
    class feature_surface_complex;
    class feature_surface_name_tag;
    class feature_surface_point;
    class feature_surface_point_mark;
    class feature_surface_simple;
    class feature_surface_treatment;
    class feature_surface_with_layout;
    class feature_thread;
    class feature_volume;
    class feature_volume_complex;
    class feature_volume_curved;
    class feature_volume_curved_line;
    class feature_volume_hole;
    class feature_volume_hole_circular;
    class feature_volume_hole_circular_threaded;
    class feature_volume_hole_rectangular;
    class feature_volume_hole_slotted;
    class feature_volume_hole_slotted_curved;
    class feature_volume_prismatic;
    class feature_volume_prismatic_chamfer;
    class feature_volume_prismatic_flange_chamfer;
    class feature_volume_prismatic_flange_notch;
    class feature_volume_prismatic_notch;
    class feature_volume_prismatic_skewed_end;
    class feature_volume_with_depth;
    class feature_volume_with_layout;
    class feature_volume_with_limit;
    class feature_volume_with_process;
    class fixed_reference_swept_surface;
    class flavour;
    class force_measure_with_unit;
    class force_per_length_measure_with_unit;
    class force_per_length_unit;
    class force_unit;
    class founded_item;
    class frequency_measure_with_unit;
    class frequency_unit;
    class functional_role;
    class functional_role_documented;
    class functionally_defined_transformation;
    class geographical_location;
    class geometric_curve_set;
    class geometric_representation_context;
    class geometric_representation_item;
    class geometric_set;
    class geometric_set_replica;
    class global_location;
    class global_uncertainty_assigned_context;
    class global_unit_assigned_context;
    class grid;
    class grid_intersection;
    class grid_intersection_resolved;
    class grid_level;
    class grid_of_building;
    class grid_of_site;
    class grid_of_structure;
    class grid_offset;
    class grid_orthogonal;
    class grid_radial;
    class grid_skewed;
    class gridline;
    class group;
    class group_assignment;
    class group_assignment_actioned;
    class group_assignment_approved;
    class group_of_analysis_data;
    class group_of_design_data;
    class group_of_generic_data;
    class group_of_physical_data;
    class group_of_project_definition_data;
    class group_of_structural_data;
    class group_relationship;
    class group_usage;
    class half_space_2d;
    class half_space_solid;
    class hexahedron_volume;
    class hyperbola;
    class id_attribute;
    class inertia_measure_with_unit;
    class inertia_unit;
    class intersection_curve;
    class item_cost_code;
    class item_cost_code_assigned;
    class item_cost_code_with_source;
    class item_defined_transformation;
    class item_property;
    class item_property_assigned;
    class item_property_with_source;
    class item_ref_source;
    class item_ref_source_documented;
    class item_ref_source_library;
    class item_ref_source_proprietary;
    class item_ref_source_standard;
    class item_reference;
    class item_reference_assigned;
    class item_reference_library;
    class item_reference_proprietary;
    class item_reference_standard;
    class joint_system;
    class joint_system_amorphous;
    class joint_system_chemical;
    class joint_system_complex;
    class joint_system_mechanical;
    class joint_system_welded;
    class joint_system_welded_linear;
    class joint_system_welded_point;
    class joint_system_welded_surface;
    class joint_system_welded_with_shape;
    class length_measure_with_unit;
    class length_unit;
    class line;
    class linear_acceleration_measure_with_unit;
    class linear_acceleration_unit;
    class linear_stiffness_measure_with_unit;
    class linear_stiffness_unit;
    class linear_velocity_measure_with_unit;
    class linear_velocity_unit;
    class load;
    class load_case;
    class load_case_documented;
    class load_combination_occurrence;
    class load_connection;
    class load_element;
    class load_element_concentrated;
    class load_element_distributed;
    class load_element_distributed_curve;
    class load_element_distributed_curve_line;
    class load_element_distributed_surface;
    class load_element_distributed_surface_uniform;
    class load_element_distributed_surface_varying;
    class load_element_thermal;
    class load_member;
    class load_member_concentrated;
    class load_member_distributed;
    class load_member_distributed_curve;
    class load_member_distributed_curve_line;
    class load_member_distributed_surface;
    class load_member_distributed_surface_uniform;
    class load_member_distributed_surface_varying;
    class load_node;
    class loaded_product;
    class loading_combination;
    class local_time;
    class located_assembly;
    class located_assembly_child;
    class located_assembly_marked;
    class located_feature;
    class located_feature_for_assembly;
    class located_feature_for_design_part;
    class located_feature_for_located_assembly;
    class located_feature_for_located_part;
    class located_feature_for_part;
    class located_feature_joint_dependent;
    class located_item;
    class located_joint_system;
    class located_part;
    class located_part_joint;
    class located_part_marked;
    class located_site;
    class located_structure;
    class loop;
    class managed_application_installation;
    class managed_data_creation;
    class managed_data_deleted;
    class managed_data_export;
    class managed_data_group;
    class managed_data_import;
    class managed_data_item;
    class managed_data_item_with_history;
    class managed_data_modification;
    class managed_data_transaction;
    class manifold_solid_brep;
    class map_location;
    class mapped_item;
    class mass_measure_with_unit;
    class mass_per_length_measure_with_unit;
    class mass_per_length_unit;
    class mass_unit;
    class material;
    class material_anisotropic;
    class material_constituent;
    class material_elasticity;
    class material_hardness;
    class material_isotropic;
    class material_mass_density;
    class material_orthotropic;
    class material_property_context;
    class material_property_context_dimensional;
    class material_property_context_loading;
    class material_property_context_strain;
    class material_property_context_stress;
    class material_property_context_temperature;
    class material_representation;
    class material_representation_item;
    class material_strength;
    class material_thermal_expansion;
    class material_toughness;
    class measure_qualification;
    class measure_with_unit;
    class media_content;
    class media_content_drawing;
    class media_file;
    class media_file_cnc;
    class media_file_drawing;
    class modulus_measure_with_unit;
    class modulus_unit;
    class moment_measure_with_unit;
    class moment_unit;
    class move;
    class name_attribute;
    class named_unit;
    class node;
    class node_dependency;
    class object_role;
    class offset_curve_2d;
    class offset_curve_3d;
    class offset_surface;
    class open_path;
    class open_shell;
    class organization;
    class organization_relationship;
    class organization_relationship_contractual;
    class organizational_address;
    class oriented_closed_shell;
    class oriented_edge;
    class oriented_face;
    class oriented_open_shell;
    class oriented_path;
    class oriented_surface;
    class outer_boundary_curve;
    class parabola;
    class parametric_representation_context;
    class part;
    class part_complex;
    class part_derived;
    class part_map;
    class part_prismatic;
    class part_prismatic_complex;
    class part_prismatic_complex_tapered;
    class part_prismatic_simple;
    class part_prismatic_simple_cambered;
    class part_prismatic_simple_cambered_absolute;
    class part_prismatic_simple_cambered_relative;
    class part_prismatic_simple_castellated;
    class part_prismatic_simple_curved;
    class part_sheet;
    class part_sheet_bounded;
    class part_sheet_bounded_complex;
    class part_sheet_bounded_simple;
    class part_sheet_profiled;
    class path;
    class pcurve;
    class person;
    class person_and_organization;
    class person_and_organization_role;
    class personal_address;
    class physical_action;
    class physical_action_accidental;
    class physical_action_permanent;
    class physical_action_seismic;
    class physical_action_variable;
    class physical_action_variable_long_term;
    class physical_action_variable_short_term;
    class physical_action_variable_transient;
    class placement;
    class plane;
    class plane_angle_measure_with_unit;
    class plane_angle_unit;
    class point;
    class point_in_volume;
    class point_on_curve;
    class point_on_surface;
    class point_replica;
    class polar_point;
    class poly_loop;
    class polygonal_area;
    class polyline;
    class positive_length_measure_with_unit;
    class precision_qualifier;
    class pressure_measure_with_unit;
    class pressure_unit;
    class primitive_2d;
    class procure;
    class project;
    class project_data_group;
    class project_organization;
    class project_plan;
    class project_plan_item;
    class project_plan_item_relationship;
    class project_process_item;
    class pyramid_volume;
    class qualitative_uncertainty;
    class quasi_uniform_curve;
    class quasi_uniform_surface;
    class quasi_uniform_volume;
    class ratio_measure_with_unit;
    class ratio_unit;
    class rational_b_spline_curve;
    class rational_b_spline_surface;
    class rational_b_spline_volume;
    class reaction;
    class reaction_acceleration;
    class reaction_displacement;
    class reaction_dynamic;
    class reaction_equilibrium;
    class reaction_force;
    class reaction_velocity;
    class rectangular_area;
    class rectangular_composite_surface;
    class rectangular_pyramid;
    class rectangular_trimmed_surface;
    class release;
    class release_logical;
    class release_spring_linear;
    class release_spring_non_linear;
    class release_warping;
    class reparametrised_composite_curve_segment;
    class representation;
    class representation_context;
    class representation_item;
    class representation_map;
    class representation_relationship;
    class representation_relationship_with_transformation;
    class resistance;
    class resistance_axial;
    class resistance_bending;
    class resistance_shear;
    class restraint;
    class restraint_logical;
    class restraint_spring;
    class restraint_warping;
    class revolved_area_solid;
    class revolved_face_solid;
    class right_angular_wedge;
    class right_circular_cone;
    class right_circular_cylinder;
    class role_association;
    class rotational_acceleration_measure_with_unit;
    class rotational_acceleration_unit;
    class rotational_stiffness_measure_with_unit;
    class rotational_stiffness_unit;
    class rotational_velocity_measure_with_unit;
    class rotational_velocity_unit;
    class seam_curve;
    class section_profile;
    class section_profile_angle;
    class section_profile_centreline;
    class section_profile_channel;
    class section_profile_circle;
    class section_profile_circle_hollow;
    class section_profile_complex;
    class section_profile_compound;
    class section_profile_derived;
    class section_profile_edge_defined;
    class section_profile_i_type;
    class section_profile_i_type_asymmetric;
    class section_profile_i_type_rail;
    class section_profile_rectangle;
    class section_profile_rectangle_hollow;
    class section_profile_simple;
    class section_profile_t_type;
    class section_properties;
    class section_properties_asymmetric;
    class setting_out_point;
    class shape_representation;
    class shape_representation_with_units;
    class shell_based_surface_model;
    class shell_based_wireframe_model;
    class si_unit;
    class site;
    class site_with_shape;
    class solder;
    class solid_angle_measure_with_unit;
    class solid_angle_unit;
    class solid_model;
    class solid_replica;
    class sphere;
    class spherical_point;
    class spherical_surface;
    class spherical_volume;
    class standard_uncertainty;
    class step_file;
    class structural_frame_item;
    class structural_frame_item_approved;
    class structural_frame_item_certified;
    class structural_frame_item_documented;
    class structural_frame_item_priced;
    class structural_frame_item_relationship;
    class structural_frame_process;
    class structural_frame_product;
    class structural_frame_product_with_material;
    class structure;
    class subedge;
    class subface;
    class surface;
    class surface_curve;
    class surface_curve_swept_area_solid;
    class surface_curve_swept_face_solid;
    class surface_curve_swept_surface;
    class surface_of_linear_extrusion;
    class surface_of_revolution;
    class surface_patch;
    class surface_replica;
    class surface_treatment;
    class surface_treatment_clean;
    class surface_treatment_coat;
    class surface_treatment_grind;
    class surface_treatment_hard_stamp;
    class surface_treatment_thermal;
    class surface_treatment_thermal_timed;
    class swept_area_solid;
    class swept_face_solid;
    class swept_surface;
    class tetrahedron;
    class tetrahedron_volume;
    class thermodynamic_temperature_measure_with_unit;
    class thermodynamic_temperature_unit;
    class time_measure_with_unit;
    class time_unit;
    class topological_representation_item;
    class toroidal_surface;
    class toroidal_volume;
    class torus;
    class trimmed_curve;
    class trimmed_volume;
    class truncated_pyramid;
    class type_qualifier;
    class uncertainty_measure_with_unit;
    class uncertainty_qualifier;
    class uniform_curve;
    class uniform_surface;
    class uniform_volume;
    class vector;
    class versioned_action_request;
    class vertex;
    class vertex_loop;
    class vertex_point;
    class vertex_shell;
    class volume;
    class volume_measure_with_unit;
    class volume_unit;
    class wedge_volume;
    class weld;
    class weld_arc;
    class weld_beam;
    class weld_gas;
    class weld_mechanism;
    class weld_mechanism_complex;
    class weld_mechanism_fillet;
    class weld_mechanism_fillet_continuous;
    class weld_mechanism_fillet_intermittent;
    class weld_mechanism_groove;
    class weld_mechanism_groove_beveled;
    class weld_mechanism_groove_butt;
    class weld_mechanism_prismatic;
    class weld_mechanism_spot_seam;
    class weld_other;
    class weld_pressure;
    class weld_resistance;
    class weld_stud;
    class wire_shell;
    class zone;
    class zone_bounded;
    class zone_of_building;
    class zone_of_building_storey;
    class zone_of_project;
    class zone_of_site;
    class zone_of_structure;
    class zone_of_structure_sequence;
    class zone_of_structure_sequence_lot;

    class assembly_component_select;
    class assembly_component_select_get;
    class assembly_component_select_put;
    class axis2_placement;
    class axis2_placement_get;
    class axis2_placement_put;
    class boolean_operand;
    class boolean_operand_get;
    class boolean_operand_put;
    class csg_primitive;
    class csg_primitive_get;
    class csg_primitive_put;
    class csg_select;
    class csg_select_get;
    class csg_select_put;
    class curve_on_surface;
    class curve_on_surface_get;
    class curve_on_surface_put;
    class derived_measure;
    class derived_measure_get;
    class derived_measure_put;
    class description_attribute_select;
    class description_attribute_select_get;
    class description_attribute_select_put;
    class founded_item_select;
    class founded_item_select_get;
    class founded_item_select_put;
    class geometric_set_select;
    class geometric_set_select_get;
    class geometric_set_select_put;
    class id_attribute_select;
    class id_attribute_select_get;
    class id_attribute_select_put;
    class measure_select;
    class measure_select_get;
    class measure_select_put;
    class measure_value;
    class measure_value_get;
    class measure_value_put;
    class name_attribute_select;
    class name_attribute_select_get;
    class name_attribute_select_put;
    class orientation_select;
    class orientation_select_get;
    class orientation_select_put;
    class part_select;
    class part_select_get;
    class part_select_put;
    class pcurve_or_surface;
    class pcurve_or_surface_get;
    class pcurve_or_surface_put;
    class product_item_select;
    class product_item_select_get;
    class product_item_select_put;
    class project_select;
    class project_select_get;
    class project_select_put;
    class reversible_topology;
    class reversible_topology_get;
    class reversible_topology_put;
    class reversible_topology_item;
    class reversible_topology_item_get;
    class reversible_topology_item_put;
    class role_select;
    class role_select_get;
    class role_select_put;
    class select_analysis_item;
    class select_analysis_item_get;
    class select_analysis_item_put;
    class select_analysis_model_item;
    class select_analysis_model_item_get;
    class select_analysis_model_item_put;
    class select_data_item;
    class select_data_item_get;
    class select_data_item_put;
    class select_data_source;
    class select_data_source_get;
    class select_data_source_put;
    class select_design_item;
    class select_design_item_get;
    class select_design_item_put;
    class select_generic_item;
    class select_generic_item_get;
    class select_generic_item_put;
    class select_loading_item;
    class select_loading_item_get;
    class select_loading_item_put;
    class select_physical_item;
    class select_physical_item_get;
    class select_physical_item_put;
    class select_project_definition_item;
    class select_project_definition_item_get;
    class select_project_definition_item_put;
    class select_response_item;
    class select_response_item_get;
    class select_response_item_put;
    class select_structural_item;
    class select_structural_item_get;
    class select_structural_item_put;
    class shell;
    class shell_get;
    class shell_put;
    class site_select;
    class site_select_get;
    class site_select_put;
    class structure_select;
    class structure_select_get;
    class structure_select_put;
    class surface_model;
    class surface_model_get;
    class surface_model_put;
    class transformation;
    class transformation_get;
    class transformation_put;
    class trimming_select;
    class trimming_select_get;
    class trimming_select_put;
    class unit;
    class unit_get;
    class unit_put;
    class value_qualifier;
    class value_qualifier_get;
    class value_qualifier_put;
    class vector_or_direction;
    class vector_or_direction_get;
    class vector_or_direction_put;
    class wireframe_model;
    class wireframe_model_get;
    class wireframe_model_put;

        //
        // Enumerations
        //

    enum class action_source_accidential
    {
        fire = 0,
        impulse = 1,
        impact = 2,
        undefined = 3,
        ___unk = -1
    };

    enum class action_source_permanent
    {
        dead = 0,
        self_weight = 1,
        prestress = 2,
        lack_of_fit = 3,
        undefined = 4,
        ___unk = -1
    };

    enum class action_source_variable_long_term
    {
        live = 0,
        system_imperfection = 1,
        settlement = 2,
        temperature_effect = 3,
        undefined = 4,
        ___unk = -1
    };

    enum class action_source_variable_short_term
    {
        buoyancy = 0,
        wind = 1,
        snow = 2,
        ice = 3,
        current = 4,
        wave = 5,
        rain = 6,
        undefined = 7,
        ___unk = -1
    };

    enum class action_source_variable_transient
    {
        transport = 0,
        erection = 1,
        propping = 2,
        undefined = 3,
        ___unk = -1
    };

    enum class ahead_or_behind
    {
        ahead = 0,
        exact = 1,
        behind = 2,
        ___unk = -1
    };

    enum class b_spline_curve_form
    {
        polyline_form = 0,
        circular_arc = 1,
        elliptic_arc = 2,
        parabolic_arc = 3,
        hyperbolic_arc = 4,
        unspecified = 5,
        ___unk = -1
    };

    enum class b_spline_surface_form
    {
        plane_surf = 0,
        cylindrical_surf = 1,
        conical_surf = 2,
        spherical_surf = 3,
        toroidal_surf = 4,
        surf_of_revolution = 5,
        ruled_surf = 6,
        generalised_cone = 7,
        quadric_surf = 8,
        surf_of_linear_extrusion = 9,
        unspecified = 10,
        ___unk = -1
    };

    enum class bending_method
    {
        hot_bend = 0,
        cold_bend = 1,
        undefined = 2,
        ___unk = -1
    };

    enum class boolean_operator
    {
        union_ = 0,
        intersection = 1,
        difference = 2,
        ___unk = -1
    };

    enum class brazing_type
    {
        diffusion_brazing = 0,
        dip_brazing = 1,
        furnace_brazing = 2,
        induction_brazing = 3,
        infrared_brazing = 4,
        resistance_brazing = 5,
        torch_brazing = 6,
        ___unk = -1
    };

    enum class buckling_direction
    {
        x_dir = 0,
        y_dir = 1,
        z_dir = 2,
        ___unk = -1
    };

    enum class castellation_type
    {
        circular = 0,
        hexagonal = 1,
        octagonal = 2,
        undefined = 3,
        ___unk = -1
    };

    enum class chemical_mechanism_type
    {
        adhesive = 0,
        grout = 1,
        filler = 2,
        sealant = 3,
        undefined = 4,
        ___unk = -1
    };

    enum class cleaning_method
    {
        chemical_wash = 0,
        blast_clean = 1,
        undefined = 2,
        ___unk = -1
    };

    enum class coating_method
    {
        sprayed = 0,
        brushed = 1,
        dipped = 2,
        electroplated = 3,
        undefined = 4,
        ___unk = -1
    };

    enum class coating_purpose
    {
        corrosion_protection = 0,
        fire_protection = 1,
        aesthetic = 2,
        undefined = 3,
        ___unk = -1
    };

    enum class complexity_level
    {
        low = 0,
        medium = 1,
        high = 2,
        ___unk = -1
    };

    enum class connection_type
    {
        pinned = 0,
        semi_rigid_full_str = 1,
        semi_rigid_partial_str = 2,
        rigid_full_str = 3,
        rigid_partial_str = 4,
        ___unk = -1
    };

    enum class cutting_type
    {
        sawn = 0,
        flame_cut = 1,
        sheared = 2,
        punched = 3,
        drilled = 4,
        laser = 5,
        abrasion = 6,
        undefined = 7,
        ___unk = -1
    };

    enum class data_status_type
    {
        deleted = 0,
        superseded = 1,
        archived = 2,
        erroneous = 3,
        undefined = 4,
        ___unk = -1
    };

    enum class direct_or_indirect_action
    {
        direct_action = 0,
        indirect_action = 1,
        ___unk = -1
    };

    enum class drawing_class
    {
        assembly_drawing = 0,
        part_drawing = 1,
        placement_drawing = 2,
        undefined = 3,
        ___unk = -1
    };

    enum class dynamic_analysis_type
    {
        free_vibration = 0,
        stressed_free_vibration = 1,
        damped_vibration = 2,
        linear_dynamic = 3,
        response_spectrum = 4,
        undefined = 5,
        ___unk = -1
    };

    enum class elastic_or_plastic_resistance
    {
        elastic_resistance = 0,
        plastic_resistance = 1,
        ___unk = -1
    };

    enum class element_surface_shape
    {
        quadrilateral = 0,
        triangle = 1,
        ___unk = -1
    };

    enum class element_volume_shape
    {
        hexahedron_element = 0,
        wedge_element = 1,
        tetrahedron_element = 2,
        pyramid_element = 3,
        ___unk = -1
    };

    enum class fabrication_type
    {
        rolled = 0,
        welded = 1,
        cold_formed = 2,
        cast = 3,
        forged = 4,
        extruded = 5,
        undefined = 6,
        ___unk = -1
    };

    enum class frame_continuity
    {
        simple = 0,
        continuous = 1,
        semi_continuous = 2,
        ___unk = -1
    };

    enum class frame_type
    {
        space_frame = 0,
        space_truss = 1,
        plane_frame = 2,
        plane_truss = 3,
        grillage = 4,
        undefined = 5,
        ___unk = -1
    };

    enum class global_or_local_load
    {
        global_load = 0,
        local_load = 1,
        ___unk = -1
    };

    enum class global_or_local_resistance
    {
        global_resistance = 0,
        local_resistance = 1,
        ___unk = -1
    };

    enum class knot_type
    {
        UNIFORM_KNOTS = 0,
        UNSPECIFIED = 1,
        QUASI_UNIFORM_KNOTS = 2,
        PIECEWISE_BEZIER_KNOTS = 3,
        ___unk = -1
    };

    enum class left_or_right
    {
        left_hand = 0,
        right_hand = 1,
        ___unk = -1
    };

    enum class loading_status
    {
        load_increasing = 0,
        load_decreasing = 1,
        load_constant = 2,
        unloaded = 3,
        ___unk = -1
    };

    enum class maximum_or_minimum
    {
        maximum = 0,
        minimum = 1,
        ___unk = -1
    };

    enum class member_beam_role
    {
        edge_beam = 0,
        eaves_beam = 1,
        gantry_girder = 2,
        joist = 3,
        lintel = 4,
        portal_rafter = 5,
        purlin = 6,
        rafter = 7,
        ring_beam = 8,
        side_rail = 9,
        waling_beam = 10,
        ___unk = -1
    };

    enum class member_beam_type
    {
        box_girder = 0,
        fish_bellied_beam = 1,
        haunched_beam = 2,
        plate_girder = 3,
        stub_girder = 4,
        tapered_beam = 5,
        ___unk = -1
    };

    enum class member_brace_type
    {
        cross_brace = 0,
        diagonal_brace = 1,
        horizontal_brace = 2,
        knee_brace = 3,
        lateral_brace = 4,
        longitudinal_brace = 5,
        plan_brace = 6,
        raker = 7,
        sway_brace = 8,
        vertical_brace = 9,
        ___unk = -1
    };

    enum class member_cable_type
    {
        stay = 0,
        suspension_cable = 1,
        suspension_chain = 2,
        ___unk = -1
    };

    enum class member_class
    {
        primary_member = 0,
        secondary_member = 1,
        tertiary_member = 2,
        undefined_class = 3,
        ___unk = -1
    };

    enum class member_column_type
    {
        battened_column = 0,
        box_column = 1,
        compound_strut = 2,
        portal_column = 3,
        ___unk = -1
    };

    enum class member_cubic_type
    {
        floor = 0,
        stair = 1,
        ramp = 2,
        structural_core = 3,
        structural_shell = 4,
        undefined = 5,
        ___unk = -1
    };

    enum class member_linear_type
    {
        beam = 0,
        column = 1,
        truss_element = 2,
        brace = 3,
        spring_element = 4,
        cable = 5,
        pipe = 6,
        wire = 7,
        tie = 8,
        undefined = 9,
        arch = 10,
        beam_column = 11,
        ___unk = -1
    };

    enum class member_planar_type
    {
        wall = 0,
        slab = 1,
        stair_element = 2,
        ramp_element = 3,
        undefined = 4,
        plate = 5,
        ___unk = -1
    };

    enum class member_plate_type
    {
        bearing_plate = 0,
        diaphragm = 1,
        flange = 2,
        web = 3,
        ___unk = -1
    };

    enum class member_role
    {
        compression_member = 0,
        tension_member = 1,
        bending_member = 2,
        combined_member = 3,
        undefined_role = 4,
        ___unk = -1
    };

    enum class member_slab_type
    {
        flat_slab = 0,
        ribbed_slab = 1,
        solid_slab = 2,
        trough_slab = 3,
        voided_slab = 4,
        waffle_slab = 5,
        ___unk = -1
    };

    enum class member_wall_type
    {
        load_bearing_wall = 0,
        retaining_wall = 1,
        shear_wall = 2,
        ___unk = -1
    };

    enum class plane_stress_or_strain
    {
        plane_stress = 0,
        plane_strain = 1,
        undefined = 2,
        ___unk = -1
    };

    enum class preferred_surface_curve_representation
    {
        curve_3d = 0,
        pcurve_s1 = 1,
        pcurve_s2 = 2,
        ___unk = -1
    };

    enum class projected_or_true_length
    {
        projected_length = 0,
        true_length = 1,
        ___unk = -1
    };

    enum class shop_or_site
    {
        shop_process = 0,
        site_process = 1,
        undefined = 2,
        ___unk = -1
    };

    enum class si_prefix
    {
        EXA = 0,
        PETA = 1,
        TERA = 2,
        GIGA = 3,
        MEGA = 4,
        KILO = 5,
        HECTO = 6,
        DECA = 7,
        DECI = 8,
        CENTI = 9,
        MILLI = 10,
        MICRO = 11,
        NANO = 12,
        PICO = 13,
        FEMTO = 14,
        ATTO = 15,
        ___unk = -1
    };

    enum class si_unit_name
    {
        METRE = 0,
        GRAM = 1,
        SECOND = 2,
        AMPERE = 3,
        KELVIN = 4,
        MOLE = 5,
        CANDELA = 6,
        RADIAN = 7,
        STERADIAN = 8,
        HERTZ = 9,
        NEWTON = 10,
        PASCAL = 11,
        JOULE = 12,
        WATT = 13,
        COULOMB = 14,
        VOLT = 15,
        FARAD = 16,
        OHM = 17,
        SIEMENS = 18,
        WEBER = 19,
        TESLA = 20,
        HENRY = 21,
        DEGREE_CELSIUS = 22,
        LUMEN = 23,
        LUX = 24,
        BECQUEREL = 25,
        GRAY = 26,
        SIEVERT = 27,
        ___unk = -1
    };

    enum class soldering_type
    {
        dip_soldering = 0,
        furnace_soldering = 1,
        induction_soldering = 2,
        infrared_soldering = 3,
        iron_soldering = 4,
        resistance_soldering = 5,
        torch_soldering = 6,
        wave_soldering = 7,
        ___unk = -1
    };

    enum class spatial_variation
    {
        free_action = 0,
        fixed_action = 1,
        ___unk = -1
    };

    enum class start_or_end_face
    {
        start_face = 0,
        end_face = 1,
        ___unk = -1
    };

    enum class static_analysis_type
    {
        elastic_1st_order = 0,
        elastic_2nd_order = 1,
        rigid_plastic = 2,
        elasto_plastic = 3,
        elastic_perfectly_plastic = 4,
        undefined = 5,
        ___unk = -1
    };

    enum class static_or_dynamic
    {
        static_ = 0,
        dynamic = 1,
        quasi_dynamic = 2,
        ___unk = -1
    };

    enum class top_or_bottom
    {
        top_edge = 0,
        bottom_edge = 1,
        ___unk = -1
    };

    enum class transition_code
    {
        discontinuous = 0,
        continuous = 1,
        cont_same_gradient = 2,
        cont_same_gradient_same_curvature = 3,
        ___unk = -1
    };

    enum class trimming_preference
    {
        cartesian = 0,
        parameter = 1,
        unspecified = 2,
        ___unk = -1
    };

    enum class weld_alignment
    {
        staggered = 0,
        chained = 1,
        ___unk = -1
    };

    enum class weld_backing_type
    {
        none = 0,
        permanent = 1,
        copper_backing_bar = 2,
        ceramic_tape = 3,
        flare_backing_ring = 4,
        permanent_backing_ring = 5,
        removable_backing_ring = 6,
        user_defined = 7,
        ___unk = -1
    };

    enum class weld_configuration
    {
        butt_joint = 0,
        tee_joint = 1,
        corner_joint = 2,
        lap_joint = 3,
        edge_joint = 4,
        cruciform_joint = 5,
        undefined = 6,
        ___unk = -1
    };

    enum class weld_intermittent_rule
    {
        none = 0,
        fixed_rule = 1,
        member_depth = 2,
        percent_length = 3,
        ___unk = -1
    };

    enum class weld_penetration
    {
        full_penetration = 0,
        deep_penetration = 1,
        partial_penetration = 2,
        undefined = 3,
        ___unk = -1
    };

    enum class weld_shape_bevel
    {
        flare_single_V = 0,
        flare_double_V = 1,
        flare_single_bevel = 2,
        flare_double_bevel = 3,
        single_bevel = 4,
        double_bevel = 5,
        single_V = 6,
        double_V = 7,
        single_J = 8,
        double_J = 9,
        single_U = 10,
        double_U = 11,
        user_defined = 12,
        ___unk = -1
    };

    enum class weld_shape_butt
    {
        square = 0,
        scarf = 1,
        user_defined = 2,
        ___unk = -1
    };

    enum class weld_sidedness
    {
        one_side = 0,
        both_sides = 1,
        ___unk = -1
    };

    enum class weld_surface_shape
    {
        flush = 0,
        convex = 1,
        concave = 2,
        undefined = 3,
        ___unk = -1
    };

    enum class weld_taper_type
    {
        non_taper = 0,
        one_side_taper = 1,
        both_sides_taper = 2,
        ___unk = -1
    };

    enum class weld_type
    {
        butt_weld = 0,
        fillet_weld = 1,
        spot_weld = 2,
        plug_weld = 3,
        seam_weld = 4,
        slot_weld = 5,
        stud_weld = 6,
        surfacing_weld = 7,
        undefined = 8,
        ___unk = -1
    };

    enum class welding_type
    {
        fusion_weld = 0,
        friction_weld = 1,
        flash_weld = 2,
        laser_weld = 3,
        forge_weld = 4,
        undefined = 5,
        ___unk = -1
    };

    enum class welding_type_arc
    {
        generic_arc_welding = 0,
        metal_arc_welding = 1,
        manual_metal_arc_welding = 2,
        gravity_arc_welding = 3,
        self_shielded_arc_welding = 4,
        submerged_arc_welding = 5,
        gas_shielded_metal_arc_welding = 6,
        metal_inert_gas_welding = 7,
        metal_active_gas_welding = 8,
        tubular_inert_gas_welding = 9,
        tubular_active_gas_welding = 10,
        tungsten_inert_gas_welding = 11,
        atomic_hydrogen_welding = 12,
        plasma_arc_welding = 13,
        carbon_arc_welding = 14,
        magnetically_impelled_arc_butt_welding = 15,
        ___unk = -1
    };

    enum class welding_type_beam
    {
        electron_beam_welding = 0,
        laser_beam_welding = 1,
        gas_laser_welding = 2,
        ___unk = -1
    };

    enum class welding_type_gas
    {
        generic_gas_welding = 0,
        oxyacetylene_welding = 1,
        oxyhydrogen_welding = 2,
        oxypropane_welding = 3,
        ___unk = -1
    };

    enum class welding_type_other
    {
        aluminothermic_welding = 0,
        electroslag_welding = 1,
        electrogas_welding = 2,
        induction_welding = 3,
        induction_butt_welding = 4,
        induction_seam_welding = 5,
        infrared_welding = 6,
        percussion_welding = 7,
        ___unk = -1
    };

    enum class welding_type_pressure
    {
        generic_pressure_welding = 0,
        ultrasonic_welding = 1,
        friction_welding = 2,
        forge_welding = 3,
        explosive_welding = 4,
        diffusion_welding = 5,
        oxyfuel_gas_pressure_welding = 6,
        cold_pressure_welding = 7,
        hot_pressure_welding = 8,
        roll_welding = 9,
        high_frequency_pressure_welding = 10,
        ___unk = -1
    };

    enum class welding_type_resistance
    {
        generic_resistance_welding = 0,
        spot_welding = 1,
        seam_welding = 2,
        projection_welding = 3,
        flash_welding = 4,
        resistance_butt_welding = 5,
        high_frequency_resistance_welding = 6,
        ___unk = -1
    };

    enum class welding_type_stud
    {
        generic_stud_welding = 0,
        resistance_stud_welding = 1,
        drawn_arc_stud_welding = 2,
        friction_stud_welding = 3,
        ___unk = -1
    };
    //
    static TextValue action_source_accidential_[] = {"fire", "impulse", "impact", "undefined", NULL};
    static TextValue action_source_permanent_[] = {"dead", "self_weight", "prestress", "lack_of_fit", "undefined", NULL};
    static TextValue action_source_variable_long_term_[] = {"live", "system_imperfection", "settlement", "temperature_effect", "undefined", NULL};
    static TextValue action_source_variable_short_term_[] = {"buoyancy", "wind", "snow", "ice", "current", "wave", "rain", "undefined", NULL};
    static TextValue action_source_variable_transient_[] = {"transport", "erection", "propping", "undefined", NULL};
    static TextValue ahead_or_behind_[] = {"ahead", "exact", "behind", NULL};
    static TextValue b_spline_curve_form_[] = {"polyline_form", "circular_arc", "elliptic_arc", "parabolic_arc", "hyperbolic_arc", "unspecified", NULL};
    static TextValue b_spline_surface_form_[] = {"plane_surf", "cylindrical_surf", "conical_surf", "spherical_surf", "toroidal_surf", "surf_of_revolution", "ruled_surf", "generalised_cone", "quadric_surf", "surf_of_linear_extrusion", "unspecified", NULL};
    static TextValue bending_method_[] = {"hot_bend", "cold_bend", "undefined", NULL};
    static TextValue boolean_operator_[] = {"union", "intersection", "difference", NULL};
    static TextValue brazing_type_[] = {"diffusion_brazing", "dip_brazing", "furnace_brazing", "induction_brazing", "infrared_brazing", "resistance_brazing", "torch_brazing", NULL};
    static TextValue buckling_direction_[] = {"x_dir", "y_dir", "z_dir", NULL};
    static TextValue castellation_type_[] = {"circular", "hexagonal", "octagonal", "undefined", NULL};
    static TextValue chemical_mechanism_type_[] = {"adhesive", "grout", "filler", "sealant", "undefined", NULL};
    static TextValue cleaning_method_[] = {"chemical_wash", "blast_clean", "undefined", NULL};
    static TextValue coating_method_[] = {"sprayed", "brushed", "dipped", "electroplated", "undefined", NULL};
    static TextValue coating_purpose_[] = {"corrosion_protection", "fire_protection", "aesthetic", "undefined", NULL};
    static TextValue complexity_level_[] = {"low", "medium", "high", NULL};
    static TextValue connection_type_[] = {"pinned", "semi_rigid_full_str", "semi_rigid_partial_str", "rigid_full_str", "rigid_partial_str", NULL};
    static TextValue cutting_type_[] = {"sawn", "flame_cut", "sheared", "punched", "drilled", "laser", "abrasion", "undefined", NULL};
    static TextValue data_status_type_[] = {"deleted", "superseded", "archived", "erroneous", "undefined", NULL};
    static TextValue direct_or_indirect_action_[] = {"direct_action", "indirect_action", NULL};
    static TextValue drawing_class_[] = {"assembly_drawing", "part_drawing", "placement_drawing", "undefined", NULL};
    static TextValue dynamic_analysis_type_[] = {"free_vibration", "stressed_free_vibration", "damped_vibration", "linear_dynamic", "response_spectrum", "undefined", NULL};
    static TextValue elastic_or_plastic_resistance_[] = {"elastic_resistance", "plastic_resistance", NULL};
    static TextValue element_surface_shape_[] = {"quadrilateral", "triangle", NULL};
    static TextValue element_volume_shape_[] = {"hexahedron_element", "wedge_element", "tetrahedron_element", "pyramid_element", NULL};
    static TextValue fabrication_type_[] = {"rolled", "welded", "cold_formed", "cast", "forged", "extruded", "undefined", NULL};
    static TextValue frame_continuity_[] = {"simple", "continuous", "semi_continuous", NULL};
    static TextValue frame_type_[] = {"space_frame", "space_truss", "plane_frame", "plane_truss", "grillage", "undefined", NULL};
    static TextValue global_or_local_load_[] = {"global_load", "local_load", NULL};
    static TextValue global_or_local_resistance_[] = {"global_resistance", "local_resistance", NULL};
    static TextValue knot_type_[] = {"UNIFORM_KNOTS", "UNSPECIFIED", "QUASI_UNIFORM_KNOTS", "PIECEWISE_BEZIER_KNOTS", NULL};
    static TextValue left_or_right_[] = {"left_hand", "right_hand", NULL};
    static TextValue loading_status_[] = {"load_increasing", "load_decreasing", "load_constant", "unloaded", NULL};
    static TextValue maximum_or_minimum_[] = {"maximum", "minimum", NULL};
    static TextValue member_beam_role_[] = {"edge_beam", "eaves_beam", "gantry_girder", "joist", "lintel", "portal_rafter", "purlin", "rafter", "ring_beam", "side_rail", "waling_beam", NULL};
    static TextValue member_beam_type_[] = {"box_girder", "fish_bellied_beam", "haunched_beam", "plate_girder", "stub_girder", "tapered_beam", NULL};
    static TextValue member_brace_type_[] = {"cross_brace", "diagonal_brace", "horizontal_brace", "knee_brace", "lateral_brace", "longitudinal_brace", "plan_brace", "raker", "sway_brace", "vertical_brace", NULL};
    static TextValue member_cable_type_[] = {"stay", "suspension_cable", "suspension_chain", NULL};
    static TextValue member_class_[] = {"primary_member", "secondary_member", "tertiary_member", "undefined_class", NULL};
    static TextValue member_column_type_[] = {"battened_column", "box_column", "compound_strut", "portal_column", NULL};
    static TextValue member_cubic_type_[] = {"floor", "stair", "ramp", "structural_core", "structural_shell", "undefined", NULL};
    static TextValue member_linear_type_[] = {"beam", "column", "truss_element", "brace", "spring_element", "cable", "pipe", "wire", "tie", "undefined", "arch", "beam_column", NULL};
    static TextValue member_planar_type_[] = {"wall", "slab", "stair_element", "ramp_element", "undefined", "plate", NULL};
    static TextValue member_plate_type_[] = {"bearing_plate", "diaphragm", "flange", "web", NULL};
    static TextValue member_role_[] = {"compression_member", "tension_member", "bending_member", "combined_member", "undefined_role", NULL};
    static TextValue member_slab_type_[] = {"flat_slab", "ribbed_slab", "solid_slab", "trough_slab", "voided_slab", "waffle_slab", NULL};
    static TextValue member_wall_type_[] = {"load_bearing_wall", "retaining_wall", "shear_wall", NULL};
    static TextValue plane_stress_or_strain_[] = {"plane_stress", "plane_strain", "undefined", NULL};
    static TextValue preferred_surface_curve_representation_[] = {"curve_3d", "pcurve_s1", "pcurve_s2", NULL};
    static TextValue projected_or_true_length_[] = {"projected_length", "true_length", NULL};
    static TextValue shop_or_site_[] = {"shop_process", "site_process", "undefined", NULL};
    static TextValue si_prefix_[] = {"EXA", "PETA", "TERA", "GIGA", "MEGA", "KILO", "HECTO", "DECA", "DECI", "CENTI", "MILLI", "MICRO", "NANO", "PICO", "FEMTO", "ATTO", NULL};
    static TextValue si_unit_name_[] = {"METRE", "GRAM", "SECOND", "AMPERE", "KELVIN", "MOLE", "CANDELA", "RADIAN", "STERADIAN", "HERTZ", "NEWTON", "PASCAL", "JOULE", "WATT", "COULOMB", "VOLT", "FARAD", "OHM", "SIEMENS", "WEBER", "TESLA", "HENRY", "DEGREE_CELSIUS", "LUMEN", "LUX", "BECQUEREL", "GRAY", "SIEVERT", NULL};
    static TextValue soldering_type_[] = {"dip_soldering", "furnace_soldering", "induction_soldering", "infrared_soldering", "iron_soldering", "resistance_soldering", "torch_soldering", "wave_soldering", NULL};
    static TextValue spatial_variation_[] = {"free_action", "fixed_action", NULL};
    static TextValue start_or_end_face_[] = {"start_face", "end_face", NULL};
    static TextValue static_analysis_type_[] = {"elastic_1st_order", "elastic_2nd_order", "rigid_plastic", "elasto_plastic", "elastic_perfectly_plastic", "undefined", NULL};
    static TextValue static_or_dynamic_[] = {"static", "dynamic", "quasi_dynamic", NULL};
    static TextValue top_or_bottom_[] = {"top_edge", "bottom_edge", NULL};
    static TextValue transition_code_[] = {"discontinuous", "continuous", "cont_same_gradient", "cont_same_gradient_same_curvature", NULL};
    static TextValue trimming_preference_[] = {"cartesian", "parameter", "unspecified", NULL};
    static TextValue weld_alignment_[] = {"staggered", "chained", NULL};
    static TextValue weld_backing_type_[] = {"none", "permanent", "copper_backing_bar", "ceramic_tape", "flare_backing_ring", "permanent_backing_ring", "removable_backing_ring", "user_defined", NULL};
    static TextValue weld_configuration_[] = {"butt_joint", "tee_joint", "corner_joint", "lap_joint", "edge_joint", "cruciform_joint", "undefined", NULL};
    static TextValue weld_intermittent_rule_[] = {"none", "fixed_rule", "member_depth", "percent_length", NULL};
    static TextValue weld_penetration_[] = {"full_penetration", "deep_penetration", "partial_penetration", "undefined", NULL};
    static TextValue weld_shape_bevel_[] = {"flare_single_V", "flare_double_V", "flare_single_bevel", "flare_double_bevel", "single_bevel", "double_bevel", "single_V", "double_V", "single_J", "double_J", "single_U", "double_U", "user_defined", NULL};
    static TextValue weld_shape_butt_[] = {"square", "scarf", "user_defined", NULL};
    static TextValue weld_sidedness_[] = {"one_side", "both_sides", NULL};
    static TextValue weld_surface_shape_[] = {"flush", "convex", "concave", "undefined", NULL};
    static TextValue weld_taper_type_[] = {"non_taper", "one_side_taper", "both_sides_taper", NULL};
    static TextValue weld_type_[] = {"butt_weld", "fillet_weld", "spot_weld", "plug_weld", "seam_weld", "slot_weld", "stud_weld", "surfacing_weld", "undefined", NULL};
    static TextValue welding_type_[] = {"fusion_weld", "friction_weld", "flash_weld", "laser_weld", "forge_weld", "undefined", NULL};
    static TextValue welding_type_arc_[] = {"generic_arc_welding", "metal_arc_welding", "manual_metal_arc_welding", "gravity_arc_welding", "self_shielded_arc_welding", "submerged_arc_welding", "gas_shielded_metal_arc_welding", "metal_inert_gas_welding", "metal_active_gas_welding", "tubular_inert_gas_welding", "tubular_active_gas_welding", "tungsten_inert_gas_welding", "atomic_hydrogen_welding", "plasma_arc_welding", "carbon_arc_welding", "magnetically_impelled_arc_butt_welding", NULL};
    static TextValue welding_type_beam_[] = {"electron_beam_welding", "laser_beam_welding", "gas_laser_welding", NULL};
    static TextValue welding_type_gas_[] = {"generic_gas_welding", "oxyacetylene_welding", "oxyhydrogen_welding", "oxypropane_welding", NULL};
    static TextValue welding_type_other_[] = {"aluminothermic_welding", "electroslag_welding", "electrogas_welding", "induction_welding", "induction_butt_welding", "induction_seam_welding", "infrared_welding", "percussion_welding", NULL};
    static TextValue welding_type_pressure_[] = {"generic_pressure_welding", "ultrasonic_welding", "friction_welding", "forge_welding", "explosive_welding", "diffusion_welding", "oxyfuel_gas_pressure_welding", "cold_pressure_welding", "hot_pressure_welding", "roll_welding", "high_frequency_pressure_welding", NULL};
    static TextValue welding_type_resistance_[] = {"generic_resistance_welding", "spot_welding", "seam_welding", "projection_welding", "flash_welding", "resistance_butt_welding", "high_frequency_resistance_welding", NULL};
    static TextValue welding_type_stud_[] = {"generic_stud_welding", "resistance_stud_welding", "drawn_arc_stud_welding", "friction_stud_welding", NULL};

    //
    // Defined types
    // 
    typedef double area_measure;
    typedef bool boolean_value;
    typedef IntValue cardinal_point_ref;
    typedef double context_dependent_measure;
    typedef double count_measure;
    typedef IntValue day_in_month_number;
    typedef IntValue degrees_rotation;
    typedef TextValue descriptive_measure;
    typedef IntValue dimension_count;
    typedef double force_measure;
    typedef double force_per_length_measure;
    typedef double frequency_measure;
    typedef TextValue globally_unique_id;
    typedef IntValue hour_in_day;
    typedef TextValue identifier;
    typedef double inertia_measure;
    typedef TextValue label;
    typedef double length_measure;
    typedef double linear_acceleration_measure;
    typedef double linear_stiffness_measure;
    typedef double linear_velocity_measure;
    typedef std::list<reversible_topology_item> list_of_reversible_topology_item;
    template <typename TList> class list_of_reversible_topology_itemSerializer : public AggrSerializerSelect<TList, reversible_topology_item> {};
    typedef double mass_measure;
    typedef double mass_per_length_measure;
    typedef IntValue minute_in_hour;
    typedef IntValue minutes_rotation;
    typedef double modulus_measure;
    typedef double moment_measure;
    typedef IntValue month_in_year_number;
    typedef double numeric_measure;
    typedef double parameter_value;
    typedef double plane_angle_measure;
    typedef length_measure positive_length_measure;
    typedef plane_angle_measure positive_plane_angle_measure;
    typedef double ratio_measure;
    typedef double positive_ratio_measure;
    typedef double pressure_measure;
    typedef double rotational_acceleration_measure;
    typedef double rotational_stiffness_measure;
    typedef double rotational_velocity_measure;
    typedef double second_in_minute;
    typedef double seconds_rotation;
    typedef std::list<reversible_topology_item> set_of_reversible_topology_item;
    template <typename TList> class set_of_reversible_topology_itemSerializer : public AggrSerializerSelect<TList, reversible_topology_item> {};
    typedef double solid_angle_measure;
    typedef TextValue text;
    typedef double thermodynamic_temperature_measure;
    typedef double time_measure;
    typedef double volume_measure;
    typedef IntValue year_number;

    class assembly_component_select : public Select
    {
    public:
        assembly_component_select(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        assembly_component_select(Select* outer) : Select(outer) {}

        bool is_located_assembly() { return IsADBEntity("located_assembly"); }
        located_assembly get_located_assembly();
        void put_located_assembly(located_assembly inst);

        bool is_located_part() { return IsADBEntity("located_part"); }
        located_part get_located_part();
        void put_located_part(located_part inst);

        bool is_located_feature() { return IsADBEntity("located_feature"); }
        located_feature get_located_feature();
        void put_located_feature(located_feature inst);

        bool is_located_joint_system() { return IsADBEntity("located_joint_system"); }
        located_joint_system get_located_joint_system();
        void put_located_joint_system(located_joint_system inst);
    };


    class assembly_component_select_get : public Select
    {
    public:
        assembly_component_select_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        assembly_component_select_get(Select* outer) : Select(outer) {}
        bool is_located_assembly() { return IsADBEntity("located_assembly"); }
        located_assembly get_located_assembly();
        bool is_located_part() { return IsADBEntity("located_part"); }
        located_part get_located_part();
        bool is_located_feature() { return IsADBEntity("located_feature"); }
        located_feature get_located_feature();
        bool is_located_joint_system() { return IsADBEntity("located_joint_system"); }
        located_joint_system get_located_joint_system();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class assembly_component_select_put : public Select
    {
    public:
        assembly_component_select_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        assembly_component_select_put(Select* outer) : Select(outer) {}
        void put_located_assembly(located_assembly inst);
        void put_located_part(located_part inst);
        void put_located_feature(located_feature inst);
        void put_located_joint_system(located_joint_system inst);
    };


    class axis2_placement : public Select
    {
    public:
        axis2_placement(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        axis2_placement(Select* outer) : Select(outer) {}

        bool is_axis2_placement_2d() { return IsADBEntity("axis2_placement_2d"); }
        axis2_placement_2d get_axis2_placement_2d();
        void put_axis2_placement_2d(axis2_placement_2d inst);

        bool is_axis2_placement_3d() { return IsADBEntity("axis2_placement_3d"); }
        axis2_placement_3d get_axis2_placement_3d();
        void put_axis2_placement_3d(axis2_placement_3d inst);
    };


    class axis2_placement_get : public Select
    {
    public:
        axis2_placement_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        axis2_placement_get(Select* outer) : Select(outer) {}
        bool is_axis2_placement_2d() { return IsADBEntity("axis2_placement_2d"); }
        axis2_placement_2d get_axis2_placement_2d();
        bool is_axis2_placement_3d() { return IsADBEntity("axis2_placement_3d"); }
        axis2_placement_3d get_axis2_placement_3d();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class axis2_placement_put : public Select
    {
    public:
        axis2_placement_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        axis2_placement_put(Select* outer) : Select(outer) {}
        void put_axis2_placement_2d(axis2_placement_2d inst);
        void put_axis2_placement_3d(axis2_placement_3d inst);
    };


    class csg_primitive : public Select
    {
    public:
        csg_primitive(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        csg_primitive(Select* outer) : Select(outer) {}

        bool is_sphere() { return IsADBEntity("sphere"); }
        sphere get_sphere();
        void put_sphere(sphere inst);

        bool is_ellipsoid() { return IsADBEntity("ellipsoid"); }
        ellipsoid get_ellipsoid();
        void put_ellipsoid(ellipsoid inst);

        bool is_block() { return IsADBEntity("block"); }
        block get_block();
        void put_block(block inst);

        bool is_right_angular_wedge() { return IsADBEntity("right_angular_wedge"); }
        right_angular_wedge get_right_angular_wedge();
        void put_right_angular_wedge(right_angular_wedge inst);

        bool is_faceted_primitive() { return IsADBEntity("faceted_primitive"); }
        faceted_primitive get_faceted_primitive();
        void put_faceted_primitive(faceted_primitive inst);

        bool is_rectangular_pyramid() { return IsADBEntity("rectangular_pyramid"); }
        rectangular_pyramid get_rectangular_pyramid();
        void put_rectangular_pyramid(rectangular_pyramid inst);

        bool is_torus() { return IsADBEntity("torus"); }
        torus get_torus();
        void put_torus(torus inst);

        bool is_right_circular_cone() { return IsADBEntity("right_circular_cone"); }
        right_circular_cone get_right_circular_cone();
        void put_right_circular_cone(right_circular_cone inst);

        bool is_eccentric_cone() { return IsADBEntity("eccentric_cone"); }
        eccentric_cone get_eccentric_cone();
        void put_eccentric_cone(eccentric_cone inst);

        bool is_right_circular_cylinder() { return IsADBEntity("right_circular_cylinder"); }
        right_circular_cylinder get_right_circular_cylinder();
        void put_right_circular_cylinder(right_circular_cylinder inst);

        bool is_cyclide_segment_solid() { return IsADBEntity("cyclide_segment_solid"); }
        cyclide_segment_solid get_cyclide_segment_solid();
        void put_cyclide_segment_solid(cyclide_segment_solid inst);

        bool is_primitive_2d() { return IsADBEntity("primitive_2d"); }
        primitive_2d get_primitive_2d();
        void put_primitive_2d(primitive_2d inst);
    };


    class csg_primitive_get : public Select
    {
    public:
        csg_primitive_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        csg_primitive_get(Select* outer) : Select(outer) {}
        bool is_sphere() { return IsADBEntity("sphere"); }
        sphere get_sphere();
        bool is_ellipsoid() { return IsADBEntity("ellipsoid"); }
        ellipsoid get_ellipsoid();
        bool is_block() { return IsADBEntity("block"); }
        block get_block();
        bool is_right_angular_wedge() { return IsADBEntity("right_angular_wedge"); }
        right_angular_wedge get_right_angular_wedge();
        bool is_faceted_primitive() { return IsADBEntity("faceted_primitive"); }
        faceted_primitive get_faceted_primitive();
        bool is_rectangular_pyramid() { return IsADBEntity("rectangular_pyramid"); }
        rectangular_pyramid get_rectangular_pyramid();
        bool is_torus() { return IsADBEntity("torus"); }
        torus get_torus();
        bool is_right_circular_cone() { return IsADBEntity("right_circular_cone"); }
        right_circular_cone get_right_circular_cone();
        bool is_eccentric_cone() { return IsADBEntity("eccentric_cone"); }
        eccentric_cone get_eccentric_cone();
        bool is_right_circular_cylinder() { return IsADBEntity("right_circular_cylinder"); }
        right_circular_cylinder get_right_circular_cylinder();
        bool is_cyclide_segment_solid() { return IsADBEntity("cyclide_segment_solid"); }
        cyclide_segment_solid get_cyclide_segment_solid();
        bool is_primitive_2d() { return IsADBEntity("primitive_2d"); }
        primitive_2d get_primitive_2d();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class csg_primitive_put : public Select
    {
    public:
        csg_primitive_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        csg_primitive_put(Select* outer) : Select(outer) {}
        void put_sphere(sphere inst);
        void put_ellipsoid(ellipsoid inst);
        void put_block(block inst);
        void put_right_angular_wedge(right_angular_wedge inst);
        void put_faceted_primitive(faceted_primitive inst);
        void put_rectangular_pyramid(rectangular_pyramid inst);
        void put_torus(torus inst);
        void put_right_circular_cone(right_circular_cone inst);
        void put_eccentric_cone(eccentric_cone inst);
        void put_right_circular_cylinder(right_circular_cylinder inst);
        void put_cyclide_segment_solid(cyclide_segment_solid inst);
        void put_primitive_2d(primitive_2d inst);
    };


    class boolean_operand : public Select
    {
    public:
        boolean_operand(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        boolean_operand(Select* outer) : Select(outer) {}

        bool is_solid_model() { return IsADBEntity("solid_model"); }
        solid_model get_solid_model();
        void put_solid_model(solid_model inst);

        bool is_half_space_solid() { return IsADBEntity("half_space_solid"); }
        half_space_solid get_half_space_solid();
        void put_half_space_solid(half_space_solid inst);

        csg_primitive _csg_primitive() { return csg_primitive(this); }

        bool is_boolean_result() { return IsADBEntity("boolean_result"); }
        boolean_result get_boolean_result();
        void put_boolean_result(boolean_result inst);

        bool is_half_space_2d() { return IsADBEntity("half_space_2d"); }
        half_space_2d get_half_space_2d();
        void put_half_space_2d(half_space_2d inst);
    };


    class boolean_operand_get : public Select
    {
    public:
        boolean_operand_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        boolean_operand_get(Select* outer) : Select(outer) {}
        bool is_solid_model() { return IsADBEntity("solid_model"); }
        solid_model get_solid_model();
        bool is_half_space_solid() { return IsADBEntity("half_space_solid"); }
        half_space_solid get_half_space_solid();
        csg_primitive_get get_csg_primitive() { return csg_primitive_get(this); }
        bool is_boolean_result() { return IsADBEntity("boolean_result"); }
        boolean_result get_boolean_result();
        bool is_half_space_2d() { return IsADBEntity("half_space_2d"); }
        half_space_2d get_half_space_2d();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class boolean_operand_put : public Select
    {
    public:
        boolean_operand_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        boolean_operand_put(Select* outer) : Select(outer) {}
        void put_solid_model(solid_model inst);
        void put_half_space_solid(half_space_solid inst);
        csg_primitive_put put_csg_primitive() { return csg_primitive_put(this); }
        void put_boolean_result(boolean_result inst);
        void put_half_space_2d(half_space_2d inst);
    };


    class csg_select : public Select
    {
    public:
        csg_select(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        csg_select(Select* outer) : Select(outer) {}

        bool is_boolean_result() { return IsADBEntity("boolean_result"); }
        boolean_result get_boolean_result();
        void put_boolean_result(boolean_result inst);

        csg_primitive _csg_primitive() { return csg_primitive(this); }
    };


    class csg_select_get : public Select
    {
    public:
        csg_select_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        csg_select_get(Select* outer) : Select(outer) {}
        bool is_boolean_result() { return IsADBEntity("boolean_result"); }
        boolean_result get_boolean_result();
        csg_primitive_get get_csg_primitive() { return csg_primitive_get(this); }

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class csg_select_put : public Select
    {
    public:
        csg_select_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        csg_select_put(Select* outer) : Select(outer) {}
        void put_boolean_result(boolean_result inst);
        csg_primitive_put put_csg_primitive() { return csg_primitive_put(this); }
    };


    class curve_on_surface : public Select
    {
    public:
        curve_on_surface(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        curve_on_surface(Select* outer) : Select(outer) {}

        bool is_pcurve() { return IsADBEntity("pcurve"); }
        pcurve get_pcurve();
        void put_pcurve(pcurve inst);

        bool is_surface_curve() { return IsADBEntity("surface_curve"); }
        surface_curve get_surface_curve();
        void put_surface_curve(surface_curve inst);

        bool is_composite_curve_on_surface() { return IsADBEntity("composite_curve_on_surface"); }
        composite_curve_on_surface get_composite_curve_on_surface();
        void put_composite_curve_on_surface(composite_curve_on_surface inst);
    };


    class curve_on_surface_get : public Select
    {
    public:
        curve_on_surface_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        curve_on_surface_get(Select* outer) : Select(outer) {}
        bool is_pcurve() { return IsADBEntity("pcurve"); }
        pcurve get_pcurve();
        bool is_surface_curve() { return IsADBEntity("surface_curve"); }
        surface_curve get_surface_curve();
        bool is_composite_curve_on_surface() { return IsADBEntity("composite_curve_on_surface"); }
        composite_curve_on_surface get_composite_curve_on_surface();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class curve_on_surface_put : public Select
    {
    public:
        curve_on_surface_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        curve_on_surface_put(Select* outer) : Select(outer) {}
        void put_pcurve(pcurve inst);
        void put_surface_curve(surface_curve inst);
        void put_composite_curve_on_surface(composite_curve_on_surface inst);
    };


    class derived_measure : public Select
    {
    public:
        derived_measure(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        derived_measure(Select* outer) : Select(outer) {}

        bool is_force_per_length_measure() { return IsADBType("FORCE_PER_LENGTH_MEASURE"); }
        Nullable<force_per_length_measure> get_force_per_length_measure() { return getSimpleValue<force_per_length_measure>("FORCE_PER_LENGTH_MEASURE", sdaiREAL); }
        void put_force_per_length_measure(force_per_length_measure value) { putSimpleValue("FORCE_PER_LENGTH_MEASURE", sdaiREAL, value); }

        bool is_inertia_measure() { return IsADBType("INERTIA_MEASURE"); }
        Nullable<inertia_measure> get_inertia_measure() { return getSimpleValue<inertia_measure>("INERTIA_MEASURE", sdaiREAL); }
        void put_inertia_measure(inertia_measure value) { putSimpleValue("INERTIA_MEASURE", sdaiREAL, value); }

        bool is_linear_acceleration_measure() { return IsADBType("LINEAR_ACCELERATION_MEASURE"); }
        Nullable<linear_acceleration_measure> get_linear_acceleration_measure() { return getSimpleValue<linear_acceleration_measure>("LINEAR_ACCELERATION_MEASURE", sdaiREAL); }
        void put_linear_acceleration_measure(linear_acceleration_measure value) { putSimpleValue("LINEAR_ACCELERATION_MEASURE", sdaiREAL, value); }

        bool is_linear_stiffness_measure() { return IsADBType("LINEAR_STIFFNESS_MEASURE"); }
        Nullable<linear_stiffness_measure> get_linear_stiffness_measure() { return getSimpleValue<linear_stiffness_measure>("LINEAR_STIFFNESS_MEASURE", sdaiREAL); }
        void put_linear_stiffness_measure(linear_stiffness_measure value) { putSimpleValue("LINEAR_STIFFNESS_MEASURE", sdaiREAL, value); }

        bool is_linear_velocity_measure() { return IsADBType("LINEAR_VELOCITY_MEASURE"); }
        Nullable<linear_velocity_measure> get_linear_velocity_measure() { return getSimpleValue<linear_velocity_measure>("LINEAR_VELOCITY_MEASURE", sdaiREAL); }
        void put_linear_velocity_measure(linear_velocity_measure value) { putSimpleValue("LINEAR_VELOCITY_MEASURE", sdaiREAL, value); }

        bool is_mass_per_length_measure() { return IsADBType("MASS_PER_LENGTH_MEASURE"); }
        Nullable<mass_per_length_measure> get_mass_per_length_measure() { return getSimpleValue<mass_per_length_measure>("MASS_PER_LENGTH_MEASURE", sdaiREAL); }
        void put_mass_per_length_measure(mass_per_length_measure value) { putSimpleValue("MASS_PER_LENGTH_MEASURE", sdaiREAL, value); }

        bool is_modulus_measure() { return IsADBType("MODULUS_MEASURE"); }
        Nullable<modulus_measure> get_modulus_measure() { return getSimpleValue<modulus_measure>("MODULUS_MEASURE", sdaiREAL); }
        void put_modulus_measure(modulus_measure value) { putSimpleValue("MODULUS_MEASURE", sdaiREAL, value); }

        bool is_moment_measure() { return IsADBType("MOMENT_MEASURE"); }
        Nullable<moment_measure> get_moment_measure() { return getSimpleValue<moment_measure>("MOMENT_MEASURE", sdaiREAL); }
        void put_moment_measure(moment_measure value) { putSimpleValue("MOMENT_MEASURE", sdaiREAL, value); }

        bool is_rotational_acceleration_measure() { return IsADBType("ROTATIONAL_ACCELERATION_MEASURE"); }
        Nullable<rotational_acceleration_measure> get_rotational_acceleration_measure() { return getSimpleValue<rotational_acceleration_measure>("ROTATIONAL_ACCELERATION_MEASURE", sdaiREAL); }
        void put_rotational_acceleration_measure(rotational_acceleration_measure value) { putSimpleValue("ROTATIONAL_ACCELERATION_MEASURE", sdaiREAL, value); }

        bool is_rotational_stiffness_measure() { return IsADBType("ROTATIONAL_STIFFNESS_MEASURE"); }
        Nullable<rotational_stiffness_measure> get_rotational_stiffness_measure() { return getSimpleValue<rotational_stiffness_measure>("ROTATIONAL_STIFFNESS_MEASURE", sdaiREAL); }
        void put_rotational_stiffness_measure(rotational_stiffness_measure value) { putSimpleValue("ROTATIONAL_STIFFNESS_MEASURE", sdaiREAL, value); }

        bool is_rotational_velocity_measure() { return IsADBType("ROTATIONAL_VELOCITY_MEASURE"); }
        Nullable<rotational_velocity_measure> get_rotational_velocity_measure() { return getSimpleValue<rotational_velocity_measure>("ROTATIONAL_VELOCITY_MEASURE", sdaiREAL); }
        void put_rotational_velocity_measure(rotational_velocity_measure value) { putSimpleValue("ROTATIONAL_VELOCITY_MEASURE", sdaiREAL, value); }
    };


    class derived_measure_get : public Select
    {
    public:
        derived_measure_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        derived_measure_get(Select* outer) : Select(outer) {}
        bool is_force_per_length_measure() { return IsADBType("FORCE_PER_LENGTH_MEASURE"); }
        Nullable<force_per_length_measure> get_force_per_length_measure() { return getSimpleValue<force_per_length_measure>("FORCE_PER_LENGTH_MEASURE", sdaiREAL); }
        bool is_inertia_measure() { return IsADBType("INERTIA_MEASURE"); }
        Nullable<inertia_measure> get_inertia_measure() { return getSimpleValue<inertia_measure>("INERTIA_MEASURE", sdaiREAL); }
        bool is_linear_acceleration_measure() { return IsADBType("LINEAR_ACCELERATION_MEASURE"); }
        Nullable<linear_acceleration_measure> get_linear_acceleration_measure() { return getSimpleValue<linear_acceleration_measure>("LINEAR_ACCELERATION_MEASURE", sdaiREAL); }
        bool is_linear_stiffness_measure() { return IsADBType("LINEAR_STIFFNESS_MEASURE"); }
        Nullable<linear_stiffness_measure> get_linear_stiffness_measure() { return getSimpleValue<linear_stiffness_measure>("LINEAR_STIFFNESS_MEASURE", sdaiREAL); }
        bool is_linear_velocity_measure() { return IsADBType("LINEAR_VELOCITY_MEASURE"); }
        Nullable<linear_velocity_measure> get_linear_velocity_measure() { return getSimpleValue<linear_velocity_measure>("LINEAR_VELOCITY_MEASURE", sdaiREAL); }
        bool is_mass_per_length_measure() { return IsADBType("MASS_PER_LENGTH_MEASURE"); }
        Nullable<mass_per_length_measure> get_mass_per_length_measure() { return getSimpleValue<mass_per_length_measure>("MASS_PER_LENGTH_MEASURE", sdaiREAL); }
        bool is_modulus_measure() { return IsADBType("MODULUS_MEASURE"); }
        Nullable<modulus_measure> get_modulus_measure() { return getSimpleValue<modulus_measure>("MODULUS_MEASURE", sdaiREAL); }
        bool is_moment_measure() { return IsADBType("MOMENT_MEASURE"); }
        Nullable<moment_measure> get_moment_measure() { return getSimpleValue<moment_measure>("MOMENT_MEASURE", sdaiREAL); }
        bool is_rotational_acceleration_measure() { return IsADBType("ROTATIONAL_ACCELERATION_MEASURE"); }
        Nullable<rotational_acceleration_measure> get_rotational_acceleration_measure() { return getSimpleValue<rotational_acceleration_measure>("ROTATIONAL_ACCELERATION_MEASURE", sdaiREAL); }
        bool is_rotational_stiffness_measure() { return IsADBType("ROTATIONAL_STIFFNESS_MEASURE"); }
        Nullable<rotational_stiffness_measure> get_rotational_stiffness_measure() { return getSimpleValue<rotational_stiffness_measure>("ROTATIONAL_STIFFNESS_MEASURE", sdaiREAL); }
        bool is_rotational_velocity_measure() { return IsADBType("ROTATIONAL_VELOCITY_MEASURE"); }
        Nullable<rotational_velocity_measure> get_rotational_velocity_measure() { return getSimpleValue<rotational_velocity_measure>("ROTATIONAL_VELOCITY_MEASURE", sdaiREAL); }

        Nullable<double> as_double() { double val = 0; if (sdaiGetAttrBN(m_instance, m_attrName, sdaiREAL, &val)) return val; else return Nullable<double>(); }
    };


    class derived_measure_put : public Select
    {
    public:
        derived_measure_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        derived_measure_put(Select* outer) : Select(outer) {}
        void put_force_per_length_measure(force_per_length_measure value) { putSimpleValue("FORCE_PER_LENGTH_MEASURE", sdaiREAL, value); }
        void put_inertia_measure(inertia_measure value) { putSimpleValue("INERTIA_MEASURE", sdaiREAL, value); }
        void put_linear_acceleration_measure(linear_acceleration_measure value) { putSimpleValue("LINEAR_ACCELERATION_MEASURE", sdaiREAL, value); }
        void put_linear_stiffness_measure(linear_stiffness_measure value) { putSimpleValue("LINEAR_STIFFNESS_MEASURE", sdaiREAL, value); }
        void put_linear_velocity_measure(linear_velocity_measure value) { putSimpleValue("LINEAR_VELOCITY_MEASURE", sdaiREAL, value); }
        void put_mass_per_length_measure(mass_per_length_measure value) { putSimpleValue("MASS_PER_LENGTH_MEASURE", sdaiREAL, value); }
        void put_modulus_measure(modulus_measure value) { putSimpleValue("MODULUS_MEASURE", sdaiREAL, value); }
        void put_moment_measure(moment_measure value) { putSimpleValue("MOMENT_MEASURE", sdaiREAL, value); }
        void put_rotational_acceleration_measure(rotational_acceleration_measure value) { putSimpleValue("ROTATIONAL_ACCELERATION_MEASURE", sdaiREAL, value); }
        void put_rotational_stiffness_measure(rotational_stiffness_measure value) { putSimpleValue("ROTATIONAL_STIFFNESS_MEASURE", sdaiREAL, value); }
        void put_rotational_velocity_measure(rotational_velocity_measure value) { putSimpleValue("ROTATIONAL_VELOCITY_MEASURE", sdaiREAL, value); }
    };


    class description_attribute_select : public Select
    {
    public:
        description_attribute_select(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        description_attribute_select(Select* outer) : Select(outer) {}

        bool is_person_and_organization_role() { return IsADBEntity("person_and_organization_role"); }
        person_and_organization_role get_person_and_organization_role();
        void put_person_and_organization_role(person_and_organization_role inst);

        bool is_person_and_organization() { return IsADBEntity("person_and_organization"); }
        person_and_organization get_person_and_organization();
        void put_person_and_organization(person_and_organization inst);

        bool is_representation() { return IsADBEntity("representation"); }
        representation get_representation();
        void put_representation(representation inst);
    };


    class description_attribute_select_get : public Select
    {
    public:
        description_attribute_select_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        description_attribute_select_get(Select* outer) : Select(outer) {}
        bool is_person_and_organization_role() { return IsADBEntity("person_and_organization_role"); }
        person_and_organization_role get_person_and_organization_role();
        bool is_person_and_organization() { return IsADBEntity("person_and_organization"); }
        person_and_organization get_person_and_organization();
        bool is_representation() { return IsADBEntity("representation"); }
        representation get_representation();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class description_attribute_select_put : public Select
    {
    public:
        description_attribute_select_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        description_attribute_select_put(Select* outer) : Select(outer) {}
        void put_person_and_organization_role(person_and_organization_role inst);
        void put_person_and_organization(person_and_organization inst);
        void put_representation(representation inst);
    };


    class founded_item_select : public Select
    {
    public:
        founded_item_select(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        founded_item_select(Select* outer) : Select(outer) {}

        bool is_founded_item() { return IsADBEntity("founded_item"); }
        founded_item get_founded_item();
        void put_founded_item(founded_item inst);

        bool is_representation_item() { return IsADBEntity("representation_item"); }
        representation_item get_representation_item();
        void put_representation_item(representation_item inst);
    };


    class founded_item_select_get : public Select
    {
    public:
        founded_item_select_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        founded_item_select_get(Select* outer) : Select(outer) {}
        bool is_founded_item() { return IsADBEntity("founded_item"); }
        founded_item get_founded_item();
        bool is_representation_item() { return IsADBEntity("representation_item"); }
        representation_item get_representation_item();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class founded_item_select_put : public Select
    {
    public:
        founded_item_select_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        founded_item_select_put(Select* outer) : Select(outer) {}
        void put_founded_item(founded_item inst);
        void put_representation_item(representation_item inst);
    };


    class geometric_set_select : public Select
    {
    public:
        geometric_set_select(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        geometric_set_select(Select* outer) : Select(outer) {}

        bool is_point() { return IsADBEntity("point"); }
        point get_point();
        void put_point(point inst);

        bool is_curve() { return IsADBEntity("curve"); }
        curve get_curve();
        void put_curve(curve inst);

        bool is_surface() { return IsADBEntity("surface"); }
        surface get_surface();
        void put_surface(surface inst);
    };


    class geometric_set_select_get : public Select
    {
    public:
        geometric_set_select_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        geometric_set_select_get(Select* outer) : Select(outer) {}
        bool is_point() { return IsADBEntity("point"); }
        point get_point();
        bool is_curve() { return IsADBEntity("curve"); }
        curve get_curve();
        bool is_surface() { return IsADBEntity("surface"); }
        surface get_surface();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class geometric_set_select_put : public Select
    {
    public:
        geometric_set_select_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        geometric_set_select_put(Select* outer) : Select(outer) {}
        void put_point(point inst);
        void put_curve(curve inst);
        void put_surface(surface inst);
    };


    class id_attribute_select : public Select
    {
    public:
        id_attribute_select(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        id_attribute_select(Select* outer) : Select(outer) {}

        bool is_action() { return IsADBEntity("action"); }
        action get_action();
        void put_action(action inst);

        bool is_address() { return IsADBEntity("address"); }
        address get_address();
        void put_address(address inst);

        bool is_group() { return IsADBEntity("group"); }
        group get_group();
        void put_group(group inst);

        bool is_representation() { return IsADBEntity("representation"); }
        representation get_representation();
        void put_representation(representation inst);
    };


    class id_attribute_select_get : public Select
    {
    public:
        id_attribute_select_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        id_attribute_select_get(Select* outer) : Select(outer) {}
        bool is_action() { return IsADBEntity("action"); }
        action get_action();
        bool is_address() { return IsADBEntity("address"); }
        address get_address();
        bool is_group() { return IsADBEntity("group"); }
        group get_group();
        bool is_representation() { return IsADBEntity("representation"); }
        representation get_representation();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class id_attribute_select_put : public Select
    {
    public:
        id_attribute_select_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        id_attribute_select_put(Select* outer) : Select(outer) {}
        void put_action(action inst);
        void put_address(address inst);
        void put_group(group inst);
        void put_representation(representation inst);
    };


    class measure_value : public Select
    {
    public:
        measure_value(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        measure_value(Select* outer) : Select(outer) {}

        bool is_length_measure() { return IsADBType("LENGTH_MEASURE"); }
        Nullable<length_measure> get_length_measure() { return getSimpleValue<length_measure>("LENGTH_MEASURE", sdaiREAL); }
        void put_length_measure(length_measure value) { putSimpleValue("LENGTH_MEASURE", sdaiREAL, value); }

        bool is_mass_measure() { return IsADBType("MASS_MEASURE"); }
        Nullable<mass_measure> get_mass_measure() { return getSimpleValue<mass_measure>("MASS_MEASURE", sdaiREAL); }
        void put_mass_measure(mass_measure value) { putSimpleValue("MASS_MEASURE", sdaiREAL, value); }

        bool is_time_measure() { return IsADBType("TIME_MEASURE"); }
        Nullable<time_measure> get_time_measure() { return getSimpleValue<time_measure>("TIME_MEASURE", sdaiREAL); }
        void put_time_measure(time_measure value) { putSimpleValue("TIME_MEASURE", sdaiREAL, value); }

        bool is_thermodynamic_temperature_measure() { return IsADBType("THERMODYNAMIC_TEMPERATURE_MEASURE"); }
        Nullable<thermodynamic_temperature_measure> get_thermodynamic_temperature_measure() { return getSimpleValue<thermodynamic_temperature_measure>("THERMODYNAMIC_TEMPERATURE_MEASURE", sdaiREAL); }
        void put_thermodynamic_temperature_measure(thermodynamic_temperature_measure value) { putSimpleValue("THERMODYNAMIC_TEMPERATURE_MEASURE", sdaiREAL, value); }

        bool is_plane_angle_measure() { return IsADBType("PLANE_ANGLE_MEASURE"); }
        Nullable<plane_angle_measure> get_plane_angle_measure() { return getSimpleValue<plane_angle_measure>("PLANE_ANGLE_MEASURE", sdaiREAL); }
        void put_plane_angle_measure(plane_angle_measure value) { putSimpleValue("PLANE_ANGLE_MEASURE", sdaiREAL, value); }

        bool is_solid_angle_measure() { return IsADBType("SOLID_ANGLE_MEASURE"); }
        Nullable<solid_angle_measure> get_solid_angle_measure() { return getSimpleValue<solid_angle_measure>("SOLID_ANGLE_MEASURE", sdaiREAL); }
        void put_solid_angle_measure(solid_angle_measure value) { putSimpleValue("SOLID_ANGLE_MEASURE", sdaiREAL, value); }

        bool is_area_measure() { return IsADBType("AREA_MEASURE"); }
        Nullable<area_measure> get_area_measure() { return getSimpleValue<area_measure>("AREA_MEASURE", sdaiREAL); }
        void put_area_measure(area_measure value) { putSimpleValue("AREA_MEASURE", sdaiREAL, value); }

        bool is_volume_measure() { return IsADBType("VOLUME_MEASURE"); }
        Nullable<volume_measure> get_volume_measure() { return getSimpleValue<volume_measure>("VOLUME_MEASURE", sdaiREAL); }
        void put_volume_measure(volume_measure value) { putSimpleValue("VOLUME_MEASURE", sdaiREAL, value); }

        bool is_ratio_measure() { return IsADBType("RATIO_MEASURE"); }
        Nullable<ratio_measure> get_ratio_measure() { return getSimpleValue<ratio_measure>("RATIO_MEASURE", sdaiREAL); }
        void put_ratio_measure(ratio_measure value) { putSimpleValue("RATIO_MEASURE", sdaiREAL, value); }

        bool is_parameter_value() { return IsADBType("PARAMETER_VALUE"); }
        Nullable<parameter_value> get_parameter_value() { return getSimpleValue<parameter_value>("PARAMETER_VALUE", sdaiREAL); }
        void put_parameter_value(parameter_value value) { putSimpleValue("PARAMETER_VALUE", sdaiREAL, value); }

        bool is_numeric_measure() { return IsADBType("NUMERIC_MEASURE"); }
        Nullable<numeric_measure> get_numeric_measure() { return getSimpleValue<numeric_measure>("NUMERIC_MEASURE", sdaiREAL); }
        void put_numeric_measure(numeric_measure value) { putSimpleValue("NUMERIC_MEASURE", sdaiREAL, value); }

        bool is_force_measure() { return IsADBType("FORCE_MEASURE"); }
        Nullable<force_measure> get_force_measure() { return getSimpleValue<force_measure>("FORCE_MEASURE", sdaiREAL); }
        void put_force_measure(force_measure value) { putSimpleValue("FORCE_MEASURE", sdaiREAL, value); }

        bool is_frequency_measure() { return IsADBType("FREQUENCY_MEASURE"); }
        Nullable<frequency_measure> get_frequency_measure() { return getSimpleValue<frequency_measure>("FREQUENCY_MEASURE", sdaiREAL); }
        void put_frequency_measure(frequency_measure value) { putSimpleValue("FREQUENCY_MEASURE", sdaiREAL, value); }

        bool is_pressure_measure() { return IsADBType("PRESSURE_MEASURE"); }
        Nullable<pressure_measure> get_pressure_measure() { return getSimpleValue<pressure_measure>("PRESSURE_MEASURE", sdaiREAL); }
        void put_pressure_measure(pressure_measure value) { putSimpleValue("PRESSURE_MEASURE", sdaiREAL, value); }

        bool is_context_dependent_measure() { return IsADBType("CONTEXT_DEPENDENT_MEASURE"); }
        Nullable<context_dependent_measure> get_context_dependent_measure() { return getSimpleValue<context_dependent_measure>("CONTEXT_DEPENDENT_MEASURE", sdaiREAL); }
        void put_context_dependent_measure(context_dependent_measure value) { putSimpleValue("CONTEXT_DEPENDENT_MEASURE", sdaiREAL, value); }

        bool is_descriptive_measure() { return IsADBType("DESCRIPTIVE_MEASURE"); }
        descriptive_measure get_descriptive_measure() { return getTextValue("DESCRIPTIVE_MEASURE", sdaiSTRING); }
        void put_descriptive_measure(descriptive_measure value) { putTextValue("DESCRIPTIVE_MEASURE", sdaiSTRING, value); }

        bool is_positive_length_measure() { return IsADBType("POSITIVE_LENGTH_MEASURE"); }
        Nullable<positive_length_measure> get_positive_length_measure() { return getSimpleValue<positive_length_measure>("POSITIVE_LENGTH_MEASURE", sdaiREAL); }
        void put_positive_length_measure(positive_length_measure value) { putSimpleValue("POSITIVE_LENGTH_MEASURE", sdaiREAL, value); }

        bool is_positive_plane_angle_measure() { return IsADBType("POSITIVE_PLANE_ANGLE_MEASURE"); }
        Nullable<positive_plane_angle_measure> get_positive_plane_angle_measure() { return getSimpleValue<positive_plane_angle_measure>("POSITIVE_PLANE_ANGLE_MEASURE", sdaiREAL); }
        void put_positive_plane_angle_measure(positive_plane_angle_measure value) { putSimpleValue("POSITIVE_PLANE_ANGLE_MEASURE", sdaiREAL, value); }

        bool is_positive_ratio_measure() { return IsADBType("POSITIVE_RATIO_MEASURE"); }
        Nullable<positive_ratio_measure> get_positive_ratio_measure() { return getSimpleValue<positive_ratio_measure>("POSITIVE_RATIO_MEASURE", sdaiREAL); }
        void put_positive_ratio_measure(positive_ratio_measure value) { putSimpleValue("POSITIVE_RATIO_MEASURE", sdaiREAL, value); }

        bool is_count_measure() { return IsADBType("COUNT_MEASURE"); }
        Nullable<count_measure> get_count_measure() { return getSimpleValue<count_measure>("COUNT_MEASURE", sdaiREAL); }
        void put_count_measure(count_measure value) { putSimpleValue("COUNT_MEASURE", sdaiREAL, value); }

        derived_measure _derived_measure() { return derived_measure(this); }
    };


    class measure_value_get : public Select
    {
    public:
        measure_value_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        measure_value_get(Select* outer) : Select(outer) {}
        bool is_length_measure() { return IsADBType("LENGTH_MEASURE"); }
        Nullable<length_measure> get_length_measure() { return getSimpleValue<length_measure>("LENGTH_MEASURE", sdaiREAL); }
        bool is_mass_measure() { return IsADBType("MASS_MEASURE"); }
        Nullable<mass_measure> get_mass_measure() { return getSimpleValue<mass_measure>("MASS_MEASURE", sdaiREAL); }
        bool is_time_measure() { return IsADBType("TIME_MEASURE"); }
        Nullable<time_measure> get_time_measure() { return getSimpleValue<time_measure>("TIME_MEASURE", sdaiREAL); }
        bool is_thermodynamic_temperature_measure() { return IsADBType("THERMODYNAMIC_TEMPERATURE_MEASURE"); }
        Nullable<thermodynamic_temperature_measure> get_thermodynamic_temperature_measure() { return getSimpleValue<thermodynamic_temperature_measure>("THERMODYNAMIC_TEMPERATURE_MEASURE", sdaiREAL); }
        bool is_plane_angle_measure() { return IsADBType("PLANE_ANGLE_MEASURE"); }
        Nullable<plane_angle_measure> get_plane_angle_measure() { return getSimpleValue<plane_angle_measure>("PLANE_ANGLE_MEASURE", sdaiREAL); }
        bool is_solid_angle_measure() { return IsADBType("SOLID_ANGLE_MEASURE"); }
        Nullable<solid_angle_measure> get_solid_angle_measure() { return getSimpleValue<solid_angle_measure>("SOLID_ANGLE_MEASURE", sdaiREAL); }
        bool is_area_measure() { return IsADBType("AREA_MEASURE"); }
        Nullable<area_measure> get_area_measure() { return getSimpleValue<area_measure>("AREA_MEASURE", sdaiREAL); }
        bool is_volume_measure() { return IsADBType("VOLUME_MEASURE"); }
        Nullable<volume_measure> get_volume_measure() { return getSimpleValue<volume_measure>("VOLUME_MEASURE", sdaiREAL); }
        bool is_ratio_measure() { return IsADBType("RATIO_MEASURE"); }
        Nullable<ratio_measure> get_ratio_measure() { return getSimpleValue<ratio_measure>("RATIO_MEASURE", sdaiREAL); }
        bool is_parameter_value() { return IsADBType("PARAMETER_VALUE"); }
        Nullable<parameter_value> get_parameter_value() { return getSimpleValue<parameter_value>("PARAMETER_VALUE", sdaiREAL); }
        bool is_numeric_measure() { return IsADBType("NUMERIC_MEASURE"); }
        Nullable<numeric_measure> get_numeric_measure() { return getSimpleValue<numeric_measure>("NUMERIC_MEASURE", sdaiREAL); }
        bool is_force_measure() { return IsADBType("FORCE_MEASURE"); }
        Nullable<force_measure> get_force_measure() { return getSimpleValue<force_measure>("FORCE_MEASURE", sdaiREAL); }
        bool is_frequency_measure() { return IsADBType("FREQUENCY_MEASURE"); }
        Nullable<frequency_measure> get_frequency_measure() { return getSimpleValue<frequency_measure>("FREQUENCY_MEASURE", sdaiREAL); }
        bool is_pressure_measure() { return IsADBType("PRESSURE_MEASURE"); }
        Nullable<pressure_measure> get_pressure_measure() { return getSimpleValue<pressure_measure>("PRESSURE_MEASURE", sdaiREAL); }
        bool is_context_dependent_measure() { return IsADBType("CONTEXT_DEPENDENT_MEASURE"); }
        Nullable<context_dependent_measure> get_context_dependent_measure() { return getSimpleValue<context_dependent_measure>("CONTEXT_DEPENDENT_MEASURE", sdaiREAL); }
        bool is_descriptive_measure() { return IsADBType("DESCRIPTIVE_MEASURE"); }
        descriptive_measure get_descriptive_measure() { return getTextValue("DESCRIPTIVE_MEASURE", sdaiSTRING); }
        bool is_positive_length_measure() { return IsADBType("POSITIVE_LENGTH_MEASURE"); }
        Nullable<positive_length_measure> get_positive_length_measure() { return getSimpleValue<positive_length_measure>("POSITIVE_LENGTH_MEASURE", sdaiREAL); }
        bool is_positive_plane_angle_measure() { return IsADBType("POSITIVE_PLANE_ANGLE_MEASURE"); }
        Nullable<positive_plane_angle_measure> get_positive_plane_angle_measure() { return getSimpleValue<positive_plane_angle_measure>("POSITIVE_PLANE_ANGLE_MEASURE", sdaiREAL); }
        bool is_positive_ratio_measure() { return IsADBType("POSITIVE_RATIO_MEASURE"); }
        Nullable<positive_ratio_measure> get_positive_ratio_measure() { return getSimpleValue<positive_ratio_measure>("POSITIVE_RATIO_MEASURE", sdaiREAL); }
        bool is_count_measure() { return IsADBType("COUNT_MEASURE"); }
        Nullable<count_measure> get_count_measure() { return getSimpleValue<count_measure>("COUNT_MEASURE", sdaiREAL); }
        derived_measure_get get_derived_measure() { return derived_measure_get(this); }

        Nullable<double> as_double() { double val = 0; if (sdaiGetAttrBN(m_instance, m_attrName, sdaiREAL, &val)) return val; else return Nullable<double>(); }
        TextValue as_text() { TextValue val = NULL; sdaiGetAttrBN(m_instance, m_attrName, sdaiSTRING, &val); return val; }
    };


    class measure_value_put : public Select
    {
    public:
        measure_value_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        measure_value_put(Select* outer) : Select(outer) {}
        void put_length_measure(length_measure value) { putSimpleValue("LENGTH_MEASURE", sdaiREAL, value); }
        void put_mass_measure(mass_measure value) { putSimpleValue("MASS_MEASURE", sdaiREAL, value); }
        void put_time_measure(time_measure value) { putSimpleValue("TIME_MEASURE", sdaiREAL, value); }
        void put_thermodynamic_temperature_measure(thermodynamic_temperature_measure value) { putSimpleValue("THERMODYNAMIC_TEMPERATURE_MEASURE", sdaiREAL, value); }
        void put_plane_angle_measure(plane_angle_measure value) { putSimpleValue("PLANE_ANGLE_MEASURE", sdaiREAL, value); }
        void put_solid_angle_measure(solid_angle_measure value) { putSimpleValue("SOLID_ANGLE_MEASURE", sdaiREAL, value); }
        void put_area_measure(area_measure value) { putSimpleValue("AREA_MEASURE", sdaiREAL, value); }
        void put_volume_measure(volume_measure value) { putSimpleValue("VOLUME_MEASURE", sdaiREAL, value); }
        void put_ratio_measure(ratio_measure value) { putSimpleValue("RATIO_MEASURE", sdaiREAL, value); }
        void put_parameter_value(parameter_value value) { putSimpleValue("PARAMETER_VALUE", sdaiREAL, value); }
        void put_numeric_measure(numeric_measure value) { putSimpleValue("NUMERIC_MEASURE", sdaiREAL, value); }
        void put_force_measure(force_measure value) { putSimpleValue("FORCE_MEASURE", sdaiREAL, value); }
        void put_frequency_measure(frequency_measure value) { putSimpleValue("FREQUENCY_MEASURE", sdaiREAL, value); }
        void put_pressure_measure(pressure_measure value) { putSimpleValue("PRESSURE_MEASURE", sdaiREAL, value); }
        void put_context_dependent_measure(context_dependent_measure value) { putSimpleValue("CONTEXT_DEPENDENT_MEASURE", sdaiREAL, value); }
        void put_descriptive_measure(descriptive_measure value) { putTextValue("DESCRIPTIVE_MEASURE", sdaiSTRING, value); }
        void put_positive_length_measure(positive_length_measure value) { putSimpleValue("POSITIVE_LENGTH_MEASURE", sdaiREAL, value); }
        void put_positive_plane_angle_measure(positive_plane_angle_measure value) { putSimpleValue("POSITIVE_PLANE_ANGLE_MEASURE", sdaiREAL, value); }
        void put_positive_ratio_measure(positive_ratio_measure value) { putSimpleValue("POSITIVE_RATIO_MEASURE", sdaiREAL, value); }
        void put_count_measure(count_measure value) { putSimpleValue("COUNT_MEASURE", sdaiREAL, value); }
        derived_measure_put put_derived_measure() { return derived_measure_put(this); }
    };


    class measure_select : public Select
    {
    public:
        measure_select(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        measure_select(Select* outer) : Select(outer) {}

        bool is_measure_with_unit() { return IsADBEntity("measure_with_unit"); }
        measure_with_unit get_measure_with_unit();
        void put_measure_with_unit(measure_with_unit inst);

        measure_value _measure_value() { return measure_value(this); }

        bool is_boolean_value() { return IsADBType("BOOLEAN_VALUE"); }
        Nullable<boolean_value> get_boolean_value() { return getSimpleValue<boolean_value>("BOOLEAN_VALUE", sdaiBOOLEAN); }
        void put_boolean_value(boolean_value value) { putSimpleValue("BOOLEAN_VALUE", sdaiBOOLEAN, value); }
    };


    class measure_select_get : public Select
    {
    public:
        measure_select_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        measure_select_get(Select* outer) : Select(outer) {}
        bool is_measure_with_unit() { return IsADBEntity("measure_with_unit"); }
        measure_with_unit get_measure_with_unit();
        measure_value_get get_measure_value() { return measure_value_get(this); }
        bool is_boolean_value() { return IsADBType("BOOLEAN_VALUE"); }
        Nullable<boolean_value> get_boolean_value() { return getSimpleValue<boolean_value>("BOOLEAN_VALUE", sdaiBOOLEAN); }

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
        Nullable<double> as_double() { double val = 0; if (sdaiGetAttrBN(m_instance, m_attrName, sdaiREAL, &val)) return val; else return Nullable<double>(); }
        TextValue as_text() { TextValue val = NULL; sdaiGetAttrBN(m_instance, m_attrName, sdaiSTRING, &val); return val; }
        Nullable<bool> as_bool() { bool val = 0; if (sdaiGetAttrBN(m_instance, m_attrName, sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
    };


    class measure_select_put : public Select
    {
    public:
        measure_select_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        measure_select_put(Select* outer) : Select(outer) {}
        void put_measure_with_unit(measure_with_unit inst);
        measure_value_put put_measure_value() { return measure_value_put(this); }
        void put_boolean_value(boolean_value value) { putSimpleValue("BOOLEAN_VALUE", sdaiBOOLEAN, value); }
    };


    class name_attribute_select : public Select
    {
    public:
        name_attribute_select(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        name_attribute_select(Select* outer) : Select(outer) {}

        bool is_address() { return IsADBEntity("address"); }
        address get_address();
        void put_address(address inst);

        bool is_derived_unit() { return IsADBEntity("derived_unit"); }
        derived_unit get_derived_unit();
        void put_derived_unit(derived_unit inst);

        bool is_person_and_organization() { return IsADBEntity("person_and_organization"); }
        person_and_organization get_person_and_organization();
        void put_person_and_organization(person_and_organization inst);
    };


    class name_attribute_select_get : public Select
    {
    public:
        name_attribute_select_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        name_attribute_select_get(Select* outer) : Select(outer) {}
        bool is_address() { return IsADBEntity("address"); }
        address get_address();
        bool is_derived_unit() { return IsADBEntity("derived_unit"); }
        derived_unit get_derived_unit();
        bool is_person_and_organization() { return IsADBEntity("person_and_organization"); }
        person_and_organization get_person_and_organization();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class name_attribute_select_put : public Select
    {
    public:
        name_attribute_select_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        name_attribute_select_put(Select* outer) : Select(outer) {}
        void put_address(address inst);
        void put_derived_unit(derived_unit inst);
        void put_person_and_organization(person_and_organization inst);
    };


    class orientation_select : public Select
    {
    public:
        orientation_select(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        orientation_select(Select* outer) : Select(outer) {}

        bool is_plane_angle_measure_with_unit() { return IsADBEntity("plane_angle_measure_with_unit"); }
        plane_angle_measure_with_unit get_plane_angle_measure_with_unit();
        void put_plane_angle_measure_with_unit(plane_angle_measure_with_unit inst);

        bool is_direction() { return IsADBEntity("direction"); }
        direction get_direction();
        void put_direction(direction inst);
    };


    class orientation_select_get : public Select
    {
    public:
        orientation_select_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        orientation_select_get(Select* outer) : Select(outer) {}
        bool is_plane_angle_measure_with_unit() { return IsADBEntity("plane_angle_measure_with_unit"); }
        plane_angle_measure_with_unit get_plane_angle_measure_with_unit();
        bool is_direction() { return IsADBEntity("direction"); }
        direction get_direction();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class orientation_select_put : public Select
    {
    public:
        orientation_select_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        orientation_select_put(Select* outer) : Select(outer) {}
        void put_plane_angle_measure_with_unit(plane_angle_measure_with_unit inst);
        void put_direction(direction inst);
    };


    class part_select : public Select
    {
    public:
        part_select(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        part_select(Select* outer) : Select(outer) {}

        bool is_part() { return IsADBEntity("part"); }
        part get_part();
        void put_part(part inst);

        bool is_design_part() { return IsADBEntity("design_part"); }
        design_part get_design_part();
        void put_design_part(design_part inst);

        bool is_located_part() { return IsADBEntity("located_part"); }
        located_part get_located_part();
        void put_located_part(located_part inst);
    };


    class part_select_get : public Select
    {
    public:
        part_select_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        part_select_get(Select* outer) : Select(outer) {}
        bool is_part() { return IsADBEntity("part"); }
        part get_part();
        bool is_design_part() { return IsADBEntity("design_part"); }
        design_part get_design_part();
        bool is_located_part() { return IsADBEntity("located_part"); }
        located_part get_located_part();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class part_select_put : public Select
    {
    public:
        part_select_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        part_select_put(Select* outer) : Select(outer) {}
        void put_part(part inst);
        void put_design_part(design_part inst);
        void put_located_part(located_part inst);
    };


    class pcurve_or_surface : public Select
    {
    public:
        pcurve_or_surface(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        pcurve_or_surface(Select* outer) : Select(outer) {}

        bool is_pcurve() { return IsADBEntity("pcurve"); }
        pcurve get_pcurve();
        void put_pcurve(pcurve inst);

        bool is_surface() { return IsADBEntity("surface"); }
        surface get_surface();
        void put_surface(surface inst);
    };


    class pcurve_or_surface_get : public Select
    {
    public:
        pcurve_or_surface_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        pcurve_or_surface_get(Select* outer) : Select(outer) {}
        bool is_pcurve() { return IsADBEntity("pcurve"); }
        pcurve get_pcurve();
        bool is_surface() { return IsADBEntity("surface"); }
        surface get_surface();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class pcurve_or_surface_put : public Select
    {
    public:
        pcurve_or_surface_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        pcurve_or_surface_put(Select* outer) : Select(outer) {}
        void put_pcurve(pcurve inst);
        void put_surface(surface inst);
    };


    class product_item_select : public Select
    {
    public:
        product_item_select(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        product_item_select(Select* outer) : Select(outer) {}

        bool is_structural_frame_product() { return IsADBEntity("structural_frame_product"); }
        structural_frame_product get_structural_frame_product();
        void put_structural_frame_product(structural_frame_product inst);

        assembly_component_select _assembly_component_select() { return assembly_component_select(this); }
    };


    class product_item_select_get : public Select
    {
    public:
        product_item_select_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        product_item_select_get(Select* outer) : Select(outer) {}
        bool is_structural_frame_product() { return IsADBEntity("structural_frame_product"); }
        structural_frame_product get_structural_frame_product();
        assembly_component_select_get get_assembly_component_select() { return assembly_component_select_get(this); }

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class product_item_select_put : public Select
    {
    public:
        product_item_select_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        product_item_select_put(Select* outer) : Select(outer) {}
        void put_structural_frame_product(structural_frame_product inst);
        assembly_component_select_put put_assembly_component_select() { return assembly_component_select_put(this); }
    };


    class project_select : public Select
    {
    public:
        project_select(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        project_select(Select* outer) : Select(outer) {}

        bool is_project() { return IsADBEntity("project"); }
        project get_project();
        void put_project(project inst);

        bool is_zone_of_project() { return IsADBEntity("zone_of_project"); }
        zone_of_project get_zone_of_project();
        void put_zone_of_project(zone_of_project inst);
    };


    class project_select_get : public Select
    {
    public:
        project_select_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        project_select_get(Select* outer) : Select(outer) {}
        bool is_project() { return IsADBEntity("project"); }
        project get_project();
        bool is_zone_of_project() { return IsADBEntity("zone_of_project"); }
        zone_of_project get_zone_of_project();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class project_select_put : public Select
    {
    public:
        project_select_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        project_select_put(Select* outer) : Select(outer) {}
        void put_project(project inst);
        void put_zone_of_project(zone_of_project inst);
    };


    class reversible_topology_item : public Select
    {
    public:
        reversible_topology_item(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        reversible_topology_item(Select* outer) : Select(outer) {}

        bool is_edge() { return IsADBEntity("edge"); }
        edge get_edge();
        void put_edge(edge inst);

        bool is_path() { return IsADBEntity("path"); }
        path get_path();
        void put_path(path inst);

        bool is_face() { return IsADBEntity("face"); }
        face get_face();
        void put_face(face inst);

        bool is_face_bound() { return IsADBEntity("face_bound"); }
        face_bound get_face_bound();
        void put_face_bound(face_bound inst);

        bool is_closed_shell() { return IsADBEntity("closed_shell"); }
        closed_shell get_closed_shell();
        void put_closed_shell(closed_shell inst);

        bool is_open_shell() { return IsADBEntity("open_shell"); }
        open_shell get_open_shell();
        void put_open_shell(open_shell inst);
    };


    class reversible_topology_item_get : public Select
    {
    public:
        reversible_topology_item_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        reversible_topology_item_get(Select* outer) : Select(outer) {}
        bool is_edge() { return IsADBEntity("edge"); }
        edge get_edge();
        bool is_path() { return IsADBEntity("path"); }
        path get_path();
        bool is_face() { return IsADBEntity("face"); }
        face get_face();
        bool is_face_bound() { return IsADBEntity("face_bound"); }
        face_bound get_face_bound();
        bool is_closed_shell() { return IsADBEntity("closed_shell"); }
        closed_shell get_closed_shell();
        bool is_open_shell() { return IsADBEntity("open_shell"); }
        open_shell get_open_shell();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class reversible_topology_item_put : public Select
    {
    public:
        reversible_topology_item_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        reversible_topology_item_put(Select* outer) : Select(outer) {}
        void put_edge(edge inst);
        void put_path(path inst);
        void put_face(face inst);
        void put_face_bound(face_bound inst);
        void put_closed_shell(closed_shell inst);
        void put_open_shell(open_shell inst);
    };


    class reversible_topology : public Select
    {
    public:
        reversible_topology(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        reversible_topology(Select* outer) : Select(outer) {}

        reversible_topology_item _reversible_topology_item() { return reversible_topology_item(this); }

        bool is_list_of_reversible_topology_item() { return IsADBType("LIST_OF_REVERSIBLE_TOPOLOGY_ITEM"); }

        //TList may be list_of_reversible_topology_item or list of converible elements
        template <typename TList> void get_list_of_reversible_topology_item(TList& lst) { SdaiAggr aggr = getAggrValue("LIST_OF_REVERSIBLE_TOPOLOGY_ITEM"); list_of_reversible_topology_itemSerializer<TList> sr; sr.FromSdaiAggr(lst, m_instance, aggr); }

                //TList may be list_of_reversible_topology_item or list of converible elements
        template <typename TList> void put_list_of_reversible_topology_item(TList& lst) { list_of_reversible_topology_itemSerializer<TList> sr; SdaiAggr aggr = sr.ToSdaiAggr(lst, m_instance, NULL); putAggrValue("LIST_OF_REVERSIBLE_TOPOLOGY_ITEM", aggr); }

        bool is_set_of_reversible_topology_item() { return IsADBType("SET_OF_REVERSIBLE_TOPOLOGY_ITEM"); }

        //TList may be set_of_reversible_topology_item or list of converible elements
        template <typename TList> void get_set_of_reversible_topology_item(TList& lst) { SdaiAggr aggr = getAggrValue("SET_OF_REVERSIBLE_TOPOLOGY_ITEM"); set_of_reversible_topology_itemSerializer<TList> sr; sr.FromSdaiAggr(lst, m_instance, aggr); }

                //TList may be set_of_reversible_topology_item or list of converible elements
        template <typename TList> void put_set_of_reversible_topology_item(TList& lst) { set_of_reversible_topology_itemSerializer<TList> sr; SdaiAggr aggr = sr.ToSdaiAggr(lst, m_instance, NULL); putAggrValue("SET_OF_REVERSIBLE_TOPOLOGY_ITEM", aggr); }
    };


    class reversible_topology_get : public Select
    {
    public:
        reversible_topology_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        reversible_topology_get(Select* outer) : Select(outer) {}
        reversible_topology_item_get get_reversible_topology_item() { return reversible_topology_item_get(this); }
        bool is_list_of_reversible_topology_item() { return IsADBType("LIST_OF_REVERSIBLE_TOPOLOGY_ITEM"); }

        //TList may be list_of_reversible_topology_item or list of converible elements
        template <typename TList> void get_list_of_reversible_topology_item(TList& lst) { SdaiAggr aggr = getAggrValue("LIST_OF_REVERSIBLE_TOPOLOGY_ITEM"); list_of_reversible_topology_itemSerializer<TList> sr; sr.FromSdaiAggr(lst, m_instance, aggr); }
        bool is_set_of_reversible_topology_item() { return IsADBType("SET_OF_REVERSIBLE_TOPOLOGY_ITEM"); }

        //TList may be set_of_reversible_topology_item or list of converible elements
        template <typename TList> void get_set_of_reversible_topology_item(TList& lst) { SdaiAggr aggr = getAggrValue("SET_OF_REVERSIBLE_TOPOLOGY_ITEM"); set_of_reversible_topology_itemSerializer<TList> sr; sr.FromSdaiAggr(lst, m_instance, aggr); }

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class reversible_topology_put : public Select
    {
    public:
        reversible_topology_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        reversible_topology_put(Select* outer) : Select(outer) {}
        reversible_topology_item_put put_reversible_topology_item() { return reversible_topology_item_put(this); }

                //TList may be list_of_reversible_topology_item or list of converible elements
        template <typename TList> void put_list_of_reversible_topology_item(TList& lst) { list_of_reversible_topology_itemSerializer<TList> sr; SdaiAggr aggr = sr.ToSdaiAggr(lst, m_instance, NULL); putAggrValue("LIST_OF_REVERSIBLE_TOPOLOGY_ITEM", aggr); }

                //TList may be set_of_reversible_topology_item or list of converible elements
        template <typename TList> void put_set_of_reversible_topology_item(TList& lst) { set_of_reversible_topology_itemSerializer<TList> sr; SdaiAggr aggr = sr.ToSdaiAggr(lst, m_instance, NULL); putAggrValue("SET_OF_REVERSIBLE_TOPOLOGY_ITEM", aggr); }
    };


    class role_select : public Select
    {
    public:
        role_select(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        role_select(Select* outer) : Select(outer) {}

        bool is_group_assignment() { return IsADBEntity("group_assignment"); }
        group_assignment get_group_assignment();
        void put_group_assignment(group_assignment inst);
    };


    class role_select_get : public Select
    {
    public:
        role_select_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        role_select_get(Select* outer) : Select(outer) {}
        bool is_group_assignment() { return IsADBEntity("group_assignment"); }
        group_assignment get_group_assignment();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class role_select_put : public Select
    {
    public:
        role_select_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        role_select_put(Select* outer) : Select(outer) {}
        void put_group_assignment(group_assignment inst);
    };


    class select_analysis_model_item : public Select
    {
    public:
        select_analysis_model_item(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_analysis_model_item(Select* outer) : Select(outer) {}

        bool is_analysis_method() { return IsADBEntity("analysis_method"); }
        analysis_method get_analysis_method();
        void put_analysis_method(analysis_method inst);

        bool is_boundary_condition() { return IsADBEntity("boundary_condition"); }
        boundary_condition get_boundary_condition();
        void put_boundary_condition(boundary_condition inst);

        bool is_element_eccentricity() { return IsADBEntity("element_eccentricity"); }
        element_eccentricity get_element_eccentricity();
        void put_element_eccentricity(element_eccentricity inst);

        bool is_element_node_connectivity() { return IsADBEntity("element_node_connectivity"); }
        element_node_connectivity get_element_node_connectivity();
        void put_element_node_connectivity(element_node_connectivity inst);

        bool is_analysis_model() { return IsADBEntity("analysis_model"); }
        analysis_model get_analysis_model();
        void put_analysis_model(analysis_model inst);

        bool is_analysis_model_mapping() { return IsADBEntity("analysis_model_mapping"); }
        analysis_model_mapping get_analysis_model_mapping();
        void put_analysis_model_mapping(analysis_model_mapping inst);

        bool is_analysis_model_relationship() { return IsADBEntity("analysis_model_relationship"); }
        analysis_model_relationship get_analysis_model_relationship();
        void put_analysis_model_relationship(analysis_model_relationship inst);

        bool is_element() { return IsADBEntity("element"); }
        element get_element();
        void put_element(element inst);

        bool is_element_mapping() { return IsADBEntity("element_mapping"); }
        element_mapping get_element_mapping();
        void put_element_mapping(element_mapping inst);

        bool is_node() { return IsADBEntity("node"); }
        node get_node();
        void put_node(node inst);

        bool is_node_dependency() { return IsADBEntity("node_dependency"); }
        node_dependency get_node_dependency();
        void put_node_dependency(node_dependency inst);

        bool is_release() { return IsADBEntity("release"); }
        release get_release();
        void put_release(release inst);
    };


    class select_analysis_model_item_get : public Select
    {
    public:
        select_analysis_model_item_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_analysis_model_item_get(Select* outer) : Select(outer) {}
        bool is_analysis_method() { return IsADBEntity("analysis_method"); }
        analysis_method get_analysis_method();
        bool is_boundary_condition() { return IsADBEntity("boundary_condition"); }
        boundary_condition get_boundary_condition();
        bool is_element_eccentricity() { return IsADBEntity("element_eccentricity"); }
        element_eccentricity get_element_eccentricity();
        bool is_element_node_connectivity() { return IsADBEntity("element_node_connectivity"); }
        element_node_connectivity get_element_node_connectivity();
        bool is_analysis_model() { return IsADBEntity("analysis_model"); }
        analysis_model get_analysis_model();
        bool is_analysis_model_mapping() { return IsADBEntity("analysis_model_mapping"); }
        analysis_model_mapping get_analysis_model_mapping();
        bool is_analysis_model_relationship() { return IsADBEntity("analysis_model_relationship"); }
        analysis_model_relationship get_analysis_model_relationship();
        bool is_element() { return IsADBEntity("element"); }
        element get_element();
        bool is_element_mapping() { return IsADBEntity("element_mapping"); }
        element_mapping get_element_mapping();
        bool is_node() { return IsADBEntity("node"); }
        node get_node();
        bool is_node_dependency() { return IsADBEntity("node_dependency"); }
        node_dependency get_node_dependency();
        bool is_release() { return IsADBEntity("release"); }
        release get_release();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class select_analysis_model_item_put : public Select
    {
    public:
        select_analysis_model_item_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_analysis_model_item_put(Select* outer) : Select(outer) {}
        void put_analysis_method(analysis_method inst);
        void put_boundary_condition(boundary_condition inst);
        void put_element_eccentricity(element_eccentricity inst);
        void put_element_node_connectivity(element_node_connectivity inst);
        void put_analysis_model(analysis_model inst);
        void put_analysis_model_mapping(analysis_model_mapping inst);
        void put_analysis_model_relationship(analysis_model_relationship inst);
        void put_element(element inst);
        void put_element_mapping(element_mapping inst);
        void put_node(node inst);
        void put_node_dependency(node_dependency inst);
        void put_release(release inst);
    };


    class select_loading_item : public Select
    {
    public:
        select_loading_item(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_loading_item(Select* outer) : Select(outer) {}

        bool is_applied_load() { return IsADBEntity("applied_load"); }
        applied_load get_applied_load();
        void put_applied_load(applied_load inst);

        bool is_load_case() { return IsADBEntity("load_case"); }
        load_case get_load_case();
        void put_load_case(load_case inst);

        bool is_load() { return IsADBEntity("load"); }
        load get_load();
        void put_load(load inst);

        bool is_loaded_product() { return IsADBEntity("loaded_product"); }
        loaded_product get_loaded_product();
        void put_loaded_product(loaded_product inst);

        bool is_loading_combination() { return IsADBEntity("loading_combination"); }
        loading_combination get_loading_combination();
        void put_loading_combination(loading_combination inst);

        bool is_load_combination_occurrence() { return IsADBEntity("load_combination_occurrence"); }
        load_combination_occurrence get_load_combination_occurrence();
        void put_load_combination_occurrence(load_combination_occurrence inst);

        bool is_physical_action() { return IsADBEntity("physical_action"); }
        physical_action get_physical_action();
        void put_physical_action(physical_action inst);
    };


    class select_loading_item_get : public Select
    {
    public:
        select_loading_item_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_loading_item_get(Select* outer) : Select(outer) {}
        bool is_applied_load() { return IsADBEntity("applied_load"); }
        applied_load get_applied_load();
        bool is_load_case() { return IsADBEntity("load_case"); }
        load_case get_load_case();
        bool is_load() { return IsADBEntity("load"); }
        load get_load();
        bool is_loaded_product() { return IsADBEntity("loaded_product"); }
        loaded_product get_loaded_product();
        bool is_loading_combination() { return IsADBEntity("loading_combination"); }
        loading_combination get_loading_combination();
        bool is_load_combination_occurrence() { return IsADBEntity("load_combination_occurrence"); }
        load_combination_occurrence get_load_combination_occurrence();
        bool is_physical_action() { return IsADBEntity("physical_action"); }
        physical_action get_physical_action();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class select_loading_item_put : public Select
    {
    public:
        select_loading_item_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_loading_item_put(Select* outer) : Select(outer) {}
        void put_applied_load(applied_load inst);
        void put_load_case(load_case inst);
        void put_load(load inst);
        void put_loaded_product(loaded_product inst);
        void put_loading_combination(loading_combination inst);
        void put_load_combination_occurrence(load_combination_occurrence inst);
        void put_physical_action(physical_action inst);
    };


    class select_response_item : public Select
    {
    public:
        select_response_item(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_response_item(Select* outer) : Select(outer) {}

        bool is_analysis_result() { return IsADBEntity("analysis_result"); }
        analysis_result get_analysis_result();
        void put_analysis_result(analysis_result inst);

        bool is_analysis_results_set() { return IsADBEntity("analysis_results_set"); }
        analysis_results_set get_analysis_results_set();
        void put_analysis_results_set(analysis_results_set inst);

        bool is_design_result() { return IsADBEntity("design_result"); }
        design_result get_design_result();
        void put_design_result(design_result inst);

        bool is_reaction() { return IsADBEntity("reaction"); }
        reaction get_reaction();
        void put_reaction(reaction inst);
    };


    class select_response_item_get : public Select
    {
    public:
        select_response_item_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_response_item_get(Select* outer) : Select(outer) {}
        bool is_analysis_result() { return IsADBEntity("analysis_result"); }
        analysis_result get_analysis_result();
        bool is_analysis_results_set() { return IsADBEntity("analysis_results_set"); }
        analysis_results_set get_analysis_results_set();
        bool is_design_result() { return IsADBEntity("design_result"); }
        design_result get_design_result();
        bool is_reaction() { return IsADBEntity("reaction"); }
        reaction get_reaction();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class select_response_item_put : public Select
    {
    public:
        select_response_item_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_response_item_put(Select* outer) : Select(outer) {}
        void put_analysis_result(analysis_result inst);
        void put_analysis_results_set(analysis_results_set inst);
        void put_design_result(design_result inst);
        void put_reaction(reaction inst);
    };


    class select_analysis_item : public Select
    {
    public:
        select_analysis_item(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_analysis_item(Select* outer) : Select(outer) {}

        select_analysis_model_item _select_analysis_model_item() { return select_analysis_model_item(this); }

        select_loading_item _select_loading_item() { return select_loading_item(this); }

        select_response_item _select_response_item() { return select_response_item(this); }
    };


    class select_analysis_item_get : public Select
    {
    public:
        select_analysis_item_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_analysis_item_get(Select* outer) : Select(outer) {}
        select_analysis_model_item_get get_select_analysis_model_item() { return select_analysis_model_item_get(this); }
        select_loading_item_get get_select_loading_item() { return select_loading_item_get(this); }
        select_response_item_get get_select_response_item() { return select_response_item_get(this); }

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class select_analysis_item_put : public Select
    {
    public:
        select_analysis_item_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_analysis_item_put(Select* outer) : Select(outer) {}
        select_analysis_model_item_put put_select_analysis_model_item() { return select_analysis_model_item_put(this); }
        select_loading_item_put put_select_loading_item() { return select_loading_item_put(this); }
        select_response_item_put put_select_response_item() { return select_response_item_put(this); }
    };


    class value_qualifier : public Select
    {
    public:
        value_qualifier(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        value_qualifier(Select* outer) : Select(outer) {}

        bool is_precision_qualifier() { return IsADBEntity("precision_qualifier"); }
        precision_qualifier get_precision_qualifier();
        void put_precision_qualifier(precision_qualifier inst);

        bool is_type_qualifier() { return IsADBEntity("type_qualifier"); }
        type_qualifier get_type_qualifier();
        void put_type_qualifier(type_qualifier inst);

        bool is_uncertainty_qualifier() { return IsADBEntity("uncertainty_qualifier"); }
        uncertainty_qualifier get_uncertainty_qualifier();
        void put_uncertainty_qualifier(uncertainty_qualifier inst);
    };


    class value_qualifier_get : public Select
    {
    public:
        value_qualifier_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        value_qualifier_get(Select* outer) : Select(outer) {}
        bool is_precision_qualifier() { return IsADBEntity("precision_qualifier"); }
        precision_qualifier get_precision_qualifier();
        bool is_type_qualifier() { return IsADBEntity("type_qualifier"); }
        type_qualifier get_type_qualifier();
        bool is_uncertainty_qualifier() { return IsADBEntity("uncertainty_qualifier"); }
        uncertainty_qualifier get_uncertainty_qualifier();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class value_qualifier_put : public Select
    {
    public:
        value_qualifier_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        value_qualifier_put(Select* outer) : Select(outer) {}
        void put_precision_qualifier(precision_qualifier inst);
        void put_type_qualifier(type_qualifier inst);
        void put_uncertainty_qualifier(uncertainty_qualifier inst);
    };


    class select_generic_item : public Select
    {
    public:
        select_generic_item(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_generic_item(Select* outer) : Select(outer) {}

        bool is_action() { return IsADBEntity("action"); }
        action get_action();
        void put_action(action inst);

        bool is_action_directive() { return IsADBEntity("action_directive"); }
        action_directive get_action_directive();
        void put_action_directive(action_directive inst);

        bool is_action_method() { return IsADBEntity("action_method"); }
        action_method get_action_method();
        void put_action_method(action_method inst);

        bool is_address() { return IsADBEntity("address"); }
        address get_address();
        void put_address(address inst);

        bool is_approval() { return IsADBEntity("approval"); }
        approval get_approval();
        void put_approval(approval inst);

        bool is_approval_status() { return IsADBEntity("approval_status"); }
        approval_status get_approval_status();
        void put_approval_status(approval_status inst);

        bool is_box_domain() { return IsADBEntity("box_domain"); }
        box_domain get_box_domain();
        void put_box_domain(box_domain inst);

        bool is_certification() { return IsADBEntity("certification"); }
        certification get_certification();
        void put_certification(certification inst);

        bool is_certification_type() { return IsADBEntity("certification_type"); }
        certification_type get_certification_type();
        void put_certification_type(certification_type inst);

        bool is_contract() { return IsADBEntity("contract"); }
        contract get_contract();
        void put_contract(contract inst);

        bool is_contract_type() { return IsADBEntity("contract_type"); }
        contract_type get_contract_type();
        void put_contract_type(contract_type inst);

        bool is_coordinated_universal_time_offset() { return IsADBEntity("coordinated_universal_time_offset"); }
        coordinated_universal_time_offset get_coordinated_universal_time_offset();
        void put_coordinated_universal_time_offset(coordinated_universal_time_offset inst);

        bool is_date() { return IsADBEntity("date"); }
        date get_date();
        void put_date(date inst);

        bool is_date_and_time() { return IsADBEntity("date_and_time"); }
        date_and_time get_date_and_time();
        void put_date_and_time(date_and_time inst);

        bool is_derived_unit() { return IsADBEntity("derived_unit"); }
        derived_unit get_derived_unit();
        void put_derived_unit(derived_unit inst);

        bool is_derived_unit_element() { return IsADBEntity("derived_unit_element"); }
        derived_unit_element get_derived_unit_element();
        void put_derived_unit_element(derived_unit_element inst);

        bool is_description_attribute() { return IsADBEntity("description_attribute"); }
        description_attribute get_description_attribute();
        void put_description_attribute(description_attribute inst);

        bool is_dimensional_exponents() { return IsADBEntity("dimensional_exponents"); }
        dimensional_exponents get_dimensional_exponents();
        void put_dimensional_exponents(dimensional_exponents inst);

        bool is_document() { return IsADBEntity("document"); }
        document get_document();
        void put_document(document inst);

        bool is_document_type() { return IsADBEntity("document_type"); }
        document_type get_document_type();
        void put_document_type(document_type inst);

        bool is_document_relationship() { return IsADBEntity("document_relationship"); }
        document_relationship get_document_relationship();
        void put_document_relationship(document_relationship inst);

        bool is_document_representation_type() { return IsADBEntity("document_representation_type"); }
        document_representation_type get_document_representation_type();
        void put_document_representation_type(document_representation_type inst);

        bool is_document_usage_constraint() { return IsADBEntity("document_usage_constraint"); }
        document_usage_constraint get_document_usage_constraint();
        void put_document_usage_constraint(document_usage_constraint inst);

        bool is_founded_item() { return IsADBEntity("founded_item"); }
        founded_item get_founded_item();
        void put_founded_item(founded_item inst);

        bool is_functionally_defined_transformation() { return IsADBEntity("functionally_defined_transformation"); }
        functionally_defined_transformation get_functionally_defined_transformation();
        void put_functionally_defined_transformation(functionally_defined_transformation inst);

        bool is_group() { return IsADBEntity("group"); }
        group get_group();
        void put_group(group inst);

        bool is_group_assignment() { return IsADBEntity("group_assignment"); }
        group_assignment get_group_assignment();
        void put_group_assignment(group_assignment inst);

        bool is_group_relationship() { return IsADBEntity("group_relationship"); }
        group_relationship get_group_relationship();
        void put_group_relationship(group_relationship inst);

        bool is_id_attribute() { return IsADBEntity("id_attribute"); }
        id_attribute get_id_attribute();
        void put_id_attribute(id_attribute inst);

        bool is_item_defined_transformation() { return IsADBEntity("item_defined_transformation"); }
        item_defined_transformation get_item_defined_transformation();
        void put_item_defined_transformation(item_defined_transformation inst);

        bool is_local_time() { return IsADBEntity("local_time"); }
        local_time get_local_time();
        void put_local_time(local_time inst);

        bool is_measure_qualification() { return IsADBEntity("measure_qualification"); }
        measure_qualification get_measure_qualification();
        void put_measure_qualification(measure_qualification inst);

        bool is_measure_with_unit() { return IsADBEntity("measure_with_unit"); }
        measure_with_unit get_measure_with_unit();
        void put_measure_with_unit(measure_with_unit inst);

        bool is_name_attribute() { return IsADBEntity("name_attribute"); }
        name_attribute get_name_attribute();
        void put_name_attribute(name_attribute inst);

        bool is_named_unit() { return IsADBEntity("named_unit"); }
        named_unit get_named_unit();
        void put_named_unit(named_unit inst);

        bool is_object_role() { return IsADBEntity("object_role"); }
        object_role get_object_role();
        void put_object_role(object_role inst);

        bool is_organization() { return IsADBEntity("organization"); }
        organization get_organization();
        void put_organization(organization inst);

        bool is_organization_relationship() { return IsADBEntity("organization_relationship"); }
        organization_relationship get_organization_relationship();
        void put_organization_relationship(organization_relationship inst);

        bool is_person() { return IsADBEntity("person"); }
        person get_person();
        void put_person(person inst);

        bool is_person_and_organization() { return IsADBEntity("person_and_organization"); }
        person_and_organization get_person_and_organization();
        void put_person_and_organization(person_and_organization inst);

        bool is_person_and_organization_role() { return IsADBEntity("person_and_organization_role"); }
        person_and_organization_role get_person_and_organization_role();
        void put_person_and_organization_role(person_and_organization_role inst);

        bool is_representation() { return IsADBEntity("representation"); }
        representation get_representation();
        void put_representation(representation inst);

        bool is_representation_context() { return IsADBEntity("representation_context"); }
        representation_context get_representation_context();
        void put_representation_context(representation_context inst);

        bool is_representation_item() { return IsADBEntity("representation_item"); }
        representation_item get_representation_item();
        void put_representation_item(representation_item inst);

        bool is_representation_map() { return IsADBEntity("representation_map"); }
        representation_map get_representation_map();
        void put_representation_map(representation_map inst);

        bool is_representation_relationship() { return IsADBEntity("representation_relationship"); }
        representation_relationship get_representation_relationship();
        void put_representation_relationship(representation_relationship inst);

        bool is_role_association() { return IsADBEntity("role_association"); }
        role_association get_role_association();
        void put_role_association(role_association inst);

        bool is_surface_patch() { return IsADBEntity("surface_patch"); }
        surface_patch get_surface_patch();
        void put_surface_patch(surface_patch inst);

        value_qualifier _value_qualifier() { return value_qualifier(this); }

        bool is_versioned_action_request() { return IsADBEntity("versioned_action_request"); }
        versioned_action_request get_versioned_action_request();
        void put_versioned_action_request(versioned_action_request inst);
    };


    class select_generic_item_get : public Select
    {
    public:
        select_generic_item_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_generic_item_get(Select* outer) : Select(outer) {}
        bool is_action() { return IsADBEntity("action"); }
        action get_action();
        bool is_action_directive() { return IsADBEntity("action_directive"); }
        action_directive get_action_directive();
        bool is_action_method() { return IsADBEntity("action_method"); }
        action_method get_action_method();
        bool is_address() { return IsADBEntity("address"); }
        address get_address();
        bool is_approval() { return IsADBEntity("approval"); }
        approval get_approval();
        bool is_approval_status() { return IsADBEntity("approval_status"); }
        approval_status get_approval_status();
        bool is_box_domain() { return IsADBEntity("box_domain"); }
        box_domain get_box_domain();
        bool is_certification() { return IsADBEntity("certification"); }
        certification get_certification();
        bool is_certification_type() { return IsADBEntity("certification_type"); }
        certification_type get_certification_type();
        bool is_contract() { return IsADBEntity("contract"); }
        contract get_contract();
        bool is_contract_type() { return IsADBEntity("contract_type"); }
        contract_type get_contract_type();
        bool is_coordinated_universal_time_offset() { return IsADBEntity("coordinated_universal_time_offset"); }
        coordinated_universal_time_offset get_coordinated_universal_time_offset();
        bool is_date() { return IsADBEntity("date"); }
        date get_date();
        bool is_date_and_time() { return IsADBEntity("date_and_time"); }
        date_and_time get_date_and_time();
        bool is_derived_unit() { return IsADBEntity("derived_unit"); }
        derived_unit get_derived_unit();
        bool is_derived_unit_element() { return IsADBEntity("derived_unit_element"); }
        derived_unit_element get_derived_unit_element();
        bool is_description_attribute() { return IsADBEntity("description_attribute"); }
        description_attribute get_description_attribute();
        bool is_dimensional_exponents() { return IsADBEntity("dimensional_exponents"); }
        dimensional_exponents get_dimensional_exponents();
        bool is_document() { return IsADBEntity("document"); }
        document get_document();
        bool is_document_type() { return IsADBEntity("document_type"); }
        document_type get_document_type();
        bool is_document_relationship() { return IsADBEntity("document_relationship"); }
        document_relationship get_document_relationship();
        bool is_document_representation_type() { return IsADBEntity("document_representation_type"); }
        document_representation_type get_document_representation_type();
        bool is_document_usage_constraint() { return IsADBEntity("document_usage_constraint"); }
        document_usage_constraint get_document_usage_constraint();
        bool is_founded_item() { return IsADBEntity("founded_item"); }
        founded_item get_founded_item();
        bool is_functionally_defined_transformation() { return IsADBEntity("functionally_defined_transformation"); }
        functionally_defined_transformation get_functionally_defined_transformation();
        bool is_group() { return IsADBEntity("group"); }
        group get_group();
        bool is_group_assignment() { return IsADBEntity("group_assignment"); }
        group_assignment get_group_assignment();
        bool is_group_relationship() { return IsADBEntity("group_relationship"); }
        group_relationship get_group_relationship();
        bool is_id_attribute() { return IsADBEntity("id_attribute"); }
        id_attribute get_id_attribute();
        bool is_item_defined_transformation() { return IsADBEntity("item_defined_transformation"); }
        item_defined_transformation get_item_defined_transformation();
        bool is_local_time() { return IsADBEntity("local_time"); }
        local_time get_local_time();
        bool is_measure_qualification() { return IsADBEntity("measure_qualification"); }
        measure_qualification get_measure_qualification();
        bool is_measure_with_unit() { return IsADBEntity("measure_with_unit"); }
        measure_with_unit get_measure_with_unit();
        bool is_name_attribute() { return IsADBEntity("name_attribute"); }
        name_attribute get_name_attribute();
        bool is_named_unit() { return IsADBEntity("named_unit"); }
        named_unit get_named_unit();
        bool is_object_role() { return IsADBEntity("object_role"); }
        object_role get_object_role();
        bool is_organization() { return IsADBEntity("organization"); }
        organization get_organization();
        bool is_organization_relationship() { return IsADBEntity("organization_relationship"); }
        organization_relationship get_organization_relationship();
        bool is_person() { return IsADBEntity("person"); }
        person get_person();
        bool is_person_and_organization() { return IsADBEntity("person_and_organization"); }
        person_and_organization get_person_and_organization();
        bool is_person_and_organization_role() { return IsADBEntity("person_and_organization_role"); }
        person_and_organization_role get_person_and_organization_role();
        bool is_representation() { return IsADBEntity("representation"); }
        representation get_representation();
        bool is_representation_context() { return IsADBEntity("representation_context"); }
        representation_context get_representation_context();
        bool is_representation_item() { return IsADBEntity("representation_item"); }
        representation_item get_representation_item();
        bool is_representation_map() { return IsADBEntity("representation_map"); }
        representation_map get_representation_map();
        bool is_representation_relationship() { return IsADBEntity("representation_relationship"); }
        representation_relationship get_representation_relationship();
        bool is_role_association() { return IsADBEntity("role_association"); }
        role_association get_role_association();
        bool is_surface_patch() { return IsADBEntity("surface_patch"); }
        surface_patch get_surface_patch();
        value_qualifier_get get_value_qualifier() { return value_qualifier_get(this); }
        bool is_versioned_action_request() { return IsADBEntity("versioned_action_request"); }
        versioned_action_request get_versioned_action_request();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class select_generic_item_put : public Select
    {
    public:
        select_generic_item_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_generic_item_put(Select* outer) : Select(outer) {}
        void put_action(action inst);
        void put_action_directive(action_directive inst);
        void put_action_method(action_method inst);
        void put_address(address inst);
        void put_approval(approval inst);
        void put_approval_status(approval_status inst);
        void put_box_domain(box_domain inst);
        void put_certification(certification inst);
        void put_certification_type(certification_type inst);
        void put_contract(contract inst);
        void put_contract_type(contract_type inst);
        void put_coordinated_universal_time_offset(coordinated_universal_time_offset inst);
        void put_date(date inst);
        void put_date_and_time(date_and_time inst);
        void put_derived_unit(derived_unit inst);
        void put_derived_unit_element(derived_unit_element inst);
        void put_description_attribute(description_attribute inst);
        void put_dimensional_exponents(dimensional_exponents inst);
        void put_document(document inst);
        void put_document_type(document_type inst);
        void put_document_relationship(document_relationship inst);
        void put_document_representation_type(document_representation_type inst);
        void put_document_usage_constraint(document_usage_constraint inst);
        void put_founded_item(founded_item inst);
        void put_functionally_defined_transformation(functionally_defined_transformation inst);
        void put_group(group inst);
        void put_group_assignment(group_assignment inst);
        void put_group_relationship(group_relationship inst);
        void put_id_attribute(id_attribute inst);
        void put_item_defined_transformation(item_defined_transformation inst);
        void put_local_time(local_time inst);
        void put_measure_qualification(measure_qualification inst);
        void put_measure_with_unit(measure_with_unit inst);
        void put_name_attribute(name_attribute inst);
        void put_named_unit(named_unit inst);
        void put_object_role(object_role inst);
        void put_organization(organization inst);
        void put_organization_relationship(organization_relationship inst);
        void put_person(person inst);
        void put_person_and_organization(person_and_organization inst);
        void put_person_and_organization_role(person_and_organization_role inst);
        void put_representation(representation inst);
        void put_representation_context(representation_context inst);
        void put_representation_item(representation_item inst);
        void put_representation_map(representation_map inst);
        void put_representation_relationship(representation_relationship inst);
        void put_role_association(role_association inst);
        void put_surface_patch(surface_patch inst);
        value_qualifier_put put_value_qualifier() { return value_qualifier_put(this); }
        void put_versioned_action_request(versioned_action_request inst);
    };


    class select_design_item : public Select
    {
    public:
        select_design_item(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_design_item(Select* outer) : Select(outer) {}

        bool is_assembly_design() { return IsADBEntity("assembly_design"); }
        assembly_design get_assembly_design();
        void put_assembly_design(assembly_design inst);

        bool is_assembly_map() { return IsADBEntity("assembly_map"); }
        assembly_map get_assembly_map();
        void put_assembly_map(assembly_map inst);

        bool is_assembly_relationship() { return IsADBEntity("assembly_relationship"); }
        assembly_relationship get_assembly_relationship();
        void put_assembly_relationship(assembly_relationship inst);

        bool is_design_criterion() { return IsADBEntity("design_criterion"); }
        design_criterion get_design_criterion();
        void put_design_criterion(design_criterion inst);

        bool is_design_joint_system() { return IsADBEntity("design_joint_system"); }
        design_joint_system get_design_joint_system();
        void put_design_joint_system(design_joint_system inst);

        bool is_design_part() { return IsADBEntity("design_part"); }
        design_part get_design_part();
        void put_design_part(design_part inst);

        bool is_design_result() { return IsADBEntity("design_result"); }
        design_result get_design_result();
        void put_design_result(design_result inst);

        bool is_effective_buckling_length() { return IsADBEntity("effective_buckling_length"); }
        effective_buckling_length get_effective_buckling_length();
        void put_effective_buckling_length(effective_buckling_length inst);

        bool is_functional_role() { return IsADBEntity("functional_role"); }
        functional_role get_functional_role();
        void put_functional_role(functional_role inst);

        bool is_resistance() { return IsADBEntity("resistance"); }
        resistance get_resistance();
        void put_resistance(resistance inst);

        bool is_restraint() { return IsADBEntity("restraint"); }
        restraint get_restraint();
        void put_restraint(restraint inst);
    };


    class select_design_item_get : public Select
    {
    public:
        select_design_item_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_design_item_get(Select* outer) : Select(outer) {}
        bool is_assembly_design() { return IsADBEntity("assembly_design"); }
        assembly_design get_assembly_design();
        bool is_assembly_map() { return IsADBEntity("assembly_map"); }
        assembly_map get_assembly_map();
        bool is_assembly_relationship() { return IsADBEntity("assembly_relationship"); }
        assembly_relationship get_assembly_relationship();
        bool is_design_criterion() { return IsADBEntity("design_criterion"); }
        design_criterion get_design_criterion();
        bool is_design_joint_system() { return IsADBEntity("design_joint_system"); }
        design_joint_system get_design_joint_system();
        bool is_design_part() { return IsADBEntity("design_part"); }
        design_part get_design_part();
        bool is_design_result() { return IsADBEntity("design_result"); }
        design_result get_design_result();
        bool is_effective_buckling_length() { return IsADBEntity("effective_buckling_length"); }
        effective_buckling_length get_effective_buckling_length();
        bool is_functional_role() { return IsADBEntity("functional_role"); }
        functional_role get_functional_role();
        bool is_resistance() { return IsADBEntity("resistance"); }
        resistance get_resistance();
        bool is_restraint() { return IsADBEntity("restraint"); }
        restraint get_restraint();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class select_design_item_put : public Select
    {
    public:
        select_design_item_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_design_item_put(Select* outer) : Select(outer) {}
        void put_assembly_design(assembly_design inst);
        void put_assembly_map(assembly_map inst);
        void put_assembly_relationship(assembly_relationship inst);
        void put_design_criterion(design_criterion inst);
        void put_design_joint_system(design_joint_system inst);
        void put_design_part(design_part inst);
        void put_design_result(design_result inst);
        void put_effective_buckling_length(effective_buckling_length inst);
        void put_functional_role(functional_role inst);
        void put_resistance(resistance inst);
        void put_restraint(restraint inst);
    };


    class select_physical_item : public Select
    {
    public:
        select_physical_item(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_physical_item(Select* outer) : Select(outer) {}

        bool is_located_item() { return IsADBEntity("located_item"); }
        located_item get_located_item();
        void put_located_item(located_item inst);

        bool is_located_part_joint() { return IsADBEntity("located_part_joint"); }
        located_part_joint get_located_part_joint();
        void put_located_part_joint(located_part_joint inst);
    };


    class select_physical_item_get : public Select
    {
    public:
        select_physical_item_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_physical_item_get(Select* outer) : Select(outer) {}
        bool is_located_item() { return IsADBEntity("located_item"); }
        located_item get_located_item();
        bool is_located_part_joint() { return IsADBEntity("located_part_joint"); }
        located_part_joint get_located_part_joint();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class select_physical_item_put : public Select
    {
    public:
        select_physical_item_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_physical_item_put(Select* outer) : Select(outer) {}
        void put_located_item(located_item inst);
        void put_located_part_joint(located_part_joint inst);
    };


    class select_project_definition_item : public Select
    {
    public:
        select_project_definition_item(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_project_definition_item(Select* outer) : Select(outer) {}

        bool is_assembly() { return IsADBEntity("assembly"); }
        assembly get_assembly();
        void put_assembly(assembly inst);

        bool is_building() { return IsADBEntity("building"); }
        building get_building();
        void put_building(building inst);

        bool is_building_complex() { return IsADBEntity("building_complex"); }
        building_complex get_building_complex();
        void put_building_complex(building_complex inst);

        bool is_currency_measure_with_unit() { return IsADBEntity("currency_measure_with_unit"); }
        currency_measure_with_unit get_currency_measure_with_unit();
        void put_currency_measure_with_unit(currency_measure_with_unit inst);

        bool is_project() { return IsADBEntity("project"); }
        project get_project();
        void put_project(project inst);

        bool is_project_plan() { return IsADBEntity("project_plan"); }
        project_plan get_project_plan();
        void put_project_plan(project_plan inst);

        bool is_project_plan_item() { return IsADBEntity("project_plan_item"); }
        project_plan_item get_project_plan_item();
        void put_project_plan_item(project_plan_item inst);

        bool is_project_plan_item_relationship() { return IsADBEntity("project_plan_item_relationship"); }
        project_plan_item_relationship get_project_plan_item_relationship();
        void put_project_plan_item_relationship(project_plan_item_relationship inst);

        bool is_project_organization() { return IsADBEntity("project_organization"); }
        project_organization get_project_organization();
        void put_project_organization(project_organization inst);

        bool is_site() { return IsADBEntity("site"); }
        site get_site();
        void put_site(site inst);

        bool is_structure() { return IsADBEntity("structure"); }
        structure get_structure();
        void put_structure(structure inst);
    };


    class select_project_definition_item_get : public Select
    {
    public:
        select_project_definition_item_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_project_definition_item_get(Select* outer) : Select(outer) {}
        bool is_assembly() { return IsADBEntity("assembly"); }
        assembly get_assembly();
        bool is_building() { return IsADBEntity("building"); }
        building get_building();
        bool is_building_complex() { return IsADBEntity("building_complex"); }
        building_complex get_building_complex();
        bool is_currency_measure_with_unit() { return IsADBEntity("currency_measure_with_unit"); }
        currency_measure_with_unit get_currency_measure_with_unit();
        bool is_project() { return IsADBEntity("project"); }
        project get_project();
        bool is_project_plan() { return IsADBEntity("project_plan"); }
        project_plan get_project_plan();
        bool is_project_plan_item() { return IsADBEntity("project_plan_item"); }
        project_plan_item get_project_plan_item();
        bool is_project_plan_item_relationship() { return IsADBEntity("project_plan_item_relationship"); }
        project_plan_item_relationship get_project_plan_item_relationship();
        bool is_project_organization() { return IsADBEntity("project_organization"); }
        project_organization get_project_organization();
        bool is_site() { return IsADBEntity("site"); }
        site get_site();
        bool is_structure() { return IsADBEntity("structure"); }
        structure get_structure();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class select_project_definition_item_put : public Select
    {
    public:
        select_project_definition_item_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_project_definition_item_put(Select* outer) : Select(outer) {}
        void put_assembly(assembly inst);
        void put_building(building inst);
        void put_building_complex(building_complex inst);
        void put_currency_measure_with_unit(currency_measure_with_unit inst);
        void put_project(project inst);
        void put_project_plan(project_plan inst);
        void put_project_plan_item(project_plan_item inst);
        void put_project_plan_item_relationship(project_plan_item_relationship inst);
        void put_project_organization(project_organization inst);
        void put_site(site inst);
        void put_structure(structure inst);
    };


    class select_structural_item : public Select
    {
    public:
        select_structural_item(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_structural_item(Select* outer) : Select(outer) {}

        bool is_coord_system() { return IsADBEntity("coord_system"); }
        coord_system get_coord_system();
        void put_coord_system(coord_system inst);

        bool is_grid() { return IsADBEntity("grid"); }
        grid get_grid();
        void put_grid(grid inst);

        bool is_grid_intersection() { return IsADBEntity("grid_intersection"); }
        grid_intersection get_grid_intersection();
        void put_grid_intersection(grid_intersection inst);

        bool is_grid_offset() { return IsADBEntity("grid_offset"); }
        grid_offset get_grid_offset();
        void put_grid_offset(grid_offset inst);

        bool is_geographical_location() { return IsADBEntity("geographical_location"); }
        geographical_location get_geographical_location();
        void put_geographical_location(geographical_location inst);

        bool is_item_cost_code() { return IsADBEntity("item_cost_code"); }
        item_cost_code get_item_cost_code();
        void put_item_cost_code(item_cost_code inst);

        bool is_item_cost_code_assigned() { return IsADBEntity("item_cost_code_assigned"); }
        item_cost_code_assigned get_item_cost_code_assigned();
        void put_item_cost_code_assigned(item_cost_code_assigned inst);

        bool is_item_property() { return IsADBEntity("item_property"); }
        item_property get_item_property();
        void put_item_property(item_property inst);

        bool is_item_property_assigned() { return IsADBEntity("item_property_assigned"); }
        item_property_assigned get_item_property_assigned();
        void put_item_property_assigned(item_property_assigned inst);

        bool is_item_reference() { return IsADBEntity("item_reference"); }
        item_reference get_item_reference();
        void put_item_reference(item_reference inst);

        bool is_item_reference_assigned() { return IsADBEntity("item_reference_assigned"); }
        item_reference_assigned get_item_reference_assigned();
        void put_item_reference_assigned(item_reference_assigned inst);

        bool is_item_ref_source() { return IsADBEntity("item_ref_source"); }
        item_ref_source get_item_ref_source();
        void put_item_ref_source(item_ref_source inst);

        bool is_item_ref_source_documented() { return IsADBEntity("item_ref_source_documented"); }
        item_ref_source_documented get_item_ref_source_documented();
        void put_item_ref_source_documented(item_ref_source_documented inst);

        bool is_section_properties() { return IsADBEntity("section_properties"); }
        section_properties get_section_properties();
        void put_section_properties(section_properties inst);

        bool is_setting_out_point() { return IsADBEntity("setting_out_point"); }
        setting_out_point get_setting_out_point();
        void put_setting_out_point(setting_out_point inst);

        bool is_structural_frame_item() { return IsADBEntity("structural_frame_item"); }
        structural_frame_item get_structural_frame_item();
        void put_structural_frame_item(structural_frame_item inst);

        bool is_structural_frame_item_approved() { return IsADBEntity("structural_frame_item_approved"); }
        structural_frame_item_approved get_structural_frame_item_approved();
        void put_structural_frame_item_approved(structural_frame_item_approved inst);

        bool is_structural_frame_item_certified() { return IsADBEntity("structural_frame_item_certified"); }
        structural_frame_item_certified get_structural_frame_item_certified();
        void put_structural_frame_item_certified(structural_frame_item_certified inst);

        bool is_structural_frame_item_documented() { return IsADBEntity("structural_frame_item_documented"); }
        structural_frame_item_documented get_structural_frame_item_documented();
        void put_structural_frame_item_documented(structural_frame_item_documented inst);

        bool is_structural_frame_item_priced() { return IsADBEntity("structural_frame_item_priced"); }
        structural_frame_item_priced get_structural_frame_item_priced();
        void put_structural_frame_item_priced(structural_frame_item_priced inst);

        bool is_structural_frame_item_relationship() { return IsADBEntity("structural_frame_item_relationship"); }
        structural_frame_item_relationship get_structural_frame_item_relationship();
        void put_structural_frame_item_relationship(structural_frame_item_relationship inst);

        bool is_zone() { return IsADBEntity("zone"); }
        zone get_zone();
        void put_zone(zone inst);
    };


    class select_structural_item_get : public Select
    {
    public:
        select_structural_item_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_structural_item_get(Select* outer) : Select(outer) {}
        bool is_coord_system() { return IsADBEntity("coord_system"); }
        coord_system get_coord_system();
        bool is_grid() { return IsADBEntity("grid"); }
        grid get_grid();
        bool is_grid_intersection() { return IsADBEntity("grid_intersection"); }
        grid_intersection get_grid_intersection();
        bool is_grid_offset() { return IsADBEntity("grid_offset"); }
        grid_offset get_grid_offset();
        bool is_geographical_location() { return IsADBEntity("geographical_location"); }
        geographical_location get_geographical_location();
        bool is_item_cost_code() { return IsADBEntity("item_cost_code"); }
        item_cost_code get_item_cost_code();
        bool is_item_cost_code_assigned() { return IsADBEntity("item_cost_code_assigned"); }
        item_cost_code_assigned get_item_cost_code_assigned();
        bool is_item_property() { return IsADBEntity("item_property"); }
        item_property get_item_property();
        bool is_item_property_assigned() { return IsADBEntity("item_property_assigned"); }
        item_property_assigned get_item_property_assigned();
        bool is_item_reference() { return IsADBEntity("item_reference"); }
        item_reference get_item_reference();
        bool is_item_reference_assigned() { return IsADBEntity("item_reference_assigned"); }
        item_reference_assigned get_item_reference_assigned();
        bool is_item_ref_source() { return IsADBEntity("item_ref_source"); }
        item_ref_source get_item_ref_source();
        bool is_item_ref_source_documented() { return IsADBEntity("item_ref_source_documented"); }
        item_ref_source_documented get_item_ref_source_documented();
        bool is_section_properties() { return IsADBEntity("section_properties"); }
        section_properties get_section_properties();
        bool is_setting_out_point() { return IsADBEntity("setting_out_point"); }
        setting_out_point get_setting_out_point();
        bool is_structural_frame_item() { return IsADBEntity("structural_frame_item"); }
        structural_frame_item get_structural_frame_item();
        bool is_structural_frame_item_approved() { return IsADBEntity("structural_frame_item_approved"); }
        structural_frame_item_approved get_structural_frame_item_approved();
        bool is_structural_frame_item_certified() { return IsADBEntity("structural_frame_item_certified"); }
        structural_frame_item_certified get_structural_frame_item_certified();
        bool is_structural_frame_item_documented() { return IsADBEntity("structural_frame_item_documented"); }
        structural_frame_item_documented get_structural_frame_item_documented();
        bool is_structural_frame_item_priced() { return IsADBEntity("structural_frame_item_priced"); }
        structural_frame_item_priced get_structural_frame_item_priced();
        bool is_structural_frame_item_relationship() { return IsADBEntity("structural_frame_item_relationship"); }
        structural_frame_item_relationship get_structural_frame_item_relationship();
        bool is_zone() { return IsADBEntity("zone"); }
        zone get_zone();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class select_structural_item_put : public Select
    {
    public:
        select_structural_item_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_structural_item_put(Select* outer) : Select(outer) {}
        void put_coord_system(coord_system inst);
        void put_grid(grid inst);
        void put_grid_intersection(grid_intersection inst);
        void put_grid_offset(grid_offset inst);
        void put_geographical_location(geographical_location inst);
        void put_item_cost_code(item_cost_code inst);
        void put_item_cost_code_assigned(item_cost_code_assigned inst);
        void put_item_property(item_property inst);
        void put_item_property_assigned(item_property_assigned inst);
        void put_item_reference(item_reference inst);
        void put_item_reference_assigned(item_reference_assigned inst);
        void put_item_ref_source(item_ref_source inst);
        void put_item_ref_source_documented(item_ref_source_documented inst);
        void put_section_properties(section_properties inst);
        void put_setting_out_point(setting_out_point inst);
        void put_structural_frame_item(structural_frame_item inst);
        void put_structural_frame_item_approved(structural_frame_item_approved inst);
        void put_structural_frame_item_certified(structural_frame_item_certified inst);
        void put_structural_frame_item_documented(structural_frame_item_documented inst);
        void put_structural_frame_item_priced(structural_frame_item_priced inst);
        void put_structural_frame_item_relationship(structural_frame_item_relationship inst);
        void put_zone(zone inst);
    };


    class select_data_item : public Select
    {
    public:
        select_data_item(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_data_item(Select* outer) : Select(outer) {}

        bool is_managed_data_deleted() { return IsADBEntity("managed_data_deleted"); }
        managed_data_deleted get_managed_data_deleted();
        void put_managed_data_deleted(managed_data_deleted inst);

        select_generic_item _select_generic_item() { return select_generic_item(this); }

        select_analysis_item _select_analysis_item() { return select_analysis_item(this); }

        select_design_item _select_design_item() { return select_design_item(this); }

        select_physical_item _select_physical_item() { return select_physical_item(this); }

        select_project_definition_item _select_project_definition_item() { return select_project_definition_item(this); }

        select_structural_item _select_structural_item() { return select_structural_item(this); }
    };


    class select_data_item_get : public Select
    {
    public:
        select_data_item_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_data_item_get(Select* outer) : Select(outer) {}
        bool is_managed_data_deleted() { return IsADBEntity("managed_data_deleted"); }
        managed_data_deleted get_managed_data_deleted();
        select_generic_item_get get_select_generic_item() { return select_generic_item_get(this); }
        select_analysis_item_get get_select_analysis_item() { return select_analysis_item_get(this); }
        select_design_item_get get_select_design_item() { return select_design_item_get(this); }
        select_physical_item_get get_select_physical_item() { return select_physical_item_get(this); }
        select_project_definition_item_get get_select_project_definition_item() { return select_project_definition_item_get(this); }
        select_structural_item_get get_select_structural_item() { return select_structural_item_get(this); }

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class select_data_item_put : public Select
    {
    public:
        select_data_item_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_data_item_put(Select* outer) : Select(outer) {}
        void put_managed_data_deleted(managed_data_deleted inst);
        select_generic_item_put put_select_generic_item() { return select_generic_item_put(this); }
        select_analysis_item_put put_select_analysis_item() { return select_analysis_item_put(this); }
        select_design_item_put put_select_design_item() { return select_design_item_put(this); }
        select_physical_item_put put_select_physical_item() { return select_physical_item_put(this); }
        select_project_definition_item_put put_select_project_definition_item() { return select_project_definition_item_put(this); }
        select_structural_item_put put_select_structural_item() { return select_structural_item_put(this); }
    };


    class select_data_source : public Select
    {
    public:
        select_data_source(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_data_source(Select* outer) : Select(outer) {}

        bool is_managed_application_installation() { return IsADBEntity("managed_application_installation"); }
        managed_application_installation get_managed_application_installation();
        void put_managed_application_installation(managed_application_installation inst);

        bool is_step_file() { return IsADBEntity("step_file"); }
        step_file get_step_file();
        void put_step_file(step_file inst);
    };


    class select_data_source_get : public Select
    {
    public:
        select_data_source_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_data_source_get(Select* outer) : Select(outer) {}
        bool is_managed_application_installation() { return IsADBEntity("managed_application_installation"); }
        managed_application_installation get_managed_application_installation();
        bool is_step_file() { return IsADBEntity("step_file"); }
        step_file get_step_file();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class select_data_source_put : public Select
    {
    public:
        select_data_source_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        select_data_source_put(Select* outer) : Select(outer) {}
        void put_managed_application_installation(managed_application_installation inst);
        void put_step_file(step_file inst);
    };


    class shell : public Select
    {
    public:
        shell(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        shell(Select* outer) : Select(outer) {}

        bool is_vertex_shell() { return IsADBEntity("vertex_shell"); }
        vertex_shell get_vertex_shell();
        void put_vertex_shell(vertex_shell inst);

        bool is_wire_shell() { return IsADBEntity("wire_shell"); }
        wire_shell get_wire_shell();
        void put_wire_shell(wire_shell inst);

        bool is_open_shell() { return IsADBEntity("open_shell"); }
        open_shell get_open_shell();
        void put_open_shell(open_shell inst);

        bool is_closed_shell() { return IsADBEntity("closed_shell"); }
        closed_shell get_closed_shell();
        void put_closed_shell(closed_shell inst);
    };


    class shell_get : public Select
    {
    public:
        shell_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        shell_get(Select* outer) : Select(outer) {}
        bool is_vertex_shell() { return IsADBEntity("vertex_shell"); }
        vertex_shell get_vertex_shell();
        bool is_wire_shell() { return IsADBEntity("wire_shell"); }
        wire_shell get_wire_shell();
        bool is_open_shell() { return IsADBEntity("open_shell"); }
        open_shell get_open_shell();
        bool is_closed_shell() { return IsADBEntity("closed_shell"); }
        closed_shell get_closed_shell();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class shell_put : public Select
    {
    public:
        shell_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        shell_put(Select* outer) : Select(outer) {}
        void put_vertex_shell(vertex_shell inst);
        void put_wire_shell(wire_shell inst);
        void put_open_shell(open_shell inst);
        void put_closed_shell(closed_shell inst);
    };


    class site_select : public Select
    {
    public:
        site_select(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        site_select(Select* outer) : Select(outer) {}

        bool is_site() { return IsADBEntity("site"); }
        site get_site();
        void put_site(site inst);

        bool is_located_site() { return IsADBEntity("located_site"); }
        located_site get_located_site();
        void put_located_site(located_site inst);

        bool is_zone_of_site() { return IsADBEntity("zone_of_site"); }
        zone_of_site get_zone_of_site();
        void put_zone_of_site(zone_of_site inst);

        bool is_zone_of_building() { return IsADBEntity("zone_of_building"); }
        zone_of_building get_zone_of_building();
        void put_zone_of_building(zone_of_building inst);

        bool is_building_complex() { return IsADBEntity("building_complex"); }
        building_complex get_building_complex();
        void put_building_complex(building_complex inst);
    };


    class site_select_get : public Select
    {
    public:
        site_select_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        site_select_get(Select* outer) : Select(outer) {}
        bool is_site() { return IsADBEntity("site"); }
        site get_site();
        bool is_located_site() { return IsADBEntity("located_site"); }
        located_site get_located_site();
        bool is_zone_of_site() { return IsADBEntity("zone_of_site"); }
        zone_of_site get_zone_of_site();
        bool is_zone_of_building() { return IsADBEntity("zone_of_building"); }
        zone_of_building get_zone_of_building();
        bool is_building_complex() { return IsADBEntity("building_complex"); }
        building_complex get_building_complex();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class site_select_put : public Select
    {
    public:
        site_select_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        site_select_put(Select* outer) : Select(outer) {}
        void put_site(site inst);
        void put_located_site(located_site inst);
        void put_zone_of_site(zone_of_site inst);
        void put_zone_of_building(zone_of_building inst);
        void put_building_complex(building_complex inst);
    };


    class structure_select : public Select
    {
    public:
        structure_select(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        structure_select(Select* outer) : Select(outer) {}

        bool is_structure() { return IsADBEntity("structure"); }
        structure get_structure();
        void put_structure(structure inst);

        bool is_located_structure() { return IsADBEntity("located_structure"); }
        located_structure get_located_structure();
        void put_located_structure(located_structure inst);

        bool is_zone_of_structure() { return IsADBEntity("zone_of_structure"); }
        zone_of_structure get_zone_of_structure();
        void put_zone_of_structure(zone_of_structure inst);

        bool is_zone_of_building() { return IsADBEntity("zone_of_building"); }
        zone_of_building get_zone_of_building();
        void put_zone_of_building(zone_of_building inst);

        bool is_located_assembly() { return IsADBEntity("located_assembly"); }
        located_assembly get_located_assembly();
        void put_located_assembly(located_assembly inst);
    };


    class structure_select_get : public Select
    {
    public:
        structure_select_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        structure_select_get(Select* outer) : Select(outer) {}
        bool is_structure() { return IsADBEntity("structure"); }
        structure get_structure();
        bool is_located_structure() { return IsADBEntity("located_structure"); }
        located_structure get_located_structure();
        bool is_zone_of_structure() { return IsADBEntity("zone_of_structure"); }
        zone_of_structure get_zone_of_structure();
        bool is_zone_of_building() { return IsADBEntity("zone_of_building"); }
        zone_of_building get_zone_of_building();
        bool is_located_assembly() { return IsADBEntity("located_assembly"); }
        located_assembly get_located_assembly();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class structure_select_put : public Select
    {
    public:
        structure_select_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        structure_select_put(Select* outer) : Select(outer) {}
        void put_structure(structure inst);
        void put_located_structure(located_structure inst);
        void put_zone_of_structure(zone_of_structure inst);
        void put_zone_of_building(zone_of_building inst);
        void put_located_assembly(located_assembly inst);
    };


    class surface_model : public Select
    {
    public:
        surface_model(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        surface_model(Select* outer) : Select(outer) {}

        bool is_shell_based_surface_model() { return IsADBEntity("shell_based_surface_model"); }
        shell_based_surface_model get_shell_based_surface_model();
        void put_shell_based_surface_model(shell_based_surface_model inst);

        bool is_face_based_surface_model() { return IsADBEntity("face_based_surface_model"); }
        face_based_surface_model get_face_based_surface_model();
        void put_face_based_surface_model(face_based_surface_model inst);
    };


    class surface_model_get : public Select
    {
    public:
        surface_model_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        surface_model_get(Select* outer) : Select(outer) {}
        bool is_shell_based_surface_model() { return IsADBEntity("shell_based_surface_model"); }
        shell_based_surface_model get_shell_based_surface_model();
        bool is_face_based_surface_model() { return IsADBEntity("face_based_surface_model"); }
        face_based_surface_model get_face_based_surface_model();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class surface_model_put : public Select
    {
    public:
        surface_model_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        surface_model_put(Select* outer) : Select(outer) {}
        void put_shell_based_surface_model(shell_based_surface_model inst);
        void put_face_based_surface_model(face_based_surface_model inst);
    };


    class transformation : public Select
    {
    public:
        transformation(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        transformation(Select* outer) : Select(outer) {}

        bool is_item_defined_transformation() { return IsADBEntity("item_defined_transformation"); }
        item_defined_transformation get_item_defined_transformation();
        void put_item_defined_transformation(item_defined_transformation inst);

        bool is_functionally_defined_transformation() { return IsADBEntity("functionally_defined_transformation"); }
        functionally_defined_transformation get_functionally_defined_transformation();
        void put_functionally_defined_transformation(functionally_defined_transformation inst);
    };


    class transformation_get : public Select
    {
    public:
        transformation_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        transformation_get(Select* outer) : Select(outer) {}
        bool is_item_defined_transformation() { return IsADBEntity("item_defined_transformation"); }
        item_defined_transformation get_item_defined_transformation();
        bool is_functionally_defined_transformation() { return IsADBEntity("functionally_defined_transformation"); }
        functionally_defined_transformation get_functionally_defined_transformation();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class transformation_put : public Select
    {
    public:
        transformation_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        transformation_put(Select* outer) : Select(outer) {}
        void put_item_defined_transformation(item_defined_transformation inst);
        void put_functionally_defined_transformation(functionally_defined_transformation inst);
    };


    class trimming_select : public Select
    {
    public:
        trimming_select(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        trimming_select(Select* outer) : Select(outer) {}

        bool is_cartesian_point() { return IsADBEntity("cartesian_point"); }
        cartesian_point get_cartesian_point();
        void put_cartesian_point(cartesian_point inst);

        bool is_parameter_value() { return IsADBType("PARAMETER_VALUE"); }
        Nullable<parameter_value> get_parameter_value() { return getSimpleValue<parameter_value>("PARAMETER_VALUE", sdaiREAL); }
        void put_parameter_value(parameter_value value) { putSimpleValue("PARAMETER_VALUE", sdaiREAL, value); }
    };


    class trimming_select_get : public Select
    {
    public:
        trimming_select_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        trimming_select_get(Select* outer) : Select(outer) {}
        bool is_cartesian_point() { return IsADBEntity("cartesian_point"); }
        cartesian_point get_cartesian_point();
        bool is_parameter_value() { return IsADBType("PARAMETER_VALUE"); }
        Nullable<parameter_value> get_parameter_value() { return getSimpleValue<parameter_value>("PARAMETER_VALUE", sdaiREAL); }

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
        Nullable<double> as_double() { double val = 0; if (sdaiGetAttrBN(m_instance, m_attrName, sdaiREAL, &val)) return val; else return Nullable<double>(); }
    };


    class trimming_select_put : public Select
    {
    public:
        trimming_select_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        trimming_select_put(Select* outer) : Select(outer) {}
        void put_cartesian_point(cartesian_point inst);
        void put_parameter_value(parameter_value value) { putSimpleValue("PARAMETER_VALUE", sdaiREAL, value); }
    };


    class unit : public Select
    {
    public:
        unit(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        unit(Select* outer) : Select(outer) {}

        bool is_named_unit() { return IsADBEntity("named_unit"); }
        named_unit get_named_unit();
        void put_named_unit(named_unit inst);

        bool is_derived_unit() { return IsADBEntity("derived_unit"); }
        derived_unit get_derived_unit();
        void put_derived_unit(derived_unit inst);
    };


    class unit_get : public Select
    {
    public:
        unit_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        unit_get(Select* outer) : Select(outer) {}
        bool is_named_unit() { return IsADBEntity("named_unit"); }
        named_unit get_named_unit();
        bool is_derived_unit() { return IsADBEntity("derived_unit"); }
        derived_unit get_derived_unit();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class unit_put : public Select
    {
    public:
        unit_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        unit_put(Select* outer) : Select(outer) {}
        void put_named_unit(named_unit inst);
        void put_derived_unit(derived_unit inst);
    };


    class vector_or_direction : public Select
    {
    public:
        vector_or_direction(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        vector_or_direction(Select* outer) : Select(outer) {}

        bool is_direction() { return IsADBEntity("direction"); }
        direction get_direction();
        void put_direction(direction inst);

        bool is_vector() { return IsADBEntity("vector"); }
        vector get_vector();
        void put_vector(vector inst);
    };


    class vector_or_direction_get : public Select
    {
    public:
        vector_or_direction_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        vector_or_direction_get(Select* outer) : Select(outer) {}
        bool is_direction() { return IsADBEntity("direction"); }
        direction get_direction();
        bool is_vector() { return IsADBEntity("vector"); }
        vector get_vector();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class vector_or_direction_put : public Select
    {
    public:
        vector_or_direction_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        vector_or_direction_put(Select* outer) : Select(outer) {}
        void put_direction(direction inst);
        void put_vector(vector inst);
    };


    class wireframe_model : public Select
    {
    public:
        wireframe_model(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        wireframe_model(Select* outer) : Select(outer) {}

        bool is_shell_based_wireframe_model() { return IsADBEntity("shell_based_wireframe_model"); }
        shell_based_wireframe_model get_shell_based_wireframe_model();
        void put_shell_based_wireframe_model(shell_based_wireframe_model inst);

        bool is_edge_based_wireframe_model() { return IsADBEntity("edge_based_wireframe_model"); }
        edge_based_wireframe_model get_edge_based_wireframe_model();
        void put_edge_based_wireframe_model(edge_based_wireframe_model inst);
    };


    class wireframe_model_get : public Select
    {
    public:
        wireframe_model_get(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        wireframe_model_get(Select* outer) : Select(outer) {}
        bool is_shell_based_wireframe_model() { return IsADBEntity("shell_based_wireframe_model"); }
        shell_based_wireframe_model get_shell_based_wireframe_model();
        bool is_edge_based_wireframe_model() { return IsADBEntity("edge_based_wireframe_model"); }
        edge_based_wireframe_model get_edge_based_wireframe_model();

        SdaiInstance as_instance() { return getEntityInstance(NULL); }
    };


    class wireframe_model_put : public Select
    {
    public:
        wireframe_model_put(SdaiInstance instance, TextValue attrName = NULL, void* adb = NULL) : Select(instance, attrName, adb) {}
        wireframe_model_put(Select* outer) : Select(outer) {}
        void put_shell_based_wireframe_model(shell_based_wireframe_model inst);
        void put_edge_based_wireframe_model(edge_based_wireframe_model inst);
    };


        //
        // Unnamed aggregations
        //
    typedef std::list<versioned_action_request> set_of_versioned_action_request;
    template <typename TList> class set_of_versioned_action_requestSerializer : public AggrSerializerInstance<TList, versioned_action_request> {};
    typedef std::list<document_usage_constraint> set_of_document_usage_constraint;
    template <typename TList> class set_of_document_usage_constraintSerializer : public AggrSerializerInstance<TList, document_usage_constraint> {};
    typedef std::list<element> set_of_element;
    template <typename TList> class set_of_elementSerializer : public AggrSerializerInstance<TList, element> {};
    typedef std::list<node> set_of_node;
    template <typename TList> class set_of_nodeSerializer : public AggrSerializerInstance<TList, node> {};
    typedef std::list<assembly> set_of_assembly;
    template <typename TList> class set_of_assemblySerializer : public AggrSerializerInstance<TList, assembly> {};
    typedef std::list<analysis_result> set_of_analysis_result;
    template <typename TList> class set_of_analysis_resultSerializer : public AggrSerializerInstance<TList, analysis_result> {};
    typedef std::list<analysis_results_set_combined> set_of_analysis_results_set_combined;
    template <typename TList> class set_of_analysis_results_set_combinedSerializer : public AggrSerializerInstance<TList, analysis_results_set_combined> {};
    typedef std::list<ratio_measure_with_unit> list_of_ratio_measure_with_unit;
    template <typename TList> class list_of_ratio_measure_with_unitSerializer : public AggrSerializerInstance<TList, ratio_measure_with_unit> {};
    typedef std::list<assembly_component_select> set_of_assembly_component_select;
    template <typename TList> class set_of_assembly_component_selectSerializer : public AggrSerializerSelect<TList, assembly_component_select> {};
    typedef std::list<structural_frame_process> set_of_structural_frame_process;
    template <typename TList> class set_of_structural_frame_processSerializer : public AggrSerializerInstance<TList, structural_frame_process> {};
    typedef std::list<functional_role> set_of_functional_role;
    template <typename TList> class set_of_functional_roleSerializer : public AggrSerializerInstance<TList, functional_role> {};
    typedef std::list<design_criterion> set_of_design_criterion;
    template <typename TList> class set_of_design_criterionSerializer : public AggrSerializerInstance<TList, design_criterion> {};
    typedef std::list<assembly_design> set_of_assembly_design;
    template <typename TList> class set_of_assembly_designSerializer : public AggrSerializerInstance<TList, assembly_design> {};
    typedef std::list<assembly_design_structural_member> set_of_assembly_design_structural_member;
    template <typename TList> class set_of_assembly_design_structural_memberSerializer : public AggrSerializerInstance<TList, assembly_design_structural_member> {};
    typedef std::list<assembly_design_structural_connection> set_of_assembly_design_structural_connection;
    template <typename TList> class set_of_assembly_design_structural_connectionSerializer : public AggrSerializerInstance<TList, assembly_design_structural_connection> {};
    typedef std::list<member_beam_type> set_of_member_beam_type;
    template <typename TList> class set_of_member_beam_typeSerializer : public AggrSerializerEnum<TList, member_beam_type, member_beam_type_, sdaiENUM> {};
    typedef std::list<member_beam_role> set_of_member_beam_role;
    template <typename TList> class set_of_member_beam_roleSerializer : public AggrSerializerEnum<TList, member_beam_role, member_beam_role_, sdaiENUM> {};
    typedef std::list<member_column_type> set_of_member_column_type;
    template <typename TList> class set_of_member_column_typeSerializer : public AggrSerializerEnum<TList, member_column_type, member_column_type_, sdaiENUM> {};
    typedef std::list<assembly_design_structural_member_linear> set_of_assembly_design_structural_member_linear;
    template <typename TList> class set_of_assembly_design_structural_member_linearSerializer : public AggrSerializerInstance<TList, assembly_design_structural_member_linear> {};
    typedef std::list<cartesian_point> list_of_cartesian_point;
    template <typename TList> class list_of_cartesian_pointSerializer : public AggrSerializerInstance<TList, cartesian_point> {};
    typedef std::list<IntValue> ListOfIntValue;
    template <typename TList> class ListOfIntValueSerializer : public AggrSerializerSimple<TList, IntValue, sdaiINTEGER> {};
    typedef std::list<parameter_value> list_of_parameter_value;
    template <typename TList> class list_of_parameter_valueSerializer : public AggrSerializerSimple<TList, parameter_value, sdaiREAL> {};
    typedef std::list<list_of_cartesian_point> list_of_list_of_cartesian_point;
    template <typename TList> class list_of_list_of_cartesian_pointSerializer : public AggrSerializerAggr<TList, list_of_cartesian_point, list_of_cartesian_pointSerializer<list_of_cartesian_point>> {};
    typedef std::list<list_of_list_of_cartesian_point> list_of_list_of_list_of_cartesian_point;
    template <typename TList> class list_of_list_of_list_of_cartesian_pointSerializer : public AggrSerializerAggr<TList, list_of_list_of_cartesian_point, list_of_list_of_cartesian_pointSerializer<list_of_list_of_cartesian_point>> {};
    typedef std::list<measure_with_unit> list_of_measure_with_unit;
    template <typename TList> class list_of_measure_with_unitSerializer : public AggrSerializerInstance<TList, measure_with_unit> {};
    typedef std::list<boundary_condition_spring_linear> list_of_boundary_condition_spring_linear;
    template <typename TList> class list_of_boundary_condition_spring_linearSerializer : public AggrSerializerInstance<TList, boundary_condition_spring_linear> {};
    typedef std::list<composite_curve_segment> list_of_composite_curve_segment;
    template <typename TList> class list_of_composite_curve_segmentSerializer : public AggrSerializerInstance<TList, composite_curve_segment> {};
    typedef std::list<pcurve_or_surface> list_of_pcurve_or_surface;
    template <typename TList> class list_of_pcurve_or_surfaceSerializer : public AggrSerializerSelect<TList, pcurve_or_surface> {};
    typedef std::list<oriented_closed_shell> set_of_oriented_closed_shell;
    template <typename TList> class set_of_oriented_closed_shellSerializer : public AggrSerializerInstance<TList, oriented_closed_shell> {};
    typedef std::list<structure> list_of_structure;
    template <typename TList> class list_of_structureSerializer : public AggrSerializerInstance<TList, structure> {};
    typedef std::list<building> list_of_building;
    template <typename TList> class list_of_buildingSerializer : public AggrSerializerInstance<TList, building> {};
    typedef std::list<length_measure> list_of_length_measure;
    template <typename TList> class list_of_length_measureSerializer : public AggrSerializerSimple<TList, length_measure, sdaiREAL> {};
    typedef std::list<face> set_of_face;
    template <typename TList> class set_of_faceSerializer : public AggrSerializerInstance<TList, face> {};
    typedef std::list<composite_curve> bag_of_composite_curve;
    template <typename TList> class bag_of_composite_curveSerializer : public AggrSerializerInstance<TList, composite_curve> {};
    typedef std::list<edge> set_of_edge;
    template <typename TList> class set_of_edgeSerializer : public AggrSerializerInstance<TList, edge> {};
    typedef std::list<direction> list_of_direction;
    template <typename TList> class list_of_directionSerializer : public AggrSerializerInstance<TList, direction> {};
    typedef std::list<boundary_curve> set_of_boundary_curve;
    template <typename TList> class set_of_boundary_curveSerializer : public AggrSerializerInstance<TList, boundary_curve> {};
    typedef std::list<representation_item> set_of_representation_item;
    template <typename TList> class set_of_representation_itemSerializer : public AggrSerializerInstance<TList, representation_item> {};
    typedef std::list<derived_unit_element> set_of_derived_unit_element;
    template <typename TList> class set_of_derived_unit_elementSerializer : public AggrSerializerInstance<TList, derived_unit_element> {};
    typedef std::list<assembly_design> list_of_assembly_design;
    template <typename TList> class list_of_assembly_designSerializer : public AggrSerializerInstance<TList, assembly_design> {};
    typedef std::list<coord_system> list_of_coord_system;
    template <typename TList> class list_of_coord_systemSerializer : public AggrSerializerInstance<TList, coord_system> {};
    typedef std::list<design_part> set_of_design_part;
    template <typename TList> class set_of_design_partSerializer : public AggrSerializerInstance<TList, design_part> {};
    typedef std::list<double> list_of_double;
    template <typename TList> class list_of_doubleSerializer : public AggrSerializerSimple<TList, double, sdaiREAL> {};
    typedef std::list<product_item_select> list_of_product_item_select;
    template <typename TList> class list_of_product_item_selectSerializer : public AggrSerializerSelect<TList, product_item_select> {};
    typedef std::list<document_representation_type> set_of_document_representation_type;
    template <typename TList> class set_of_document_representation_typeSerializer : public AggrSerializerInstance<TList, document_representation_type> {};
    typedef std::list<connected_edge_set> set_of_connected_edge_set;
    template <typename TList> class set_of_connected_edge_setSerializer : public AggrSerializerInstance<TList, connected_edge_set> {};
    typedef std::list<oriented_edge> list_of_oriented_edge;
    template <typename TList> class list_of_oriented_edgeSerializer : public AggrSerializerInstance<TList, oriented_edge> {};
    typedef std::list<element_node_connectivity> set_of_element_node_connectivity;
    template <typename TList> class set_of_element_node_connectivitySerializer : public AggrSerializerInstance<TList, element_node_connectivity> {};
    typedef std::list<section_profile> list_of_section_profile;
    template <typename TList> class list_of_section_profileSerializer : public AggrSerializerInstance<TList, section_profile> {};
    typedef std::list<point_on_curve> list_of_point_on_curve;
    template <typename TList> class list_of_point_on_curveSerializer : public AggrSerializerInstance<TList, point_on_curve> {};
    typedef std::list<orientation_select> list_of_orientation_select;
    template <typename TList> class list_of_orientation_selectSerializer : public AggrSerializerSelect<TList, orientation_select> {};
    typedef std::list<double> array_of_double;
    template <typename TList> class array_of_doubleSerializer : public AggrSerializerSimple<TList, double, sdaiREAL> {};
    typedef std::list<array_of_double> array_of_array_of_double;
    template <typename TList> class array_of_array_of_doubleSerializer : public AggrSerializerAggr<TList, array_of_double, array_of_doubleSerializer<array_of_double>> {};
    typedef std::list<face_bound> set_of_face_bound;
    template <typename TList> class set_of_face_boundSerializer : public AggrSerializerInstance<TList, face_bound> {};
    typedef std::list<connected_face_set> set_of_connected_face_set;
    template <typename TList> class set_of_connected_face_setSerializer : public AggrSerializerInstance<TList, connected_face_set> {};
    typedef std::list<fastener> list_of_fastener;
    template <typename TList> class list_of_fastenerSerializer : public AggrSerializerInstance<TList, fastener> {};
    typedef std::list<length_measure_with_unit> list_of_length_measure_with_unit;
    template <typename TList> class list_of_length_measure_with_unitSerializer : public AggrSerializerInstance<TList, length_measure_with_unit> {};
    typedef std::list<StringValue> list_of_text;
    template <typename TList> class list_of_textSerializer : public AggrSerializerText<list_of_text, text, sdaiSTRING> {};
    typedef std::list<point> list_of_point;
    template <typename TList> class list_of_pointSerializer : public AggrSerializerInstance<TList, point> {};
    typedef std::list<point> set_of_point;
    template <typename TList> class set_of_pointSerializer : public AggrSerializerInstance<TList, point> {};
    typedef std::list<item_reference> set_of_item_reference;
    template <typename TList> class set_of_item_referenceSerializer : public AggrSerializerInstance<TList, item_reference> {};
    typedef std::list<geometric_set_select> set_of_geometric_set_select;
    template <typename TList> class set_of_geometric_set_selectSerializer : public AggrSerializerSelect<TList, geometric_set_select> {};
    typedef std::list<representation> set_of_representation;
    template <typename TList> class set_of_representationSerializer : public AggrSerializerInstance<TList, representation> {};
    typedef std::list<uncertainty_measure_with_unit> set_of_uncertainty_measure_with_unit;
    template <typename TList> class set_of_uncertainty_measure_with_unitSerializer : public AggrSerializerInstance<TList, uncertainty_measure_with_unit> {};
    typedef std::list<unit> set_of_unit;
    template <typename TList> class set_of_unitSerializer : public AggrSerializerSelect<TList, unit> {};
    typedef std::list<gridline> set_of_gridline;
    template <typename TList> class set_of_gridlineSerializer : public AggrSerializerInstance<TList, gridline> {};
    typedef std::list<positive_length_measure_with_unit> list_of_positive_length_measure_with_unit;
    template <typename TList> class list_of_positive_length_measure_with_unitSerializer : public AggrSerializerInstance<TList, positive_length_measure_with_unit> {};
    typedef std::list<plane_angle_measure_with_unit> list_of_plane_angle_measure_with_unit;
    template <typename TList> class list_of_plane_angle_measure_with_unitSerializer : public AggrSerializerInstance<TList, plane_angle_measure_with_unit> {};
    typedef std::list<select_analysis_item> set_of_select_analysis_item;
    template <typename TList> class set_of_select_analysis_itemSerializer : public AggrSerializerSelect<TList, select_analysis_item> {};
    typedef std::list<select_design_item> set_of_select_design_item;
    template <typename TList> class set_of_select_design_itemSerializer : public AggrSerializerSelect<TList, select_design_item> {};
    typedef std::list<select_generic_item> set_of_select_generic_item;
    template <typename TList> class set_of_select_generic_itemSerializer : public AggrSerializerSelect<TList, select_generic_item> {};
    typedef std::list<select_physical_item> set_of_select_physical_item;
    template <typename TList> class set_of_select_physical_itemSerializer : public AggrSerializerSelect<TList, select_physical_item> {};
    typedef std::list<select_project_definition_item> set_of_select_project_definition_item;
    template <typename TList> class set_of_select_project_definition_itemSerializer : public AggrSerializerSelect<TList, select_project_definition_item> {};
    typedef std::list<select_structural_item> set_of_select_structural_item;
    template <typename TList> class set_of_select_structural_itemSerializer : public AggrSerializerSelect<TList, select_structural_item> {};
    typedef std::list<item_reference_library> set_of_item_reference_library;
    template <typename TList> class set_of_item_reference_librarySerializer : public AggrSerializerInstance<TList, item_reference_library> {};
    typedef std::list<item_reference_proprietary> set_of_item_reference_proprietary;
    template <typename TList> class set_of_item_reference_proprietarySerializer : public AggrSerializerInstance<TList, item_reference_proprietary> {};
    typedef std::list<item_reference_standard> set_of_item_reference_standard;
    template <typename TList> class set_of_item_reference_standardSerializer : public AggrSerializerInstance<TList, item_reference_standard> {};
    typedef std::list<chemical_mechanism> list_of_chemical_mechanism;
    template <typename TList> class list_of_chemical_mechanismSerializer : public AggrSerializerInstance<TList, chemical_mechanism> {};
    typedef std::list<joint_system> list_of_joint_system;
    template <typename TList> class list_of_joint_systemSerializer : public AggrSerializerInstance<TList, joint_system> {};
    typedef std::list<analysis_method> set_of_analysis_method;
    template <typename TList> class set_of_analysis_methodSerializer : public AggrSerializerInstance<TList, analysis_method> {};
    typedef std::list<load> set_of_load;
    template <typename TList> class set_of_loadSerializer : public AggrSerializerInstance<TList, load> {};
    typedef std::list<applied_load_static_pressure> set_of_applied_load_static_pressure;
    template <typename TList> class set_of_applied_load_static_pressureSerializer : public AggrSerializerInstance<TList, applied_load_static_pressure> {};
    typedef std::list<load_combination_occurrence> set_of_load_combination_occurrence;
    template <typename TList> class set_of_load_combination_occurrenceSerializer : public AggrSerializerInstance<TList, load_combination_occurrence> {};
    typedef std::list<grid_offset> set_of_grid_offset;
    template <typename TList> class set_of_grid_offsetSerializer : public AggrSerializerInstance<TList, grid_offset> {};
    typedef std::list<located_part> set_of_located_part;
    template <typename TList> class set_of_located_partSerializer : public AggrSerializerInstance<TList, located_part> {};
    typedef std::list<located_joint_system> set_of_located_joint_system;
    template <typename TList> class set_of_located_joint_systemSerializer : public AggrSerializerInstance<TList, located_joint_system> {};
    typedef std::list<managed_data_item> set_of_managed_data_item;
    template <typename TList> class set_of_managed_data_itemSerializer : public AggrSerializerInstance<TList, managed_data_item> {};
    typedef std::list<managed_data_transaction> set_of_managed_data_transaction;
    template <typename TList> class set_of_managed_data_transactionSerializer : public AggrSerializerInstance<TList, managed_data_transaction> {};
    typedef std::list<managed_data_transaction> list_of_managed_data_transaction;
    template <typename TList> class list_of_managed_data_transactionSerializer : public AggrSerializerInstance<TList, managed_data_transaction> {};
    typedef std::list<material_representation> list_of_material_representation;
    template <typename TList> class list_of_material_representationSerializer : public AggrSerializerInstance<TList, material_representation> {};
    typedef std::list<placement> list_of_placement;
    template <typename TList> class list_of_placementSerializer : public AggrSerializerInstance<TList, placement> {};
    typedef std::list<value_qualifier> set_of_value_qualifier;
    template <typename TList> class set_of_value_qualifierSerializer : public AggrSerializerSelect<TList, value_qualifier> {};
    typedef std::list<person_and_organization> list_of_person_and_organization;
    template <typename TList> class list_of_person_and_organizationSerializer : public AggrSerializerInstance<TList, person_and_organization> {};
    typedef std::list<organization> set_of_organization;
    template <typename TList> class set_of_organizationSerializer : public AggrSerializerInstance<TList, organization> {};
    typedef std::list<StringValue> list_of_label;
    template <typename TList> class list_of_labelSerializer : public AggrSerializerText<list_of_label, label, sdaiSTRING> {};
    typedef std::list<person> set_of_person;
    template <typename TList> class set_of_personSerializer : public AggrSerializerInstance<TList, person> {};
    typedef std::list<calendar_date> list_of_calendar_date;
    template <typename TList> class list_of_calendar_dateSerializer : public AggrSerializerInstance<TList, calendar_date> {};
    typedef std::list<structural_frame_item_priced> set_of_structural_frame_item_priced;
    template <typename TList> class set_of_structural_frame_item_pricedSerializer : public AggrSerializerInstance<TList, structural_frame_item_priced> {};
    typedef std::list<project_plan_item> set_of_project_plan_item;
    template <typename TList> class set_of_project_plan_itemSerializer : public AggrSerializerInstance<TList, project_plan_item> {};
    typedef std::list<project_organization> set_of_project_organization;
    template <typename TList> class set_of_project_organizationSerializer : public AggrSerializerInstance<TList, project_organization> {};
    typedef std::list<product_item_select> set_of_product_item_select;
    template <typename TList> class set_of_product_item_selectSerializer : public AggrSerializerSelect<TList, product_item_select> {};
    typedef std::list<list_of_double> list_of_list_of_double;
    template <typename TList> class list_of_list_of_doubleSerializer : public AggrSerializerAggr<TList, list_of_double, list_of_doubleSerializer<list_of_double>> {};
    typedef std::list<list_of_list_of_double> list_of_list_of_list_of_double;
    template <typename TList> class list_of_list_of_list_of_doubleSerializer : public AggrSerializerAggr<TList, list_of_list_of_double, list_of_list_of_doubleSerializer<list_of_list_of_double>> {};
    typedef std::list<surface_patch> list_of_surface_patch;
    template <typename TList> class list_of_surface_patchSerializer : public AggrSerializerInstance<TList, surface_patch> {};
    typedef std::list<list_of_surface_patch> list_of_list_of_surface_patch;
    template <typename TList> class list_of_list_of_surface_patchSerializer : public AggrSerializerAggr<TList, list_of_surface_patch, list_of_surface_patchSerializer<list_of_surface_patch>> {};
    typedef std::list<release_spring_linear> list_of_release_spring_linear;
    template <typename TList> class list_of_release_spring_linearSerializer : public AggrSerializerInstance<TList, release_spring_linear> {};
    typedef std::list<mapped_item> set_of_mapped_item;
    template <typename TList> class set_of_mapped_itemSerializer : public AggrSerializerInstance<TList, mapped_item> {};
    typedef std::list<design_result> set_of_design_result;
    template <typename TList> class set_of_design_resultSerializer : public AggrSerializerInstance<TList, design_result> {};
    typedef std::list<bounded_curve> list_of_bounded_curve;
    template <typename TList> class list_of_bounded_curveSerializer : public AggrSerializerInstance<TList, bounded_curve> {};
    typedef std::list<length_measure_with_unit> array_of_length_measure_with_unit;
    template <typename TList> class array_of_length_measure_with_unitSerializer : public AggrSerializerInstance<TList, length_measure_with_unit> {};
    typedef std::list<modulus_measure_with_unit> array_of_modulus_measure_with_unit;
    template <typename TList> class array_of_modulus_measure_with_unitSerializer : public AggrSerializerInstance<TList, modulus_measure_with_unit> {};
    typedef std::list<shell> set_of_shell;
    template <typename TList> class set_of_shellSerializer : public AggrSerializerSelect<TList, shell> {};
    typedef std::list<group_assignment> set_of_group_assignment;
    template <typename TList> class set_of_group_assignmentSerializer : public AggrSerializerInstance<TList, group_assignment> {};
    typedef std::list<rectangular_composite_surface> bag_of_rectangular_composite_surface;
    template <typename TList> class bag_of_rectangular_composite_surfaceSerializer : public AggrSerializerInstance<TList, rectangular_composite_surface> {};
    typedef std::list<coating_method> list_of_coating_method;
    template <typename TList> class list_of_coating_methodSerializer : public AggrSerializerEnum<TList, coating_method, coating_method_, sdaiENUM> {};
    typedef std::list<coating> list_of_coating;
    template <typename TList> class list_of_coatingSerializer : public AggrSerializerInstance<TList, coating> {};
    typedef std::list<trimming_select> set_of_trimming_select;
    template <typename TList> class set_of_trimming_selectSerializer : public AggrSerializerSelect<TList, trimming_select> {};
    typedef std::list<loop> set_of_loop;
    template <typename TList> class set_of_loopSerializer : public AggrSerializerInstance<TList, loop> {};
    typedef std::list<grid_level> set_of_grid_level;
    template <typename TList> class set_of_grid_levelSerializer : public AggrSerializerInstance<TList, grid_level> {};

        //
        // Entities
        // 


        /// <summary>
        /// Provides utility methods to interact with an instnace of action
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class action : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of action
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        action(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "action")
        {}

                /// <summary>
                /// Create new instace of action and returns object of this C++ class to interact with
                /// </summary>
        static action Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "action"); assert(inst); return inst; }

        label get_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_name(label value) { sdaiPutAttrBN(m_instance, "name", sdaiSTRING, value); }

        text get_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_description(text value) { sdaiPutAttrBN(m_instance, "description", sdaiSTRING, value); }

        action_method get_chosen_method();
        void put_chosen_method(action_method inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of action_directive
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class action_directive : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of action_directive
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        action_directive(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "action_directive")
        {}

                /// <summary>
                /// Create new instace of action_directive and returns object of this C++ class to interact with
                /// </summary>
        static action_directive Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "action_directive"); assert(inst); return inst; }

        label get_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_name(label value) { sdaiPutAttrBN(m_instance, "name", sdaiSTRING, value); }

        text get_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_description(text value) { sdaiPutAttrBN(m_instance, "description", sdaiSTRING, value); }

        text get_analysis() { text val = NULL; if (sdaiGetAttrBN(m_instance, "analysis", sdaiSTRING, &val)) return val; else return NULL; }
        void put_analysis(text value) { sdaiPutAttrBN(m_instance, "analysis", sdaiSTRING, value); }

        text get_comment() { text val = NULL; if (sdaiGetAttrBN(m_instance, "comment", sdaiSTRING, &val)) return val; else return NULL; }
        void put_comment(text value) { sdaiPutAttrBN(m_instance, "comment", sdaiSTRING, value); }

        //TList may be set_of_versioned_action_request or list of converible elements
        template <typename TList> void get_requests(TList& lst) { set_of_versioned_action_requestSerializer<TList> sr; sr.FromAttr(lst, m_instance, "requests"); }

        //TList may be set_of_versioned_action_request or list of converible elements
        template <typename TList> void put_requests(TList& lst) { set_of_versioned_action_requestSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "requests"); }

        //TArrayElem[] may be versioned_action_request[] or array of convertible elements
        template <typename TArrayElem> void put_requests(TArrayElem arr[], size_t n) { set_of_versioned_action_request lst; ArrayToList(arr, n, lst); put_requests(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of action_method
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class action_method : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of action_method
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        action_method(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "action_method")
        {}

                /// <summary>
                /// Create new instace of action_method and returns object of this C++ class to interact with
                /// </summary>
        static action_method Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "action_method"); assert(inst); return inst; }

        label get_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_name(label value) { sdaiPutAttrBN(m_instance, "name", sdaiSTRING, value); }

        text get_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_description(text value) { sdaiPutAttrBN(m_instance, "description", sdaiSTRING, value); }

        text get_consequence() { text val = NULL; if (sdaiGetAttrBN(m_instance, "consequence", sdaiSTRING, &val)) return val; else return NULL; }
        void put_consequence(text value) { sdaiPutAttrBN(m_instance, "consequence", sdaiSTRING, value); }

        text get_purpose() { text val = NULL; if (sdaiGetAttrBN(m_instance, "purpose", sdaiSTRING, &val)) return val; else return NULL; }
        void put_purpose(text value) { sdaiPutAttrBN(m_instance, "purpose", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of address
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class address : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of address
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        address(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "address")
        {}

                /// <summary>
                /// Create new instace of address and returns object of this C++ class to interact with
                /// </summary>
        static address Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "address"); assert(inst); return inst; }

        label get_internal_location() { label val = NULL; if (sdaiGetAttrBN(m_instance, "internal_location", sdaiSTRING, &val)) return val; else return NULL; }
        void put_internal_location(label value) { sdaiPutAttrBN(m_instance, "internal_location", sdaiSTRING, value); }

        label get_street_number() { label val = NULL; if (sdaiGetAttrBN(m_instance, "street_number", sdaiSTRING, &val)) return val; else return NULL; }
        void put_street_number(label value) { sdaiPutAttrBN(m_instance, "street_number", sdaiSTRING, value); }

        label get_street() { label val = NULL; if (sdaiGetAttrBN(m_instance, "street", sdaiSTRING, &val)) return val; else return NULL; }
        void put_street(label value) { sdaiPutAttrBN(m_instance, "street", sdaiSTRING, value); }

        label get_postal_box() { label val = NULL; if (sdaiGetAttrBN(m_instance, "postal_box", sdaiSTRING, &val)) return val; else return NULL; }
        void put_postal_box(label value) { sdaiPutAttrBN(m_instance, "postal_box", sdaiSTRING, value); }

        label get_town() { label val = NULL; if (sdaiGetAttrBN(m_instance, "town", sdaiSTRING, &val)) return val; else return NULL; }
        void put_town(label value) { sdaiPutAttrBN(m_instance, "town", sdaiSTRING, value); }

        label get_region() { label val = NULL; if (sdaiGetAttrBN(m_instance, "region", sdaiSTRING, &val)) return val; else return NULL; }
        void put_region(label value) { sdaiPutAttrBN(m_instance, "region", sdaiSTRING, value); }

        label get_postal_code() { label val = NULL; if (sdaiGetAttrBN(m_instance, "postal_code", sdaiSTRING, &val)) return val; else return NULL; }
        void put_postal_code(label value) { sdaiPutAttrBN(m_instance, "postal_code", sdaiSTRING, value); }

        label get_country() { label val = NULL; if (sdaiGetAttrBN(m_instance, "country", sdaiSTRING, &val)) return val; else return NULL; }
        void put_country(label value) { sdaiPutAttrBN(m_instance, "country", sdaiSTRING, value); }

        label get_facsimile_number() { label val = NULL; if (sdaiGetAttrBN(m_instance, "facsimile_number", sdaiSTRING, &val)) return val; else return NULL; }
        void put_facsimile_number(label value) { sdaiPutAttrBN(m_instance, "facsimile_number", sdaiSTRING, value); }

        label get_telephone_number() { label val = NULL; if (sdaiGetAttrBN(m_instance, "telephone_number", sdaiSTRING, &val)) return val; else return NULL; }
        void put_telephone_number(label value) { sdaiPutAttrBN(m_instance, "telephone_number", sdaiSTRING, value); }

        label get_electronic_mail_address() { label val = NULL; if (sdaiGetAttrBN(m_instance, "electronic_mail_address", sdaiSTRING, &val)) return val; else return NULL; }
        void put_electronic_mail_address(label value) { sdaiPutAttrBN(m_instance, "electronic_mail_address", sdaiSTRING, value); }

        label get_telex_number() { label val = NULL; if (sdaiGetAttrBN(m_instance, "telex_number", sdaiSTRING, &val)) return val; else return NULL; }
        void put_telex_number(label value) { sdaiPutAttrBN(m_instance, "telex_number", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_method
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_method : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_method
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_method(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_method")
        {}

                /// <summary>
                /// Create new instace of analysis_method and returns object of this C++ class to interact with
                /// </summary>
        static analysis_method Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "analysis_method"); assert(inst); return inst; }

        label get_analysis_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "analysis_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_analysis_name(label value) { sdaiPutAttrBN(m_instance, "analysis_name", sdaiSTRING, value); }

        text get_analysis_assumptions() { text val = NULL; if (sdaiGetAttrBN(m_instance, "analysis_assumptions", sdaiSTRING, &val)) return val; else return NULL; }
        void put_analysis_assumptions(text value) { sdaiPutAttrBN(m_instance, "analysis_assumptions", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_method_documented
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_method_documented : public virtual analysis_method
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_method_documented
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_method_documented(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_method_documented")
        {}

                /// <summary>
                /// Create new instace of analysis_method_documented and returns object of this C++ class to interact with
                /// </summary>
        static analysis_method_documented Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "analysis_method_documented"); assert(inst); return inst; }

        //TList may be set_of_document_usage_constraint or list of converible elements
        template <typename TList> void get_documented_constraints(TList& lst) { set_of_document_usage_constraintSerializer<TList> sr; sr.FromAttr(lst, m_instance, "documented_constraints"); }

        //TList may be set_of_document_usage_constraint or list of converible elements
        template <typename TList> void put_documented_constraints(TList& lst) { set_of_document_usage_constraintSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "documented_constraints"); }

        //TArrayElem[] may be document_usage_constraint[] or array of convertible elements
        template <typename TArrayElem> void put_documented_constraints(TArrayElem arr[], size_t n) { set_of_document_usage_constraint lst; ArrayToList(arr, n, lst); put_documented_constraints(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_method_dynamic
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_method_dynamic : public virtual analysis_method
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_method_dynamic
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_method_dynamic(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_method_dynamic")
        {}

                /// <summary>
                /// Create new instace of analysis_method_dynamic and returns object of this C++ class to interact with
                /// </summary>
        static analysis_method_dynamic Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "analysis_method_dynamic"); assert(inst); return inst; }

        Nullable<dynamic_analysis_type> get_analysis_type() { int v = getENUM("analysis_type", dynamic_analysis_type_); if (v >= 0) return (dynamic_analysis_type) v; else return Nullable<dynamic_analysis_type>(); }
        void put_analysis_type(dynamic_analysis_type value) { TextValue val = dynamic_analysis_type_[(int) value]; sdaiPutAttrBN(m_instance, "analysis_type", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_method_pseudo_dynamic
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_method_pseudo_dynamic : public virtual analysis_method
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_method_pseudo_dynamic
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_method_pseudo_dynamic(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_method_pseudo_dynamic")
        {}

                /// <summary>
                /// Create new instace of analysis_method_pseudo_dynamic and returns object of this C++ class to interact with
                /// </summary>
        static analysis_method_pseudo_dynamic Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "analysis_method_pseudo_dynamic"); assert(inst); return inst; }

        label get_analysis_type() { label val = NULL; if (sdaiGetAttrBN(m_instance, "analysis_type", sdaiSTRING, &val)) return val; else return NULL; }
        void put_analysis_type(label value) { sdaiPutAttrBN(m_instance, "analysis_type", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_method_static
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_method_static : public virtual analysis_method
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_method_static
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_method_static(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_method_static")
        {}

                /// <summary>
                /// Create new instace of analysis_method_static and returns object of this C++ class to interact with
                /// </summary>
        static analysis_method_static Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "analysis_method_static"); assert(inst); return inst; }

        Nullable<static_analysis_type> get_analysis_type() { int v = getENUM("analysis_type", static_analysis_type_); if (v >= 0) return (static_analysis_type) v; else return Nullable<static_analysis_type>(); }
        void put_analysis_type(static_analysis_type value) { TextValue val = static_analysis_type_[(int) value]; sdaiPutAttrBN(m_instance, "analysis_type", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_model
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_model : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_model
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_model(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_model")
        {}

                /// <summary>
                /// Create new instace of analysis_model and returns object of this C++ class to interact with
                /// </summary>
        static analysis_model Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "analysis_model"); assert(inst); return inst; }

        label get_model_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "model_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_model_name(label value) { sdaiPutAttrBN(m_instance, "model_name", sdaiSTRING, value); }

        text get_model_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "model_description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_model_description(text value) { sdaiPutAttrBN(m_instance, "model_description", sdaiSTRING, value); }

        Nullable<frame_type> get_model_type() { int v = getENUM("model_type", frame_type_); if (v >= 0) return (frame_type) v; else return Nullable<frame_type>(); }
        void put_model_type(frame_type value) { TextValue val = frame_type_[(int) value]; sdaiPutAttrBN(m_instance, "model_type", sdaiENUM, val); }

        analysis_method get_method_of_analysis();
        void put_method_of_analysis(analysis_method inst);

        Nullable<dimension_count> get_coordinate_space_dimension() { dimension_count val = (dimension_count) 0; if (sdaiGetAttrBN(m_instance, "coordinate_space_dimension", sdaiINTEGER, &val)) return val; else return Nullable<dimension_count>(); }
        void put_coordinate_space_dimension(dimension_count value) { sdaiPutAttrBN(m_instance, "coordinate_space_dimension", sdaiINTEGER, &value); }

        //TList may be set_of_element or list of converible elements
        template <typename TList> void get_component_elements(TList& lst) { set_of_elementSerializer<TList> sr; sr.FromAttr(lst, m_instance, "component_elements"); }

        //TList may be set_of_node or list of converible elements
        template <typename TList> void get_component_nodes(TList& lst) { set_of_nodeSerializer<TList> sr; sr.FromAttr(lst, m_instance, "component_nodes"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_model_2D
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_model_2D : public virtual analysis_model
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_model_2D
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_model_2D(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_model_2D")
        {}

                /// <summary>
                /// Create new instace of analysis_model_2D and returns object of this C++ class to interact with
                /// </summary>
        static analysis_model_2D Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "analysis_model_2D"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_model_3D
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_model_3D : public virtual analysis_model
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_model_3D
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_model_3D(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_model_3D")
        {}

                /// <summary>
                /// Create new instace of analysis_model_3D and returns object of this C++ class to interact with
                /// </summary>
        static analysis_model_3D Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "analysis_model_3D"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_model_child
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_model_child : public virtual analysis_model
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_model_child
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_model_child(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_model_child")
        {}

                /// <summary>
                /// Create new instace of analysis_model_child and returns object of this C++ class to interact with
                /// </summary>
        static analysis_model_child Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "analysis_model_child"); assert(inst); return inst; }

        analysis_model get_parent_model();
        void put_parent_model(analysis_model inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_model_located
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_model_located : public virtual analysis_model
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_model_located
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_model_located(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_model_located")
        {}

                /// <summary>
                /// Create new instace of analysis_model_located and returns object of this C++ class to interact with
                /// </summary>
        static analysis_model_located Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "analysis_model_located"); assert(inst); return inst; }

        coord_system get_model_coord_sys();
        void put_model_coord_sys(coord_system inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_model_mapping
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_model_mapping : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_model_mapping
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_model_mapping(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_model_mapping")
        {}

                /// <summary>
                /// Create new instace of analysis_model_mapping and returns object of this C++ class to interact with
                /// </summary>
        static analysis_model_mapping Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "analysis_model_mapping"); assert(inst); return inst; }

        analysis_model get_mapped_analysis_model();
        void put_mapped_analysis_model(analysis_model inst);

        //TList may be set_of_assembly or list of converible elements
        template <typename TList> void get_represented_assemblies(TList& lst) { set_of_assemblySerializer<TList> sr; sr.FromAttr(lst, m_instance, "represented_assemblies"); }

        //TList may be set_of_assembly or list of converible elements
        template <typename TList> void put_represented_assemblies(TList& lst) { set_of_assemblySerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "represented_assemblies"); }

        //TArrayElem[] may be assembly[] or array of convertible elements
        template <typename TArrayElem> void put_represented_assemblies(TArrayElem arr[], size_t n) { set_of_assembly lst; ArrayToList(arr, n, lst); put_represented_assemblies(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_model_relationship
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_model_relationship : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_model_relationship
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_model_relationship(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_model_relationship")
        {}

                /// <summary>
                /// Create new instace of analysis_model_relationship and returns object of this C++ class to interact with
                /// </summary>
        static analysis_model_relationship Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "analysis_model_relationship"); assert(inst); return inst; }

        label get_relationship_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "relationship_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_relationship_name(label value) { sdaiPutAttrBN(m_instance, "relationship_name", sdaiSTRING, value); }

        text get_relationship_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "relationship_description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_relationship_description(text value) { sdaiPutAttrBN(m_instance, "relationship_description", sdaiSTRING, value); }

        analysis_model get_relating_model();
        void put_relating_model(analysis_model inst);

        analysis_model get_related_model();
        void put_related_model(analysis_model inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_result
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_result : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_result
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_result(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_result")
        {}


        label get_analysis_result_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "analysis_result_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_analysis_result_name(label value) { sdaiPutAttrBN(m_instance, "analysis_result_name", sdaiSTRING, value); }

        text get_sign_convention() { text val = NULL; if (sdaiGetAttrBN(m_instance, "sign_convention", sdaiSTRING, &val)) return val; else return NULL; }
        void put_sign_convention(text value) { sdaiPutAttrBN(m_instance, "sign_convention", sdaiSTRING, value); }

        analysis_method get_results_for_analysis();
        void put_results_for_analysis(analysis_method inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_result_element
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_result_element : public virtual analysis_result
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_result_element
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_result_element(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_result_element")
        {}

    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_result_element_curve
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_result_element_curve : public virtual analysis_result_element
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_result_element_curve
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_result_element_curve(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_result_element_curve")
        {}

                /// <summary>
                /// Create new instace of analysis_result_element_curve and returns object of this C++ class to interact with
                /// </summary>
        static analysis_result_element_curve Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "analysis_result_element_curve"); assert(inst); return inst; }

        element_curve get_result_for_element_curve();
        void put_result_for_element_curve(element_curve inst);

        Nullable<bool> get_x_increasing() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "x_increasing", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_x_increasing(bool value) { sdaiPutAttrBN(m_instance, "x_increasing", sdaiBOOLEAN, &value); }

        reaction get_result_values();
        void put_result_values(reaction inst);

        length_measure_with_unit get_result_position();
        void put_result_position(length_measure_with_unit inst);

        label get_position_label() { label val = NULL; if (sdaiGetAttrBN(m_instance, "position_label", sdaiSTRING, &val)) return val; else return NULL; }
        void put_position_label(label value) { sdaiPutAttrBN(m_instance, "position_label", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_result_element_node
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_result_element_node : public virtual analysis_result
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_result_element_node
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_result_element_node(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_result_element_node")
        {}

                /// <summary>
                /// Create new instace of analysis_result_element_node and returns object of this C++ class to interact with
                /// </summary>
        static analysis_result_element_node Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "analysis_result_element_node"); assert(inst); return inst; }

        element_node_connectivity get_result_for_element_node();
        void put_result_for_element_node(element_node_connectivity inst);

        reaction get_result_values();
        void put_result_values(reaction inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_result_element_point
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_result_element_point : public virtual analysis_result_element
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_result_element_point
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_result_element_point(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_result_element_point")
        {}

                /// <summary>
                /// Create new instace of analysis_result_element_point and returns object of this C++ class to interact with
                /// </summary>
        static analysis_result_element_point Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "analysis_result_element_point"); assert(inst); return inst; }

        element_point get_result_for_element_point();
        void put_result_for_element_point(element_point inst);

        reaction get_result_values();
        void put_result_values(reaction inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_result_element_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_result_element_surface : public virtual analysis_result_element
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_result_element_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_result_element_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_result_element_surface")
        {}


        element_surface get_result_for_element_surface();
        void put_result_for_element_surface(element_surface inst);

        point get_result_position();
        void put_result_position(point inst);

        label get_position_label() { label val = NULL; if (sdaiGetAttrBN(m_instance, "position_label", sdaiSTRING, &val)) return val; else return NULL; }
        void put_position_label(label value) { sdaiPutAttrBN(m_instance, "position_label", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_result_element_surface_stresses
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_result_element_surface_stresses : public virtual analysis_result_element_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_result_element_surface_stresses
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_result_element_surface_stresses(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_result_element_surface_stresses")
        {}

                /// <summary>
                /// Create new instace of analysis_result_element_surface_stresses and returns object of this C++ class to interact with
                /// </summary>
        static analysis_result_element_surface_stresses Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "analysis_result_element_surface_stresses"); assert(inst); return inst; }

        pressure_measure_with_unit get_direct_stress_sigma_y();
        void put_direct_stress_sigma_y(pressure_measure_with_unit inst);

        pressure_measure_with_unit get_membrane_stress_tau_yz();
        void put_membrane_stress_tau_yz(pressure_measure_with_unit inst);

        pressure_measure_with_unit get_direct_stress_sigma_z();
        void put_direct_stress_sigma_z(pressure_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_result_element_surface_tractions
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_result_element_surface_tractions : public virtual analysis_result_element_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_result_element_surface_tractions
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_result_element_surface_tractions(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_result_element_surface_tractions")
        {}

                /// <summary>
                /// Create new instace of analysis_result_element_surface_tractions and returns object of this C++ class to interact with
                /// </summary>
        static analysis_result_element_surface_tractions Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "analysis_result_element_surface_tractions"); assert(inst); return inst; }

        force_per_length_measure_with_unit get_thrust_tz();
        void put_thrust_tz(force_per_length_measure_with_unit inst);

        force_measure_with_unit get_bending_traction_my();
        void put_bending_traction_my(force_measure_with_unit inst);

        force_per_length_measure_with_unit get_thrust_ty();
        void put_thrust_ty(force_per_length_measure_with_unit inst);

        force_measure_with_unit get_torsional_traction_mzy();
        void put_torsional_traction_mzy(force_measure_with_unit inst);

        force_measure_with_unit get_torsional_traction_myz();
        void put_torsional_traction_myz(force_measure_with_unit inst);

        force_per_length_measure_with_unit get_shear_traction_qz();
        void put_shear_traction_qz(force_per_length_measure_with_unit inst);

        force_per_length_measure_with_unit get_shear_traction_qy();
        void put_shear_traction_qy(force_per_length_measure_with_unit inst);

        force_measure_with_unit get_bending_traction_mz();
        void put_bending_traction_mz(force_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_result_element_volume
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_result_element_volume : public virtual analysis_result_element
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_result_element_volume
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_result_element_volume(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_result_element_volume")
        {}


        element_volume get_result_for_element_volume();
        void put_result_for_element_volume(element_volume inst);

        point get_result_position();
        void put_result_position(point inst);

        label get_position_label() { label val = NULL; if (sdaiGetAttrBN(m_instance, "position_label", sdaiSTRING, &val)) return val; else return NULL; }
        void put_position_label(label value) { sdaiPutAttrBN(m_instance, "position_label", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_result_element_volume_stress_tensor
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_result_element_volume_stress_tensor : public virtual analysis_result_element_volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_result_element_volume_stress_tensor
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_result_element_volume_stress_tensor(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_result_element_volume_stress_tensor")
        {}

                /// <summary>
                /// Create new instace of analysis_result_element_volume_stress_tensor and returns object of this C++ class to interact with
                /// </summary>
        static analysis_result_element_volume_stress_tensor Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "analysis_result_element_volume_stress_tensor"); assert(inst); return inst; }

        pressure_measure_with_unit get_shear_stress_tau_zy();
        void put_shear_stress_tau_zy(pressure_measure_with_unit inst);

        pressure_measure_with_unit get_shear_stress_tau_xz();
        void put_shear_stress_tau_xz(pressure_measure_with_unit inst);

        pressure_measure_with_unit get_normal_stress_sigma_z();
        void put_normal_stress_sigma_z(pressure_measure_with_unit inst);

        pressure_measure_with_unit get_normal_stress_sigma_y();
        void put_normal_stress_sigma_y(pressure_measure_with_unit inst);

        pressure_measure_with_unit get_normal_stress_sigma_x();
        void put_normal_stress_sigma_x(pressure_measure_with_unit inst);

        pressure_measure_with_unit get_shear_stress_tau_zx();
        void put_shear_stress_tau_zx(pressure_measure_with_unit inst);

        pressure_measure_with_unit get_shear_stress_tau_yz();
        void put_shear_stress_tau_yz(pressure_measure_with_unit inst);

        pressure_measure_with_unit get_shear_stress_tau_yx();
        void put_shear_stress_tau_yx(pressure_measure_with_unit inst);

        pressure_measure_with_unit get_shear_stress_tau_xy();
        void put_shear_stress_tau_xy(pressure_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_result_node
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_result_node : public virtual analysis_result
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_result_node
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_result_node(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_result_node")
        {}

                /// <summary>
                /// Create new instace of analysis_result_node and returns object of this C++ class to interact with
                /// </summary>
        static analysis_result_node Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "analysis_result_node"); assert(inst); return inst; }

        node get_result_for_node();
        void put_result_for_node(node inst);

        reaction get_result_values();
        void put_result_values(reaction inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_results_set
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_results_set : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_results_set
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_results_set(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_results_set")
        {}

                /// <summary>
                /// Create new instace of analysis_results_set and returns object of this C++ class to interact with
                /// </summary>
        static analysis_results_set Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "analysis_results_set"); assert(inst); return inst; }

        label get_results_set_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "results_set_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_results_set_name(label value) { sdaiPutAttrBN(m_instance, "results_set_name", sdaiSTRING, value); }

        //TList may be set_of_analysis_result or list of converible elements
        template <typename TList> void get_component_results(TList& lst) { set_of_analysis_resultSerializer<TList> sr; sr.FromAttr(lst, m_instance, "component_results"); }

        //TList may be set_of_analysis_result or list of converible elements
        template <typename TList> void put_component_results(TList& lst) { set_of_analysis_resultSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "component_results"); }

        //TArrayElem[] may be analysis_result[] or array of convertible elements
        template <typename TArrayElem> void put_component_results(TArrayElem arr[], size_t n) { set_of_analysis_result lst; ArrayToList(arr, n, lst); put_component_results(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_results_set_basic
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_results_set_basic : public virtual analysis_results_set
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_results_set_basic
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_results_set_basic(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_results_set_basic")
        {}

                /// <summary>
                /// Create new instace of analysis_results_set_basic and returns object of this C++ class to interact with
                /// </summary>
        static analysis_results_set_basic Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "analysis_results_set_basic"); assert(inst); return inst; }

        load_case get_basic_load_case();
        void put_basic_load_case(load_case inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_results_set_combined
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_results_set_combined : public virtual analysis_results_set
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_results_set_combined
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_results_set_combined(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_results_set_combined")
        {}

                /// <summary>
                /// Create new instace of analysis_results_set_combined and returns object of this C++ class to interact with
                /// </summary>
        static analysis_results_set_combined Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "analysis_results_set_combined"); assert(inst); return inst; }

        loading_combination get_loading_combination_ref();
        void put_loading_combination_ref(loading_combination inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_results_set_envelope
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_results_set_envelope : public virtual analysis_results_set
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_results_set_envelope
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_results_set_envelope(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_results_set_envelope")
        {}

                /// <summary>
                /// Create new instace of analysis_results_set_envelope and returns object of this C++ class to interact with
                /// </summary>
        static analysis_results_set_envelope Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "analysis_results_set_envelope"); assert(inst); return inst; }

        Nullable<maximum_or_minimum> get_max_or_min() { int v = getENUM("max_or_min", maximum_or_minimum_); if (v >= 0) return (maximum_or_minimum) v; else return Nullable<maximum_or_minimum>(); }
        void put_max_or_min(maximum_or_minimum value) { TextValue val = maximum_or_minimum_[(int) value]; sdaiPutAttrBN(m_instance, "max_or_min", sdaiENUM, val); }

        //TList may be set_of_analysis_results_set_combined or list of converible elements
        template <typename TList> void get_component_combinations(TList& lst) { set_of_analysis_results_set_combinedSerializer<TList> sr; sr.FromAttr(lst, m_instance, "component_combinations"); }

        //TList may be set_of_analysis_results_set_combined or list of converible elements
        template <typename TList> void put_component_combinations(TList& lst) { set_of_analysis_results_set_combinedSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "component_combinations"); }

        //TArrayElem[] may be analysis_results_set_combined[] or array of convertible elements
        template <typename TArrayElem> void put_component_combinations(TArrayElem arr[], size_t n) { set_of_analysis_results_set_combined lst; ArrayToList(arr, n, lst); put_component_combinations(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of analysis_results_set_redistributed
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class analysis_results_set_redistributed : public virtual analysis_results_set
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of analysis_results_set_redistributed
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        analysis_results_set_redistributed(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "analysis_results_set_redistributed")
        {}

                /// <summary>
                /// Create new instace of analysis_results_set_redistributed and returns object of this C++ class to interact with
                /// </summary>
        static analysis_results_set_redistributed Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "analysis_results_set_redistributed"); assert(inst); return inst; }

        //TList may be list_of_ratio_measure_with_unit or list of converible elements
        template <typename TList> void get_redistribution_factors(TList& lst) { list_of_ratio_measure_with_unitSerializer<TList> sr; sr.FromAttr(lst, m_instance, "redistribution_factors"); }

        //TList may be list_of_ratio_measure_with_unit or list of converible elements
        template <typename TList> void put_redistribution_factors(TList& lst) { list_of_ratio_measure_with_unitSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "redistribution_factors"); }

        //TArrayElem[] may be ratio_measure_with_unit[] or array of convertible elements
        template <typename TArrayElem> void put_redistribution_factors(TArrayElem arr[], size_t n) { list_of_ratio_measure_with_unit lst; ArrayToList(arr, n, lst); put_redistribution_factors(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of applied_load
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class applied_load : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of applied_load
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        applied_load(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "applied_load")
        {}


        label get_applied_load_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "applied_load_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_applied_load_name(label value) { sdaiPutAttrBN(m_instance, "applied_load_name", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of applied_load_dynamic
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class applied_load_dynamic : public virtual applied_load
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of applied_load_dynamic
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        applied_load_dynamic(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "applied_load_dynamic")
        {}

                /// <summary>
                /// Create new instace of applied_load_dynamic and returns object of this C++ class to interact with
                /// </summary>
        static applied_load_dynamic Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "applied_load_dynamic"); assert(inst); return inst; }

        applied_load_static get_initial_value();
        void put_initial_value(applied_load_static inst);

        applied_load_static get_final_value();
        void put_final_value(applied_load_static inst);

        applied_load_static get_maximum_value();
        void put_maximum_value(applied_load_static inst);

        applied_load_static get_minimum_value();
        void put_minimum_value(applied_load_static inst);

        Nullable<count_measure> get_number_of_cycles() { count_measure val = (count_measure) 0; if (sdaiGetAttrBN(m_instance, "number_of_cycles", sdaiREAL, &val)) return val; else return Nullable<count_measure>(); }
        void put_number_of_cycles(count_measure value) { sdaiPutAttrBN(m_instance, "number_of_cycles", sdaiREAL, &value); }

        time_measure_with_unit get_load_duration();
        void put_load_duration(time_measure_with_unit inst);

        frequency_measure_with_unit get_load_frequency();
        void put_load_frequency(frequency_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of applied_load_dynamic_acceleration
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class applied_load_dynamic_acceleration : public virtual applied_load_dynamic
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of applied_load_dynamic_acceleration
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        applied_load_dynamic_acceleration(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "applied_load_dynamic_acceleration")
        {}

                /// <summary>
                /// Create new instace of applied_load_dynamic_acceleration and returns object of this C++ class to interact with
                /// </summary>
        static applied_load_dynamic_acceleration Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "applied_load_dynamic_acceleration"); assert(inst); return inst; }

        linear_acceleration_measure_with_unit get_preset_acceleration_ax();
        void put_preset_acceleration_ax(linear_acceleration_measure_with_unit inst);

        linear_acceleration_measure_with_unit get_preset_acceleration_ay();
        void put_preset_acceleration_ay(linear_acceleration_measure_with_unit inst);

        linear_acceleration_measure_with_unit get_preset_acceleration_az();
        void put_preset_acceleration_az(linear_acceleration_measure_with_unit inst);

        rotational_acceleration_measure_with_unit get_preset_acceleration_arx();
        void put_preset_acceleration_arx(rotational_acceleration_measure_with_unit inst);

        rotational_acceleration_measure_with_unit get_preset_acceleration_ary();
        void put_preset_acceleration_ary(rotational_acceleration_measure_with_unit inst);

        rotational_acceleration_measure_with_unit get_preset_acceleration_arz();
        void put_preset_acceleration_arz(rotational_acceleration_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of applied_load_dynamic_velocity
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class applied_load_dynamic_velocity : public virtual applied_load_dynamic
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of applied_load_dynamic_velocity
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        applied_load_dynamic_velocity(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "applied_load_dynamic_velocity")
        {}

                /// <summary>
                /// Create new instace of applied_load_dynamic_velocity and returns object of this C++ class to interact with
                /// </summary>
        static applied_load_dynamic_velocity Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "applied_load_dynamic_velocity"); assert(inst); return inst; }

        linear_velocity_measure_with_unit get_preset_velocity_vx();
        void put_preset_velocity_vx(linear_velocity_measure_with_unit inst);

        linear_velocity_measure_with_unit get_preset_velocity_vy();
        void put_preset_velocity_vy(linear_velocity_measure_with_unit inst);

        linear_velocity_measure_with_unit get_preset_velocity_vz();
        void put_preset_velocity_vz(linear_velocity_measure_with_unit inst);

        rotational_velocity_measure_with_unit get_preset_velocity_vrx();
        void put_preset_velocity_vrx(rotational_velocity_measure_with_unit inst);

        rotational_velocity_measure_with_unit get_preset_velocity_vry();
        void put_preset_velocity_vry(rotational_velocity_measure_with_unit inst);

        rotational_velocity_measure_with_unit get_preset_velocity_vrz();
        void put_preset_velocity_vrz(rotational_velocity_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of applied_load_static
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class applied_load_static : public virtual applied_load
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of applied_load_static
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        applied_load_static(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "applied_load_static")
        {}

    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of applied_load_static_displacement
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class applied_load_static_displacement : public virtual applied_load_static
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of applied_load_static_displacement
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        applied_load_static_displacement(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "applied_load_static_displacement")
        {}

                /// <summary>
                /// Create new instace of applied_load_static_displacement and returns object of this C++ class to interact with
                /// </summary>
        static applied_load_static_displacement Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "applied_load_static_displacement"); assert(inst); return inst; }

        length_measure_with_unit get_preset_displacement_dx();
        void put_preset_displacement_dx(length_measure_with_unit inst);

        length_measure_with_unit get_preset_displacement_dy();
        void put_preset_displacement_dy(length_measure_with_unit inst);

        length_measure_with_unit get_preset_displacement_dz();
        void put_preset_displacement_dz(length_measure_with_unit inst);

        plane_angle_measure_with_unit get_preset_displacement_rx();
        void put_preset_displacement_rx(plane_angle_measure_with_unit inst);

        plane_angle_measure_with_unit get_preset_displacement_ry();
        void put_preset_displacement_ry(plane_angle_measure_with_unit inst);

        plane_angle_measure_with_unit get_preset_displacement_rz();
        void put_preset_displacement_rz(plane_angle_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of applied_load_static_force
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class applied_load_static_force : public virtual applied_load_static
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of applied_load_static_force
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        applied_load_static_force(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "applied_load_static_force")
        {}

                /// <summary>
                /// Create new instace of applied_load_static_force and returns object of this C++ class to interact with
                /// </summary>
        static applied_load_static_force Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "applied_load_static_force"); assert(inst); return inst; }

        force_measure_with_unit get_applied_force_fx();
        void put_applied_force_fx(force_measure_with_unit inst);

        force_measure_with_unit get_applied_force_fy();
        void put_applied_force_fy(force_measure_with_unit inst);

        force_measure_with_unit get_applied_force_fz();
        void put_applied_force_fz(force_measure_with_unit inst);

        moment_measure_with_unit get_applied_moment_mx();
        void put_applied_moment_mx(moment_measure_with_unit inst);

        moment_measure_with_unit get_applied_moment_my();
        void put_applied_moment_my(moment_measure_with_unit inst);

        moment_measure_with_unit get_applied_moment_mz();
        void put_applied_moment_mz(moment_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of applied_load_static_pressure
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class applied_load_static_pressure : public virtual applied_load_static
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of applied_load_static_pressure
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        applied_load_static_pressure(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "applied_load_static_pressure")
        {}

                /// <summary>
                /// Create new instace of applied_load_static_pressure and returns object of this C++ class to interact with
                /// </summary>
        static applied_load_static_pressure Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "applied_load_static_pressure"); assert(inst); return inst; }

        pressure_measure_with_unit get_applied_pressure_px();
        void put_applied_pressure_px(pressure_measure_with_unit inst);

        pressure_measure_with_unit get_applied_pressure_py();
        void put_applied_pressure_py(pressure_measure_with_unit inst);

        pressure_measure_with_unit get_applied_pressure_pz();
        void put_applied_pressure_pz(pressure_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of approval
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class approval : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of approval
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        approval(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "approval")
        {}

                /// <summary>
                /// Create new instace of approval and returns object of this C++ class to interact with
                /// </summary>
        static approval Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "approval"); assert(inst); return inst; }

        approval_status get_status();
        void put_status(approval_status inst);

        label get_level() { label val = NULL; if (sdaiGetAttrBN(m_instance, "level", sdaiSTRING, &val)) return val; else return NULL; }
        void put_level(label value) { sdaiPutAttrBN(m_instance, "level", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of approval_status
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class approval_status : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of approval_status
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        approval_status(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "approval_status")
        {}

                /// <summary>
                /// Create new instace of approval_status and returns object of this C++ class to interact with
                /// </summary>
        static approval_status Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "approval_status"); assert(inst); return inst; }

        label get_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_name(label value) { sdaiPutAttrBN(m_instance, "name", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class measure_with_unit : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "measure_with_unit"); assert(inst); return inst; }

        measure_value_get get_value_component() { return measure_value_get(m_instance, "value_component", NULL); }
        measure_value_put put_value_component() { return measure_value_put(m_instance, "value_component", NULL); }

        unit_get get_unit_component() { return unit_get(m_instance, "unit_component", NULL); }
        unit_put put_unit_component() { return unit_put(m_instance, "unit_component", NULL); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of area_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class area_measure_with_unit : public virtual measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of area_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        area_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "area_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of area_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static area_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "area_measure_with_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of named_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class named_unit : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of named_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        named_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "named_unit")
        {}

                /// <summary>
                /// Create new instace of named_unit and returns object of this C++ class to interact with
                /// </summary>
        static named_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "named_unit"); assert(inst); return inst; }

        dimensional_exponents get_dimensions();
        void put_dimensions(dimensional_exponents inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of area_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class area_unit : public virtual named_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of area_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        area_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "area_unit")
        {}

                /// <summary>
                /// Create new instace of area_unit and returns object of this C++ class to interact with
                /// </summary>
        static area_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "area_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of structural_frame_item
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class structural_frame_item : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of structural_frame_item
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        structural_frame_item(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "structural_frame_item")
        {}

                /// <summary>
                /// Create new instace of structural_frame_item and returns object of this C++ class to interact with
                /// </summary>
        static structural_frame_item Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "structural_frame_item"); assert(inst); return inst; }

        Nullable<IntValue> get_item_number() { IntValue val = (IntValue) 0; if (sdaiGetAttrBN(m_instance, "item_number", sdaiINTEGER, &val)) return val; else return Nullable<IntValue>(); }
        void put_item_number(IntValue value) { sdaiPutAttrBN(m_instance, "item_number", sdaiINTEGER, &value); }

        label get_item_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "item_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_item_name(label value) { sdaiPutAttrBN(m_instance, "item_name", sdaiSTRING, value); }

        text get_item_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "item_description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_item_description(text value) { sdaiPutAttrBN(m_instance, "item_description", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of structural_frame_process
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class structural_frame_process : public virtual structural_frame_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of structural_frame_process
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        structural_frame_process(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "structural_frame_process")
        {}

                /// <summary>
                /// Create new instace of structural_frame_process and returns object of this C++ class to interact with
                /// </summary>
        static structural_frame_process Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "structural_frame_process"); assert(inst); return inst; }

        organizational_address get_place_of_process();
        void put_place_of_process(organizational_address inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assemble
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assemble : public virtual structural_frame_process
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assemble
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assemble(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assemble")
        {}

                /// <summary>
                /// Create new instace of assemble and returns object of this C++ class to interact with
                /// </summary>
        static assemble Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assemble"); assert(inst); return inst; }

        located_assembly get_resulting_assembly();
        void put_resulting_assembly(located_assembly inst);

        //TList may be set_of_assembly_component_select or list of converible elements
        template <typename TList> void get_components(TList& lst) { set_of_assembly_component_selectSerializer<TList> sr; sr.FromAttr(lst, m_instance, "components"); }

        //TList may be set_of_assembly_component_select or list of converible elements
        template <typename TList> void put_components(TList& lst) { set_of_assembly_component_selectSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "components"); }

        //TList may be set_of_structural_frame_process or list of converible elements
        template <typename TList> void get_required_processes(TList& lst) { set_of_structural_frame_processSerializer<TList> sr; sr.FromAttr(lst, m_instance, "required_processes"); }

        //TList may be set_of_structural_frame_process or list of converible elements
        template <typename TList> void put_required_processes(TList& lst) { set_of_structural_frame_processSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "required_processes"); }

        //TArrayElem[] may be structural_frame_process[] or array of convertible elements
        template <typename TArrayElem> void put_required_processes(TArrayElem arr[], size_t n) { set_of_structural_frame_process lst; ArrayToList(arr, n, lst); put_required_processes(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of structural_frame_product
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class structural_frame_product : public virtual structural_frame_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of structural_frame_product
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        structural_frame_product(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "structural_frame_product")
        {}

                /// <summary>
                /// Create new instace of structural_frame_product and returns object of this C++ class to interact with
                /// </summary>
        static structural_frame_product Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "structural_frame_product"); assert(inst); return inst; }

        label get_life_cycle_stage() { label val = NULL; if (sdaiGetAttrBN(m_instance, "life_cycle_stage", sdaiSTRING, &val)) return val; else return NULL; }
        void put_life_cycle_stage(label value) { sdaiPutAttrBN(m_instance, "life_cycle_stage", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly : public virtual structural_frame_product
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly")
        {}


        Nullable<IntValue> get_assembly_sequence_number() { IntValue val = (IntValue) 0; if (sdaiGetAttrBN(m_instance, "assembly_sequence_number", sdaiINTEGER, &val)) return val; else return Nullable<IntValue>(); }
        void put_assembly_sequence_number(IntValue value) { sdaiPutAttrBN(m_instance, "assembly_sequence_number", sdaiINTEGER, &value); }

        Nullable<complexity_level> get_complexity() { int v = getENUM("complexity", complexity_level_); if (v >= 0) return (complexity_level) v; else return Nullable<complexity_level>(); }
        void put_complexity(complexity_level value) { TextValue val = complexity_level_[(int) value]; sdaiPutAttrBN(m_instance, "complexity", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly_design
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly_design : public virtual assembly
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly_design
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly_design(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly_design")
        {}

                /// <summary>
                /// Create new instace of assembly_design and returns object of this C++ class to interact with
                /// </summary>
        static assembly_design Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assembly_design"); assert(inst); return inst; }

        Nullable<bool> get_designed() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "designed", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_designed(bool value) { sdaiPutAttrBN(m_instance, "designed", sdaiBOOLEAN, &value); }

        Nullable<bool> get_checked_() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "checked_", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_checked_(bool value) { sdaiPutAttrBN(m_instance, "checked_", sdaiBOOLEAN, &value); }

        //TList may be set_of_functional_role or list of converible elements
        template <typename TList> void get_roles(TList& lst) { set_of_functional_roleSerializer<TList> sr; sr.FromAttr(lst, m_instance, "roles"); }

        //TList may be set_of_functional_role or list of converible elements
        template <typename TList> void put_roles(TList& lst) { set_of_functional_roleSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "roles"); }

        //TArrayElem[] may be functional_role[] or array of convertible elements
        template <typename TArrayElem> void put_roles(TArrayElem arr[], size_t n) { set_of_functional_role lst; ArrayToList(arr, n, lst); put_roles(lst); }

        //TList may be set_of_design_criterion or list of converible elements
        template <typename TList> void get_governing_criteria(TList& lst) { set_of_design_criterionSerializer<TList> sr; sr.FromAttr(lst, m_instance, "governing_criteria"); }

        //TList may be set_of_design_criterion or list of converible elements
        template <typename TList> void put_governing_criteria(TList& lst) { set_of_design_criterionSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "governing_criteria"); }

        //TArrayElem[] may be design_criterion[] or array of convertible elements
        template <typename TArrayElem> void put_governing_criteria(TArrayElem arr[], size_t n) { set_of_design_criterion lst; ArrayToList(arr, n, lst); put_governing_criteria(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly_design_child
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly_design_child : public virtual assembly_design
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly_design_child
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly_design_child(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly_design_child")
        {}

                /// <summary>
                /// Create new instace of assembly_design_child and returns object of this C++ class to interact with
                /// </summary>
        static assembly_design_child Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assembly_design_child"); assert(inst); return inst; }

        //TList may be set_of_assembly_design or list of converible elements
        template <typename TList> void get_parent_assemblies(TList& lst) { set_of_assembly_designSerializer<TList> sr; sr.FromAttr(lst, m_instance, "parent_assemblies"); }

        //TList may be set_of_assembly_design or list of converible elements
        template <typename TList> void put_parent_assemblies(TList& lst) { set_of_assembly_designSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "parent_assemblies"); }

        //TArrayElem[] may be assembly_design[] or array of convertible elements
        template <typename TArrayElem> void put_parent_assemblies(TArrayElem arr[], size_t n) { set_of_assembly_design lst; ArrayToList(arr, n, lst); put_parent_assemblies(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly_design_structural_connection
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly_design_structural_connection : public virtual assembly_design
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly_design_structural_connection
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly_design_structural_connection(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly_design_structural_connection")
        {}

                /// <summary>
                /// Create new instace of assembly_design_structural_connection and returns object of this C++ class to interact with
                /// </summary>
        static assembly_design_structural_connection Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assembly_design_structural_connection"); assert(inst); return inst; }

        Nullable<connection_type> get_struc_connection_type() { int v = getENUM("struc_connection_type", connection_type_); if (v >= 0) return (connection_type) v; else return Nullable<connection_type>(); }
        void put_struc_connection_type(connection_type value) { TextValue val = connection_type_[(int) value]; sdaiPutAttrBN(m_instance, "struc_connection_type", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly_design_structural_connection_external
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly_design_structural_connection_external : public virtual assembly_design_structural_connection
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly_design_structural_connection_external
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly_design_structural_connection_external(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly_design_structural_connection_external")
        {}

                /// <summary>
                /// Create new instace of assembly_design_structural_connection_external and returns object of this C++ class to interact with
                /// </summary>
        static assembly_design_structural_connection_external Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assembly_design_structural_connection_external"); assert(inst); return inst; }

        assembly_design_structural_member get_connected_member();
        void put_connected_member(assembly_design_structural_member inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly_design_structural_connection_internal
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly_design_structural_connection_internal : public virtual assembly_design_structural_connection
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly_design_structural_connection_internal
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly_design_structural_connection_internal(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly_design_structural_connection_internal")
        {}

                /// <summary>
                /// Create new instace of assembly_design_structural_connection_internal and returns object of this C++ class to interact with
                /// </summary>
        static assembly_design_structural_connection_internal Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assembly_design_structural_connection_internal"); assert(inst); return inst; }

        //TList may be set_of_assembly_design_structural_member or list of converible elements
        template <typename TList> void get_connected_members(TList& lst) { set_of_assembly_design_structural_memberSerializer<TList> sr; sr.FromAttr(lst, m_instance, "connected_members"); }

        //TList may be set_of_assembly_design_structural_member or list of converible elements
        template <typename TList> void put_connected_members(TList& lst) { set_of_assembly_design_structural_memberSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "connected_members"); }

        //TArrayElem[] may be assembly_design_structural_member[] or array of convertible elements
        template <typename TArrayElem> void put_connected_members(TArrayElem arr[], size_t n) { set_of_assembly_design_structural_member lst; ArrayToList(arr, n, lst); put_connected_members(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly_design_structural_frame
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly_design_structural_frame : public virtual assembly_design
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly_design_structural_frame
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly_design_structural_frame(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly_design_structural_frame")
        {}

                /// <summary>
                /// Create new instace of assembly_design_structural_frame and returns object of this C++ class to interact with
                /// </summary>
        static assembly_design_structural_frame Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assembly_design_structural_frame"); assert(inst); return inst; }

        Nullable<frame_type> get_type_of_frame() { int v = getENUM("type_of_frame", frame_type_); if (v >= 0) return (frame_type) v; else return Nullable<frame_type>(); }
        void put_type_of_frame(frame_type value) { TextValue val = frame_type_[(int) value]; sdaiPutAttrBN(m_instance, "type_of_frame", sdaiENUM, val); }

        Nullable<frame_continuity> get_continuity() { int v = getENUM("continuity", frame_continuity_); if (v >= 0) return (frame_continuity) v; else return Nullable<frame_continuity>(); }
        void put_continuity(frame_continuity value) { TextValue val = frame_continuity_[(int) value]; sdaiPutAttrBN(m_instance, "continuity", sdaiENUM, val); }

        Nullable<bool> get_sway_frame() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "sway_frame", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_sway_frame(bool value) { sdaiPutAttrBN(m_instance, "sway_frame", sdaiBOOLEAN, &value); }

        Nullable<bool> get_braced_frame() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "braced_frame", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_braced_frame(bool value) { sdaiPutAttrBN(m_instance, "braced_frame", sdaiBOOLEAN, &value); }

        Nullable<bool> get_bracing_frame() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "bracing_frame", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_bracing_frame(bool value) { sdaiPutAttrBN(m_instance, "bracing_frame", sdaiBOOLEAN, &value); }

        //TList may be set_of_assembly_design_structural_member or list of converible elements
        template <typename TList> void get_frame_members(TList& lst) { set_of_assembly_design_structural_memberSerializer<TList> sr; sr.FromAttr(lst, m_instance, "frame_members"); }

        //TList may be set_of_assembly_design_structural_member or list of converible elements
        template <typename TList> void put_frame_members(TList& lst) { set_of_assembly_design_structural_memberSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "frame_members"); }

        //TArrayElem[] may be assembly_design_structural_member[] or array of convertible elements
        template <typename TArrayElem> void put_frame_members(TArrayElem arr[], size_t n) { set_of_assembly_design_structural_member lst; ArrayToList(arr, n, lst); put_frame_members(lst); }

        //TList may be set_of_assembly_design_structural_connection or list of converible elements
        template <typename TList> void get_frame_connections(TList& lst) { set_of_assembly_design_structural_connectionSerializer<TList> sr; sr.FromAttr(lst, m_instance, "frame_connections"); }

        //TList may be set_of_assembly_design_structural_connection or list of converible elements
        template <typename TList> void put_frame_connections(TList& lst) { set_of_assembly_design_structural_connectionSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "frame_connections"); }

        //TArrayElem[] may be assembly_design_structural_connection[] or array of convertible elements
        template <typename TArrayElem> void put_frame_connections(TArrayElem arr[], size_t n) { set_of_assembly_design_structural_connection lst; ArrayToList(arr, n, lst); put_frame_connections(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly_design_structural_member
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly_design_structural_member : public virtual assembly_design
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly_design_structural_member
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly_design_structural_member(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly_design_structural_member")
        {}

                /// <summary>
                /// Create new instace of assembly_design_structural_member and returns object of this C++ class to interact with
                /// </summary>
        static assembly_design_structural_member Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assembly_design_structural_member"); assert(inst); return inst; }

        Nullable<bool> get_key_member() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "key_member", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_key_member(bool value) { sdaiPutAttrBN(m_instance, "key_member", sdaiBOOLEAN, &value); }

        Nullable<member_role> get_structural_member_use() { int v = getENUM("structural_member_use", member_role_); if (v >= 0) return (member_role) v; else return Nullable<member_role>(); }
        void put_structural_member_use(member_role value) { TextValue val = member_role_[(int) value]; sdaiPutAttrBN(m_instance, "structural_member_use", sdaiENUM, val); }

        Nullable<member_class> get_structural_member_class() { int v = getENUM("structural_member_class", member_class_); if (v >= 0) return (member_class) v; else return Nullable<member_class>(); }
        void put_structural_member_class(member_class value) { TextValue val = member_class_[(int) value]; sdaiPutAttrBN(m_instance, "structural_member_class", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly_design_structural_member_cubic
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly_design_structural_member_cubic : public virtual assembly_design_structural_member
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly_design_structural_member_cubic
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly_design_structural_member_cubic(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly_design_structural_member_cubic")
        {}

                /// <summary>
                /// Create new instace of assembly_design_structural_member_cubic and returns object of this C++ class to interact with
                /// </summary>
        static assembly_design_structural_member_cubic Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assembly_design_structural_member_cubic"); assert(inst); return inst; }

        Nullable<member_cubic_type> get_cubic_member_type() { int v = getENUM("cubic_member_type", member_cubic_type_); if (v >= 0) return (member_cubic_type) v; else return Nullable<member_cubic_type>(); }
        void put_cubic_member_type(member_cubic_type value) { TextValue val = member_cubic_type_[(int) value]; sdaiPutAttrBN(m_instance, "cubic_member_type", sdaiENUM, val); }

        //TList may be set_of_assembly_design_structural_member or list of converible elements
        template <typename TList> void get_cubic_member_components(TList& lst) { set_of_assembly_design_structural_memberSerializer<TList> sr; sr.FromAttr(lst, m_instance, "cubic_member_components"); }

        //TList may be set_of_assembly_design_structural_member or list of converible elements
        template <typename TList> void put_cubic_member_components(TList& lst) { set_of_assembly_design_structural_memberSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "cubic_member_components"); }

        //TArrayElem[] may be assembly_design_structural_member[] or array of convertible elements
        template <typename TArrayElem> void put_cubic_member_components(TArrayElem arr[], size_t n) { set_of_assembly_design_structural_member lst; ArrayToList(arr, n, lst); put_cubic_member_components(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly_design_structural_member_linear
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly_design_structural_member_linear : public virtual assembly_design_structural_member
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly_design_structural_member_linear
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly_design_structural_member_linear(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly_design_structural_member_linear")
        {}

                /// <summary>
                /// Create new instace of assembly_design_structural_member_linear and returns object of this C++ class to interact with
                /// </summary>
        static assembly_design_structural_member_linear Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assembly_design_structural_member_linear"); assert(inst); return inst; }

        Nullable<member_linear_type> get_linear_member_type() { int v = getENUM("linear_member_type", member_linear_type_); if (v >= 0) return (member_linear_type) v; else return Nullable<member_linear_type>(); }
        void put_linear_member_type(member_linear_type value) { TextValue val = member_linear_type_[(int) value]; sdaiPutAttrBN(m_instance, "linear_member_type", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly_design_structural_member_linear_beam
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly_design_structural_member_linear_beam : public virtual assembly_design_structural_member_linear
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly_design_structural_member_linear_beam
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly_design_structural_member_linear_beam(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly_design_structural_member_linear_beam")
        {}

                /// <summary>
                /// Create new instace of assembly_design_structural_member_linear_beam and returns object of this C++ class to interact with
                /// </summary>
        static assembly_design_structural_member_linear_beam Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assembly_design_structural_member_linear_beam"); assert(inst); return inst; }

        //TList may be set_of_member_beam_type or list of converible elements
        template <typename TList> void get_beam_type(TList& lst) { set_of_member_beam_typeSerializer<TList> sr; sr.FromAttr(lst, m_instance, "beam_type"); }

        //TList may be set_of_member_beam_type or list of converible elements
        template <typename TList> void put_beam_type(TList& lst) { set_of_member_beam_typeSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "beam_type"); }

        //TArrayElem[] may be member_beam_type[] or array of convertible elements
        template <typename TArrayElem> void put_beam_type(TArrayElem arr[], size_t n) { set_of_member_beam_type lst; ArrayToList(arr, n, lst); put_beam_type(lst); }

        //TList may be set_of_member_beam_role or list of converible elements
        template <typename TList> void get_beam_role(TList& lst) { set_of_member_beam_roleSerializer<TList> sr; sr.FromAttr(lst, m_instance, "beam_role"); }

        //TList may be set_of_member_beam_role or list of converible elements
        template <typename TList> void put_beam_role(TList& lst) { set_of_member_beam_roleSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "beam_role"); }

        //TArrayElem[] may be member_beam_role[] or array of convertible elements
        template <typename TArrayElem> void put_beam_role(TArrayElem arr[], size_t n) { set_of_member_beam_role lst; ArrayToList(arr, n, lst); put_beam_role(lst); }

        Nullable<LOGICAL_VALUE> get_unrestrained_beam() { int v = getENUM("unrestrained_beam", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_unrestrained_beam(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "unrestrained_beam", sdaiENUM, val); }

        Nullable<LOGICAL_VALUE> get_deep_beam() { int v = getENUM("deep_beam", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_deep_beam(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "deep_beam", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly_design_structural_member_linear_brace
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly_design_structural_member_linear_brace : public virtual assembly_design_structural_member_linear
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly_design_structural_member_linear_brace
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly_design_structural_member_linear_brace(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly_design_structural_member_linear_brace")
        {}

                /// <summary>
                /// Create new instace of assembly_design_structural_member_linear_brace and returns object of this C++ class to interact with
                /// </summary>
        static assembly_design_structural_member_linear_brace Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assembly_design_structural_member_linear_brace"); assert(inst); return inst; }

        Nullable<member_brace_type> get_brace_type() { int v = getENUM("brace_type", member_brace_type_); if (v >= 0) return (member_brace_type) v; else return Nullable<member_brace_type>(); }
        void put_brace_type(member_brace_type value) { TextValue val = member_brace_type_[(int) value]; sdaiPutAttrBN(m_instance, "brace_type", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly_design_structural_member_linear_cable
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly_design_structural_member_linear_cable : public virtual assembly_design_structural_member_linear
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly_design_structural_member_linear_cable
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly_design_structural_member_linear_cable(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly_design_structural_member_linear_cable")
        {}

                /// <summary>
                /// Create new instace of assembly_design_structural_member_linear_cable and returns object of this C++ class to interact with
                /// </summary>
        static assembly_design_structural_member_linear_cable Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assembly_design_structural_member_linear_cable"); assert(inst); return inst; }

        Nullable<member_cable_type> get_cable_type() { int v = getENUM("cable_type", member_cable_type_); if (v >= 0) return (member_cable_type) v; else return Nullable<member_cable_type>(); }
        void put_cable_type(member_cable_type value) { TextValue val = member_cable_type_[(int) value]; sdaiPutAttrBN(m_instance, "cable_type", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly_design_structural_member_linear_cambered
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly_design_structural_member_linear_cambered : public virtual assembly_design_structural_member_linear
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly_design_structural_member_linear_cambered
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly_design_structural_member_linear_cambered(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly_design_structural_member_linear_cambered")
        {}

                /// <summary>
                /// Create new instace of assembly_design_structural_member_linear_cambered and returns object of this C++ class to interact with
                /// </summary>
        static assembly_design_structural_member_linear_cambered Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assembly_design_structural_member_linear_cambered"); assert(inst); return inst; }

        text get_camber_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "camber_description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_camber_description(text value) { sdaiPutAttrBN(m_instance, "camber_description", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly_design_structural_member_linear_cambered_absolute
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly_design_structural_member_linear_cambered_absolute : public virtual assembly_design_structural_member_linear_cambered
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly_design_structural_member_linear_cambered_absolute
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly_design_structural_member_linear_cambered_absolute(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly_design_structural_member_linear_cambered_absolute")
        {}

                /// <summary>
                /// Create new instace of assembly_design_structural_member_linear_cambered_absolute and returns object of this C++ class to interact with
                /// </summary>
        static assembly_design_structural_member_linear_cambered_absolute Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assembly_design_structural_member_linear_cambered_absolute"); assert(inst); return inst; }

        positive_length_measure_with_unit get_absolute_offset_position();
        void put_absolute_offset_position(positive_length_measure_with_unit inst);

        length_measure_with_unit get_absolute_offset_y();
        void put_absolute_offset_y(length_measure_with_unit inst);

        length_measure_with_unit get_absolute_offset_z();
        void put_absolute_offset_z(length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly_design_structural_member_linear_cambered_relative
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly_design_structural_member_linear_cambered_relative : public virtual assembly_design_structural_member_linear_cambered
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly_design_structural_member_linear_cambered_relative
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly_design_structural_member_linear_cambered_relative(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly_design_structural_member_linear_cambered_relative")
        {}

                /// <summary>
                /// Create new instace of assembly_design_structural_member_linear_cambered_relative and returns object of this C++ class to interact with
                /// </summary>
        static assembly_design_structural_member_linear_cambered_relative Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assembly_design_structural_member_linear_cambered_relative"); assert(inst); return inst; }

        ratio_measure_with_unit get_relative_offset_position();
        void put_relative_offset_position(ratio_measure_with_unit inst);

        ratio_measure_with_unit get_relative_offset_y();
        void put_relative_offset_y(ratio_measure_with_unit inst);

        ratio_measure_with_unit get_relative_offset_z();
        void put_relative_offset_z(ratio_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly_design_structural_member_linear_column
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly_design_structural_member_linear_column : public virtual assembly_design_structural_member_linear
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly_design_structural_member_linear_column
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly_design_structural_member_linear_column(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly_design_structural_member_linear_column")
        {}

                /// <summary>
                /// Create new instace of assembly_design_structural_member_linear_column and returns object of this C++ class to interact with
                /// </summary>
        static assembly_design_structural_member_linear_column Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assembly_design_structural_member_linear_column"); assert(inst); return inst; }

        //TList may be set_of_member_column_type or list of converible elements
        template <typename TList> void get_column_type(TList& lst) { set_of_member_column_typeSerializer<TList> sr; sr.FromAttr(lst, m_instance, "column_type"); }

        //TList may be set_of_member_column_type or list of converible elements
        template <typename TList> void put_column_type(TList& lst) { set_of_member_column_typeSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "column_type"); }

        //TArrayElem[] may be member_column_type[] or array of convertible elements
        template <typename TArrayElem> void put_column_type(TArrayElem arr[], size_t n) { set_of_member_column_type lst; ArrayToList(arr, n, lst); put_column_type(lst); }

        Nullable<LOGICAL_VALUE> get_slender_column() { int v = getENUM("slender_column", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_slender_column(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "slender_column", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly_design_structural_member_planar
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly_design_structural_member_planar : public virtual assembly_design_structural_member
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly_design_structural_member_planar
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly_design_structural_member_planar(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly_design_structural_member_planar")
        {}

                /// <summary>
                /// Create new instace of assembly_design_structural_member_planar and returns object of this C++ class to interact with
                /// </summary>
        static assembly_design_structural_member_planar Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assembly_design_structural_member_planar"); assert(inst); return inst; }

        Nullable<member_planar_type> get_planar_member_type() { int v = getENUM("planar_member_type", member_planar_type_); if (v >= 0) return (member_planar_type) v; else return Nullable<member_planar_type>(); }
        void put_planar_member_type(member_planar_type value) { TextValue val = member_planar_type_[(int) value]; sdaiPutAttrBN(m_instance, "planar_member_type", sdaiENUM, val); }

        //TList may be set_of_assembly_design_structural_member_linear or list of converible elements
        template <typename TList> void get_planar_member_components(TList& lst) { set_of_assembly_design_structural_member_linearSerializer<TList> sr; sr.FromAttr(lst, m_instance, "planar_member_components"); }

        //TList may be set_of_assembly_design_structural_member_linear or list of converible elements
        template <typename TList> void put_planar_member_components(TList& lst) { set_of_assembly_design_structural_member_linearSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "planar_member_components"); }

        //TArrayElem[] may be assembly_design_structural_member_linear[] or array of convertible elements
        template <typename TArrayElem> void put_planar_member_components(TArrayElem arr[], size_t n) { set_of_assembly_design_structural_member_linear lst; ArrayToList(arr, n, lst); put_planar_member_components(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly_design_structural_member_planar_plate
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly_design_structural_member_planar_plate : public virtual assembly_design_structural_member_planar
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly_design_structural_member_planar_plate
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly_design_structural_member_planar_plate(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly_design_structural_member_planar_plate")
        {}

                /// <summary>
                /// Create new instace of assembly_design_structural_member_planar_plate and returns object of this C++ class to interact with
                /// </summary>
        static assembly_design_structural_member_planar_plate Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assembly_design_structural_member_planar_plate"); assert(inst); return inst; }

        Nullable<member_plate_type> get_plate_type() { int v = getENUM("plate_type", member_plate_type_); if (v >= 0) return (member_plate_type) v; else return Nullable<member_plate_type>(); }
        void put_plate_type(member_plate_type value) { TextValue val = member_plate_type_[(int) value]; sdaiPutAttrBN(m_instance, "plate_type", sdaiENUM, val); }

        Nullable<LOGICAL_VALUE> get_stiffened_plate() { int v = getENUM("stiffened_plate", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_stiffened_plate(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "stiffened_plate", sdaiENUM, val); }

        Nullable<LOGICAL_VALUE> get_thick_plate() { int v = getENUM("thick_plate", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_thick_plate(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "thick_plate", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly_design_structural_member_planar_slab
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly_design_structural_member_planar_slab : public virtual assembly_design_structural_member_planar
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly_design_structural_member_planar_slab
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly_design_structural_member_planar_slab(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly_design_structural_member_planar_slab")
        {}

                /// <summary>
                /// Create new instace of assembly_design_structural_member_planar_slab and returns object of this C++ class to interact with
                /// </summary>
        static assembly_design_structural_member_planar_slab Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assembly_design_structural_member_planar_slab"); assert(inst); return inst; }

        Nullable<member_slab_type> get_slab_type() { int v = getENUM("slab_type", member_slab_type_); if (v >= 0) return (member_slab_type) v; else return Nullable<member_slab_type>(); }
        void put_slab_type(member_slab_type value) { TextValue val = member_slab_type_[(int) value]; sdaiPutAttrBN(m_instance, "slab_type", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly_design_structural_member_planar_wall
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly_design_structural_member_planar_wall : public virtual assembly_design_structural_member_planar
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly_design_structural_member_planar_wall
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly_design_structural_member_planar_wall(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly_design_structural_member_planar_wall")
        {}

                /// <summary>
                /// Create new instace of assembly_design_structural_member_planar_wall and returns object of this C++ class to interact with
                /// </summary>
        static assembly_design_structural_member_planar_wall Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assembly_design_structural_member_planar_wall"); assert(inst); return inst; }

        Nullable<member_wall_type> get_wall_type() { int v = getENUM("wall_type", member_wall_type_); if (v >= 0) return (member_wall_type) v; else return Nullable<member_wall_type>(); }
        void put_wall_type(member_wall_type value) { TextValue val = member_wall_type_[(int) value]; sdaiPutAttrBN(m_instance, "wall_type", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly_manufacturing
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly_manufacturing : public virtual assembly
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly_manufacturing
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly_manufacturing(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly_manufacturing")
        {}

                /// <summary>
                /// Create new instace of assembly_manufacturing and returns object of this C++ class to interact with
                /// </summary>
        static assembly_manufacturing Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assembly_manufacturing"); assert(inst); return inst; }

        text get_surface_treatment() { text val = NULL; if (sdaiGetAttrBN(m_instance, "surface_treatment", sdaiSTRING, &val)) return val; else return NULL; }
        void put_surface_treatment(text value) { sdaiPutAttrBN(m_instance, "surface_treatment", sdaiSTRING, value); }

        text get_assembly_sequence() { text val = NULL; if (sdaiGetAttrBN(m_instance, "assembly_sequence", sdaiSTRING, &val)) return val; else return NULL; }
        void put_assembly_sequence(text value) { sdaiPutAttrBN(m_instance, "assembly_sequence", sdaiSTRING, value); }

        text get_assembly_use() { text val = NULL; if (sdaiGetAttrBN(m_instance, "assembly_use", sdaiSTRING, &val)) return val; else return NULL; }
        void put_assembly_use(text value) { sdaiPutAttrBN(m_instance, "assembly_use", sdaiSTRING, value); }

        Nullable<shop_or_site> get_place_of_assembly() { int v = getENUM("place_of_assembly", shop_or_site_); if (v >= 0) return (shop_or_site) v; else return Nullable<shop_or_site>(); }
        void put_place_of_assembly(shop_or_site value) { TextValue val = shop_or_site_[(int) value]; sdaiPutAttrBN(m_instance, "place_of_assembly", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly_manufacturing_child
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly_manufacturing_child : public virtual assembly_manufacturing
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly_manufacturing_child
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly_manufacturing_child(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly_manufacturing_child")
        {}

                /// <summary>
                /// Create new instace of assembly_manufacturing_child and returns object of this C++ class to interact with
                /// </summary>
        static assembly_manufacturing_child Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assembly_manufacturing_child"); assert(inst); return inst; }

        assembly_manufacturing get_parent_assembly();
        void put_parent_assembly(assembly_manufacturing inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly_map
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly_map : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly_map
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly_map(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly_map")
        {}

                /// <summary>
                /// Create new instace of assembly_map and returns object of this C++ class to interact with
                /// </summary>
        static assembly_map Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assembly_map"); assert(inst); return inst; }

        assembly get_represented_assembly();
        void put_represented_assembly(assembly inst);

        //TList may be set_of_element or list of converible elements
        template <typename TList> void get_representing_elements(TList& lst) { set_of_elementSerializer<TList> sr; sr.FromAttr(lst, m_instance, "representing_elements"); }

        //TList may be set_of_element or list of converible elements
        template <typename TList> void put_representing_elements(TList& lst) { set_of_elementSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "representing_elements"); }

        //TArrayElem[] may be element[] or array of convertible elements
        template <typename TArrayElem> void put_representing_elements(TArrayElem arr[], size_t n) { set_of_element lst; ArrayToList(arr, n, lst); put_representing_elements(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly_relationship
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly_relationship : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly_relationship
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly_relationship(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly_relationship")
        {}

                /// <summary>
                /// Create new instace of assembly_relationship and returns object of this C++ class to interact with
                /// </summary>
        static assembly_relationship Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assembly_relationship"); assert(inst); return inst; }

        label get_relationship_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "relationship_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_relationship_name(label value) { sdaiPutAttrBN(m_instance, "relationship_name", sdaiSTRING, value); }

        text get_relationship_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "relationship_description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_relationship_description(text value) { sdaiPutAttrBN(m_instance, "relationship_description", sdaiSTRING, value); }

        assembly get_related_assembly();
        void put_related_assembly(assembly inst);

        assembly get_relating_assembly();
        void put_relating_assembly(assembly inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly_with_shape
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly_with_shape : public virtual assembly
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly_with_shape
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly_with_shape(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly_with_shape")
        {}

                /// <summary>
                /// Create new instace of assembly_with_shape and returns object of this C++ class to interact with
                /// </summary>
        static assembly_with_shape Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assembly_with_shape"); assert(inst); return inst; }

        shape_representation_with_units get_shape();
        void put_shape(shape_representation_with_units inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of assembly_with_bounding_box
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class assembly_with_bounding_box : public virtual assembly_with_shape
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of assembly_with_bounding_box
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        assembly_with_bounding_box(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "assembly_with_bounding_box")
        {}

                /// <summary>
                /// Create new instace of assembly_with_bounding_box and returns object of this C++ class to interact with
                /// </summary>
        static assembly_with_bounding_box Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "assembly_with_bounding_box"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of representation_item
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class representation_item : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of representation_item
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        representation_item(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "representation_item")
        {}

                /// <summary>
                /// Create new instace of representation_item and returns object of this C++ class to interact with
                /// </summary>
        static representation_item Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "representation_item"); assert(inst); return inst; }

        label get_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_name(label value) { sdaiPutAttrBN(m_instance, "name", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of geometric_representation_item
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class geometric_representation_item : public virtual representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of geometric_representation_item
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        geometric_representation_item(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "geometric_representation_item")
        {}

                /// <summary>
                /// Create new instace of geometric_representation_item and returns object of this C++ class to interact with
                /// </summary>
        static geometric_representation_item Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "geometric_representation_item"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of placement
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class placement : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of placement
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        placement(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "placement")
        {}

                /// <summary>
                /// Create new instace of placement and returns object of this C++ class to interact with
                /// </summary>
        static placement Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "placement"); assert(inst); return inst; }

        cartesian_point get_location();
        void put_location(cartesian_point inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of axis1_placement
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class axis1_placement : public virtual placement
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of axis1_placement
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        axis1_placement(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "axis1_placement")
        {}

                /// <summary>
                /// Create new instace of axis1_placement and returns object of this C++ class to interact with
                /// </summary>
        static axis1_placement Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "axis1_placement"); assert(inst); return inst; }

        direction get_axis();
        void put_axis(direction inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of axis2_placement_2d
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class axis2_placement_2d : public virtual placement
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of axis2_placement_2d
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        axis2_placement_2d(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "axis2_placement_2d")
        {}

                /// <summary>
                /// Create new instace of axis2_placement_2d and returns object of this C++ class to interact with
                /// </summary>
        static axis2_placement_2d Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "axis2_placement_2d"); assert(inst); return inst; }

        direction get_ref_direction();
        void put_ref_direction(direction inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of axis2_placement_3d
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class axis2_placement_3d : public virtual placement
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of axis2_placement_3d
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        axis2_placement_3d(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "axis2_placement_3d")
        {}

                /// <summary>
                /// Create new instace of axis2_placement_3d and returns object of this C++ class to interact with
                /// </summary>
        static axis2_placement_3d Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "axis2_placement_3d"); assert(inst); return inst; }

        direction get_axis();
        void put_axis(direction inst);

        direction get_ref_direction();
        void put_ref_direction(direction inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of curve
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class curve : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of curve
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        curve(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "curve")
        {}

                /// <summary>
                /// Create new instace of curve and returns object of this C++ class to interact with
                /// </summary>
        static curve Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "curve"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of bounded_curve
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class bounded_curve : public virtual curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of bounded_curve
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        bounded_curve(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "bounded_curve")
        {}

                /// <summary>
                /// Create new instace of bounded_curve and returns object of this C++ class to interact with
                /// </summary>
        static bounded_curve Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "bounded_curve"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of b_spline_curve
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class b_spline_curve : public virtual bounded_curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of b_spline_curve
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        b_spline_curve(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "b_spline_curve")
        {}

                /// <summary>
                /// Create new instace of b_spline_curve and returns object of this C++ class to interact with
                /// </summary>
        static b_spline_curve Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "b_spline_curve"); assert(inst); return inst; }

        Nullable<IntValue> get_degree() { IntValue val = (IntValue) 0; if (sdaiGetAttrBN(m_instance, "degree", sdaiINTEGER, &val)) return val; else return Nullable<IntValue>(); }
        void put_degree(IntValue value) { sdaiPutAttrBN(m_instance, "degree", sdaiINTEGER, &value); }

        //TList may be list_of_cartesian_point or list of converible elements
        template <typename TList> void get_control_points_list(TList& lst) { list_of_cartesian_pointSerializer<TList> sr; sr.FromAttr(lst, m_instance, "control_points_list"); }

        //TList may be list_of_cartesian_point or list of converible elements
        template <typename TList> void put_control_points_list(TList& lst) { list_of_cartesian_pointSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "control_points_list"); }

        //TArrayElem[] may be cartesian_point[] or array of convertible elements
        template <typename TArrayElem> void put_control_points_list(TArrayElem arr[], size_t n) { list_of_cartesian_point lst; ArrayToList(arr, n, lst); put_control_points_list(lst); }

        Nullable<b_spline_curve_form> get_curve_form() { int v = getENUM("curve_form", b_spline_curve_form_); if (v >= 0) return (b_spline_curve_form) v; else return Nullable<b_spline_curve_form>(); }
        void put_curve_form(b_spline_curve_form value) { TextValue val = b_spline_curve_form_[(int) value]; sdaiPutAttrBN(m_instance, "curve_form", sdaiENUM, val); }

        Nullable<LOGICAL_VALUE> get_closed_curve() { int v = getENUM("closed_curve", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_closed_curve(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "closed_curve", sdaiENUM, val); }

        Nullable<LOGICAL_VALUE> get_self_intersect() { int v = getENUM("self_intersect", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_self_intersect(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "self_intersect", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of b_spline_curve_with_knots
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class b_spline_curve_with_knots : public virtual b_spline_curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of b_spline_curve_with_knots
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        b_spline_curve_with_knots(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "b_spline_curve_with_knots")
        {}

                /// <summary>
                /// Create new instace of b_spline_curve_with_knots and returns object of this C++ class to interact with
                /// </summary>
        static b_spline_curve_with_knots Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "b_spline_curve_with_knots"); assert(inst); return inst; }

        //TList may be ListOfIntValue or list of converible elements
        template <typename TList> void get_knot_multiplicities(TList& lst) { ListOfIntValueSerializer<TList> sr; sr.FromAttr(lst, m_instance, "knot_multiplicities"); }

        //TList may be ListOfIntValue or list of converible elements
        template <typename TList> void put_knot_multiplicities(TList& lst) { ListOfIntValueSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "knot_multiplicities"); }

        //TArrayElem[] may be IntValue[] or array of convertible elements
        template <typename TArrayElem> void put_knot_multiplicities(TArrayElem arr[], size_t n) { ListOfIntValue lst; ArrayToList(arr, n, lst); put_knot_multiplicities(lst); }

        //TList may be list_of_parameter_value or list of converible elements
        template <typename TList> void get_knots(TList& lst) { list_of_parameter_valueSerializer<TList> sr; sr.FromAttr(lst, m_instance, "knots"); }

        //TList may be list_of_parameter_value or list of converible elements
        template <typename TList> void put_knots(TList& lst) { list_of_parameter_valueSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "knots"); }

        //TArrayElem[] may be parameter_value[] or array of convertible elements
        template <typename TArrayElem> void put_knots(TArrayElem arr[], size_t n) { list_of_parameter_value lst; ArrayToList(arr, n, lst); put_knots(lst); }

        Nullable<knot_type> get_knot_spec() { int v = getENUM("knot_spec", knot_type_); if (v >= 0) return (knot_type) v; else return Nullable<knot_type>(); }
        void put_knot_spec(knot_type value) { TextValue val = knot_type_[(int) value]; sdaiPutAttrBN(m_instance, "knot_spec", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class surface : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "surface")
        {}

                /// <summary>
                /// Create new instace of surface and returns object of this C++ class to interact with
                /// </summary>
        static surface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "surface"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of bounded_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class bounded_surface : public virtual surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of bounded_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        bounded_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "bounded_surface")
        {}

                /// <summary>
                /// Create new instace of bounded_surface and returns object of this C++ class to interact with
                /// </summary>
        static bounded_surface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "bounded_surface"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of b_spline_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class b_spline_surface : public virtual bounded_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of b_spline_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        b_spline_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "b_spline_surface")
        {}

                /// <summary>
                /// Create new instace of b_spline_surface and returns object of this C++ class to interact with
                /// </summary>
        static b_spline_surface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "b_spline_surface"); assert(inst); return inst; }

        Nullable<IntValue> get_u_degree() { IntValue val = (IntValue) 0; if (sdaiGetAttrBN(m_instance, "u_degree", sdaiINTEGER, &val)) return val; else return Nullable<IntValue>(); }
        void put_u_degree(IntValue value) { sdaiPutAttrBN(m_instance, "u_degree", sdaiINTEGER, &value); }

        Nullable<IntValue> get_v_degree() { IntValue val = (IntValue) 0; if (sdaiGetAttrBN(m_instance, "v_degree", sdaiINTEGER, &val)) return val; else return Nullable<IntValue>(); }
        void put_v_degree(IntValue value) { sdaiPutAttrBN(m_instance, "v_degree", sdaiINTEGER, &value); }

        //TList may be list_of_list_of_cartesian_point or list of converible elements
        template <typename TList> void get_control_points_list(TList& lst) { list_of_list_of_cartesian_pointSerializer<TList> sr; sr.FromAttr(lst, m_instance, "control_points_list"); }

        //TList may be list_of_list_of_cartesian_point or list of converible elements
        template <typename TList> void put_control_points_list(TList& lst) { list_of_list_of_cartesian_pointSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "control_points_list"); }

        Nullable<b_spline_surface_form> get_surface_form() { int v = getENUM("surface_form", b_spline_surface_form_); if (v >= 0) return (b_spline_surface_form) v; else return Nullable<b_spline_surface_form>(); }
        void put_surface_form(b_spline_surface_form value) { TextValue val = b_spline_surface_form_[(int) value]; sdaiPutAttrBN(m_instance, "surface_form", sdaiENUM, val); }

        Nullable<LOGICAL_VALUE> get_u_closed() { int v = getENUM("u_closed", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_u_closed(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "u_closed", sdaiENUM, val); }

        Nullable<LOGICAL_VALUE> get_v_closed() { int v = getENUM("v_closed", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_v_closed(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "v_closed", sdaiENUM, val); }

        Nullable<LOGICAL_VALUE> get_self_intersect() { int v = getENUM("self_intersect", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_self_intersect(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "self_intersect", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of b_spline_surface_with_knots
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class b_spline_surface_with_knots : public virtual b_spline_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of b_spline_surface_with_knots
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        b_spline_surface_with_knots(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "b_spline_surface_with_knots")
        {}

                /// <summary>
                /// Create new instace of b_spline_surface_with_knots and returns object of this C++ class to interact with
                /// </summary>
        static b_spline_surface_with_knots Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "b_spline_surface_with_knots"); assert(inst); return inst; }

        //TList may be ListOfIntValue or list of converible elements
        template <typename TList> void get_u_multiplicities(TList& lst) { ListOfIntValueSerializer<TList> sr; sr.FromAttr(lst, m_instance, "u_multiplicities"); }

        //TList may be ListOfIntValue or list of converible elements
        template <typename TList> void put_u_multiplicities(TList& lst) { ListOfIntValueSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "u_multiplicities"); }

        //TArrayElem[] may be IntValue[] or array of convertible elements
        template <typename TArrayElem> void put_u_multiplicities(TArrayElem arr[], size_t n) { ListOfIntValue lst; ArrayToList(arr, n, lst); put_u_multiplicities(lst); }

        //TList may be ListOfIntValue or list of converible elements
        template <typename TList> void get_v_multiplicities(TList& lst) { ListOfIntValueSerializer<TList> sr; sr.FromAttr(lst, m_instance, "v_multiplicities"); }

        //TList may be ListOfIntValue or list of converible elements
        template <typename TList> void put_v_multiplicities(TList& lst) { ListOfIntValueSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "v_multiplicities"); }

        //TArrayElem[] may be IntValue[] or array of convertible elements
        template <typename TArrayElem> void put_v_multiplicities(TArrayElem arr[], size_t n) { ListOfIntValue lst; ArrayToList(arr, n, lst); put_v_multiplicities(lst); }

        //TList may be list_of_parameter_value or list of converible elements
        template <typename TList> void get_u_knots(TList& lst) { list_of_parameter_valueSerializer<TList> sr; sr.FromAttr(lst, m_instance, "u_knots"); }

        //TList may be list_of_parameter_value or list of converible elements
        template <typename TList> void put_u_knots(TList& lst) { list_of_parameter_valueSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "u_knots"); }

        //TArrayElem[] may be parameter_value[] or array of convertible elements
        template <typename TArrayElem> void put_u_knots(TArrayElem arr[], size_t n) { list_of_parameter_value lst; ArrayToList(arr, n, lst); put_u_knots(lst); }

        //TList may be list_of_parameter_value or list of converible elements
        template <typename TList> void get_v_knots(TList& lst) { list_of_parameter_valueSerializer<TList> sr; sr.FromAttr(lst, m_instance, "v_knots"); }

        //TList may be list_of_parameter_value or list of converible elements
        template <typename TList> void put_v_knots(TList& lst) { list_of_parameter_valueSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "v_knots"); }

        //TArrayElem[] may be parameter_value[] or array of convertible elements
        template <typename TArrayElem> void put_v_knots(TArrayElem arr[], size_t n) { list_of_parameter_value lst; ArrayToList(arr, n, lst); put_v_knots(lst); }

        Nullable<knot_type> get_knot_spec() { int v = getENUM("knot_spec", knot_type_); if (v >= 0) return (knot_type) v; else return Nullable<knot_type>(); }
        void put_knot_spec(knot_type value) { TextValue val = knot_type_[(int) value]; sdaiPutAttrBN(m_instance, "knot_spec", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of volume
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class volume : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of volume
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        volume(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "volume")
        {}

                /// <summary>
                /// Create new instace of volume and returns object of this C++ class to interact with
                /// </summary>
        static volume Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "volume"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of b_spline_volume
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class b_spline_volume : public virtual volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of b_spline_volume
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        b_spline_volume(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "b_spline_volume")
        {}

                /// <summary>
                /// Create new instace of b_spline_volume and returns object of this C++ class to interact with
                /// </summary>
        static b_spline_volume Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "b_spline_volume"); assert(inst); return inst; }

        Nullable<IntValue> get_u_degree() { IntValue val = (IntValue) 0; if (sdaiGetAttrBN(m_instance, "u_degree", sdaiINTEGER, &val)) return val; else return Nullable<IntValue>(); }
        void put_u_degree(IntValue value) { sdaiPutAttrBN(m_instance, "u_degree", sdaiINTEGER, &value); }

        Nullable<IntValue> get_v_degree() { IntValue val = (IntValue) 0; if (sdaiGetAttrBN(m_instance, "v_degree", sdaiINTEGER, &val)) return val; else return Nullable<IntValue>(); }
        void put_v_degree(IntValue value) { sdaiPutAttrBN(m_instance, "v_degree", sdaiINTEGER, &value); }

        Nullable<IntValue> get_w_degree() { IntValue val = (IntValue) 0; if (sdaiGetAttrBN(m_instance, "w_degree", sdaiINTEGER, &val)) return val; else return Nullable<IntValue>(); }
        void put_w_degree(IntValue value) { sdaiPutAttrBN(m_instance, "w_degree", sdaiINTEGER, &value); }

        //TList may be list_of_list_of_list_of_cartesian_point or list of converible elements
        template <typename TList> void get_control_points_list(TList& lst) { list_of_list_of_list_of_cartesian_pointSerializer<TList> sr; sr.FromAttr(lst, m_instance, "control_points_list"); }

        //TList may be list_of_list_of_list_of_cartesian_point or list of converible elements
        template <typename TList> void put_control_points_list(TList& lst) { list_of_list_of_list_of_cartesian_pointSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "control_points_list"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of b_spline_volume_with_knots
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class b_spline_volume_with_knots : public virtual b_spline_volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of b_spline_volume_with_knots
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        b_spline_volume_with_knots(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "b_spline_volume_with_knots")
        {}

                /// <summary>
                /// Create new instace of b_spline_volume_with_knots and returns object of this C++ class to interact with
                /// </summary>
        static b_spline_volume_with_knots Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "b_spline_volume_with_knots"); assert(inst); return inst; }

        //TList may be ListOfIntValue or list of converible elements
        template <typename TList> void get_u_multiplicities(TList& lst) { ListOfIntValueSerializer<TList> sr; sr.FromAttr(lst, m_instance, "u_multiplicities"); }

        //TList may be ListOfIntValue or list of converible elements
        template <typename TList> void put_u_multiplicities(TList& lst) { ListOfIntValueSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "u_multiplicities"); }

        //TArrayElem[] may be IntValue[] or array of convertible elements
        template <typename TArrayElem> void put_u_multiplicities(TArrayElem arr[], size_t n) { ListOfIntValue lst; ArrayToList(arr, n, lst); put_u_multiplicities(lst); }

        //TList may be ListOfIntValue or list of converible elements
        template <typename TList> void get_v_multiplicities(TList& lst) { ListOfIntValueSerializer<TList> sr; sr.FromAttr(lst, m_instance, "v_multiplicities"); }

        //TList may be ListOfIntValue or list of converible elements
        template <typename TList> void put_v_multiplicities(TList& lst) { ListOfIntValueSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "v_multiplicities"); }

        //TArrayElem[] may be IntValue[] or array of convertible elements
        template <typename TArrayElem> void put_v_multiplicities(TArrayElem arr[], size_t n) { ListOfIntValue lst; ArrayToList(arr, n, lst); put_v_multiplicities(lst); }

        //TList may be ListOfIntValue or list of converible elements
        template <typename TList> void get_w_multiplicities(TList& lst) { ListOfIntValueSerializer<TList> sr; sr.FromAttr(lst, m_instance, "w_multiplicities"); }

        //TList may be ListOfIntValue or list of converible elements
        template <typename TList> void put_w_multiplicities(TList& lst) { ListOfIntValueSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "w_multiplicities"); }

        //TArrayElem[] may be IntValue[] or array of convertible elements
        template <typename TArrayElem> void put_w_multiplicities(TArrayElem arr[], size_t n) { ListOfIntValue lst; ArrayToList(arr, n, lst); put_w_multiplicities(lst); }

        //TList may be list_of_parameter_value or list of converible elements
        template <typename TList> void get_u_knots(TList& lst) { list_of_parameter_valueSerializer<TList> sr; sr.FromAttr(lst, m_instance, "u_knots"); }

        //TList may be list_of_parameter_value or list of converible elements
        template <typename TList> void put_u_knots(TList& lst) { list_of_parameter_valueSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "u_knots"); }

        //TArrayElem[] may be parameter_value[] or array of convertible elements
        template <typename TArrayElem> void put_u_knots(TArrayElem arr[], size_t n) { list_of_parameter_value lst; ArrayToList(arr, n, lst); put_u_knots(lst); }

        //TList may be list_of_parameter_value or list of converible elements
        template <typename TList> void get_v_knots(TList& lst) { list_of_parameter_valueSerializer<TList> sr; sr.FromAttr(lst, m_instance, "v_knots"); }

        //TList may be list_of_parameter_value or list of converible elements
        template <typename TList> void put_v_knots(TList& lst) { list_of_parameter_valueSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "v_knots"); }

        //TArrayElem[] may be parameter_value[] or array of convertible elements
        template <typename TArrayElem> void put_v_knots(TArrayElem arr[], size_t n) { list_of_parameter_value lst; ArrayToList(arr, n, lst); put_v_knots(lst); }

        //TList may be list_of_parameter_value or list of converible elements
        template <typename TList> void get_w_knots(TList& lst) { list_of_parameter_valueSerializer<TList> sr; sr.FromAttr(lst, m_instance, "w_knots"); }

        //TList may be list_of_parameter_value or list of converible elements
        template <typename TList> void put_w_knots(TList& lst) { list_of_parameter_valueSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "w_knots"); }

        //TArrayElem[] may be parameter_value[] or array of convertible elements
        template <typename TArrayElem> void put_w_knots(TArrayElem arr[], size_t n) { list_of_parameter_value lst; ArrayToList(arr, n, lst); put_w_knots(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of bend
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class bend : public virtual structural_frame_process
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of bend
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        bend(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "bend")
        {}

                /// <summary>
                /// Create new instace of bend and returns object of this C++ class to interact with
                /// </summary>
        static bend Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "bend"); assert(inst); return inst; }

        Nullable<bending_method> get_method() { int v = getENUM("method", bending_method_); if (v >= 0) return (bending_method) v; else return Nullable<bending_method>(); }
        void put_method(bending_method value) { TextValue val = bending_method_[(int) value]; sdaiPutAttrBN(m_instance, "method", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of bezier_curve
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class bezier_curve : public virtual b_spline_curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of bezier_curve
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        bezier_curve(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "bezier_curve")
        {}

                /// <summary>
                /// Create new instace of bezier_curve and returns object of this C++ class to interact with
                /// </summary>
        static bezier_curve Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "bezier_curve"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of bezier_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class bezier_surface : public virtual b_spline_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of bezier_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        bezier_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "bezier_surface")
        {}

                /// <summary>
                /// Create new instace of bezier_surface and returns object of this C++ class to interact with
                /// </summary>
        static bezier_surface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "bezier_surface"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of bezier_volume
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class bezier_volume : public virtual b_spline_volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of bezier_volume
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        bezier_volume(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "bezier_volume")
        {}

                /// <summary>
                /// Create new instace of bezier_volume and returns object of this C++ class to interact with
                /// </summary>
        static bezier_volume Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "bezier_volume"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of block
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class block : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of block
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        block(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "block")
        {}

                /// <summary>
                /// Create new instace of block and returns object of this C++ class to interact with
                /// </summary>
        static block Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "block"); assert(inst); return inst; }

        axis2_placement_3d get_position();
        void put_position(axis2_placement_3d inst);

        Nullable<positive_length_measure> get_x() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "x", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_x(positive_length_measure value) { sdaiPutAttrBN(m_instance, "x", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_y() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "y", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_y(positive_length_measure value) { sdaiPutAttrBN(m_instance, "y", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_z() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "z", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_z(positive_length_measure value) { sdaiPutAttrBN(m_instance, "z", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of block_volume
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class block_volume : public virtual volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of block_volume
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        block_volume(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "block_volume")
        {}

                /// <summary>
                /// Create new instace of block_volume and returns object of this C++ class to interact with
                /// </summary>
        static block_volume Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "block_volume"); assert(inst); return inst; }

        axis2_placement_3d get_position();
        void put_position(axis2_placement_3d inst);

        Nullable<positive_length_measure> get_x() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "x", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_x(positive_length_measure value) { sdaiPutAttrBN(m_instance, "x", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_y() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "y", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_y(positive_length_measure value) { sdaiPutAttrBN(m_instance, "y", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_z() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "z", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_z(positive_length_measure value) { sdaiPutAttrBN(m_instance, "z", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of boolean_result
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class boolean_result : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of boolean_result
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        boolean_result(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "boolean_result")
        {}

                /// <summary>
                /// Create new instace of boolean_result and returns object of this C++ class to interact with
                /// </summary>
        static boolean_result Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "boolean_result"); assert(inst); return inst; }

        Nullable<boolean_operator> get_operator_() { int v = getENUM("operator_", boolean_operator_); if (v >= 0) return (boolean_operator) v; else return Nullable<boolean_operator>(); }
        void put_operator_(boolean_operator value) { TextValue val = boolean_operator_[(int) value]; sdaiPutAttrBN(m_instance, "operator_", sdaiENUM, val); }

        boolean_operand_get get_first_operand() { return boolean_operand_get(m_instance, "first_operand", NULL); }
        boolean_operand_put put_first_operand() { return boolean_operand_put(m_instance, "first_operand", NULL); }

        boolean_operand_get get_second_operand() { return boolean_operand_get(m_instance, "second_operand", NULL); }
        boolean_operand_put put_second_operand() { return boolean_operand_put(m_instance, "second_operand", NULL); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of boundary_condition
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class boundary_condition : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of boundary_condition
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        boundary_condition(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "boundary_condition")
        {}


        label get_boundary_condition_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "boundary_condition_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_boundary_condition_name(label value) { sdaiPutAttrBN(m_instance, "boundary_condition_name", sdaiSTRING, value); }

        text get_boundary_condition_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "boundary_condition_description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_boundary_condition_description(text value) { sdaiPutAttrBN(m_instance, "boundary_condition_description", sdaiSTRING, value); }

        //TList may be set_of_node or list of converible elements
        template <typename TList> void get_restrained_nodes(TList& lst) { set_of_nodeSerializer<TList> sr; sr.FromAttr(lst, m_instance, "restrained_nodes"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of boundary_condition_logical
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class boundary_condition_logical : public virtual boundary_condition
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of boundary_condition_logical
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        boundary_condition_logical(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "boundary_condition_logical")
        {}

                /// <summary>
                /// Create new instace of boundary_condition_logical and returns object of this C++ class to interact with
                /// </summary>
        static boundary_condition_logical Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "boundary_condition_logical"); assert(inst); return inst; }

        Nullable<LOGICAL_VALUE> get_bc_x_displacement_free() { int v = getENUM("bc_x_displacement_free", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_bc_x_displacement_free(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "bc_x_displacement_free", sdaiENUM, val); }

        Nullable<LOGICAL_VALUE> get_bc_y_displacement_free() { int v = getENUM("bc_y_displacement_free", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_bc_y_displacement_free(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "bc_y_displacement_free", sdaiENUM, val); }

        Nullable<LOGICAL_VALUE> get_bc_z_displacement_free() { int v = getENUM("bc_z_displacement_free", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_bc_z_displacement_free(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "bc_z_displacement_free", sdaiENUM, val); }

        Nullable<LOGICAL_VALUE> get_bc_x_rotation_free() { int v = getENUM("bc_x_rotation_free", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_bc_x_rotation_free(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "bc_x_rotation_free", sdaiENUM, val); }

        Nullable<LOGICAL_VALUE> get_bc_y_rotation_free() { int v = getENUM("bc_y_rotation_free", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_bc_y_rotation_free(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "bc_y_rotation_free", sdaiENUM, val); }

        Nullable<LOGICAL_VALUE> get_bc_z_rotation_free() { int v = getENUM("bc_z_rotation_free", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_bc_z_rotation_free(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "bc_z_rotation_free", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of boundary_condition_skewed
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class boundary_condition_skewed : public virtual boundary_condition
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of boundary_condition_skewed
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        boundary_condition_skewed(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "boundary_condition_skewed")
        {}

                /// <summary>
                /// Create new instace of boundary_condition_skewed and returns object of this C++ class to interact with
                /// </summary>
        static boundary_condition_skewed Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "boundary_condition_skewed"); assert(inst); return inst; }

        plane_angle_measure_with_unit get_x_skew_angle();
        void put_x_skew_angle(plane_angle_measure_with_unit inst);

        plane_angle_measure_with_unit get_y_skew_angle();
        void put_y_skew_angle(plane_angle_measure_with_unit inst);

        plane_angle_measure_with_unit get_z_skew_angle();
        void put_z_skew_angle(plane_angle_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of boundary_condition_spring_linear
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class boundary_condition_spring_linear : public virtual boundary_condition
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of boundary_condition_spring_linear
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        boundary_condition_spring_linear(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "boundary_condition_spring_linear")
        {}

                /// <summary>
                /// Create new instace of boundary_condition_spring_linear and returns object of this C++ class to interact with
                /// </summary>
        static boundary_condition_spring_linear Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "boundary_condition_spring_linear"); assert(inst); return inst; }

        linear_stiffness_measure_with_unit get_bc_x_displacement();
        void put_bc_x_displacement(linear_stiffness_measure_with_unit inst);

        linear_stiffness_measure_with_unit get_bc_y_displacement();
        void put_bc_y_displacement(linear_stiffness_measure_with_unit inst);

        linear_stiffness_measure_with_unit get_bc_z_displacement();
        void put_bc_z_displacement(linear_stiffness_measure_with_unit inst);

        rotational_stiffness_measure_with_unit get_bc_x_rotation();
        void put_bc_x_rotation(rotational_stiffness_measure_with_unit inst);

        rotational_stiffness_measure_with_unit get_bc_y_rotation();
        void put_bc_y_rotation(rotational_stiffness_measure_with_unit inst);

        rotational_stiffness_measure_with_unit get_bc_z_rotation();
        void put_bc_z_rotation(rotational_stiffness_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of boundary_condition_spring_non_linear
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class boundary_condition_spring_non_linear : public virtual boundary_condition
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of boundary_condition_spring_non_linear
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        boundary_condition_spring_non_linear(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "boundary_condition_spring_non_linear")
        {}

                /// <summary>
                /// Create new instace of boundary_condition_spring_non_linear and returns object of this C++ class to interact with
                /// </summary>
        static boundary_condition_spring_non_linear Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "boundary_condition_spring_non_linear"); assert(inst); return inst; }

        //TList may be list_of_measure_with_unit or list of converible elements
        template <typename TList> void get_change_values(TList& lst) { list_of_measure_with_unitSerializer<TList> sr; sr.FromAttr(lst, m_instance, "change_values"); }

        //TList may be list_of_measure_with_unit or list of converible elements
        template <typename TList> void put_change_values(TList& lst) { list_of_measure_with_unitSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "change_values"); }

        //TArrayElem[] may be measure_with_unit[] or array of convertible elements
        template <typename TArrayElem> void put_change_values(TArrayElem arr[], size_t n) { list_of_measure_with_unit lst; ArrayToList(arr, n, lst); put_change_values(lst); }

        //TList may be list_of_boundary_condition_spring_linear or list of converible elements
        template <typename TList> void get_values(TList& lst) { list_of_boundary_condition_spring_linearSerializer<TList> sr; sr.FromAttr(lst, m_instance, "values"); }

        //TList may be list_of_boundary_condition_spring_linear or list of converible elements
        template <typename TList> void put_values(TList& lst) { list_of_boundary_condition_spring_linearSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "values"); }

        //TArrayElem[] may be boundary_condition_spring_linear[] or array of convertible elements
        template <typename TArrayElem> void put_values(TArrayElem arr[], size_t n) { list_of_boundary_condition_spring_linear lst; ArrayToList(arr, n, lst); put_values(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of boundary_condition_warping
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class boundary_condition_warping : public virtual boundary_condition_spring_linear
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of boundary_condition_warping
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        boundary_condition_warping(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "boundary_condition_warping")
        {}

                /// <summary>
                /// Create new instace of boundary_condition_warping and returns object of this C++ class to interact with
                /// </summary>
        static boundary_condition_warping Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "boundary_condition_warping"); assert(inst); return inst; }

        rotational_stiffness_measure_with_unit get_bc_warping();
        void put_bc_warping(rotational_stiffness_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of composite_curve
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class composite_curve : public virtual bounded_curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of composite_curve
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        composite_curve(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "composite_curve")
        {}

                /// <summary>
                /// Create new instace of composite_curve and returns object of this C++ class to interact with
                /// </summary>
        static composite_curve Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "composite_curve"); assert(inst); return inst; }

        //TList may be list_of_composite_curve_segment or list of converible elements
        template <typename TList> void get_segments(TList& lst) { list_of_composite_curve_segmentSerializer<TList> sr; sr.FromAttr(lst, m_instance, "segments"); }

        //TList may be list_of_composite_curve_segment or list of converible elements
        template <typename TList> void put_segments(TList& lst) { list_of_composite_curve_segmentSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "segments"); }

        //TArrayElem[] may be composite_curve_segment[] or array of convertible elements
        template <typename TArrayElem> void put_segments(TArrayElem arr[], size_t n) { list_of_composite_curve_segment lst; ArrayToList(arr, n, lst); put_segments(lst); }

        Nullable<LOGICAL_VALUE> get_self_intersect() { int v = getENUM("self_intersect", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_self_intersect(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "self_intersect", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of composite_curve_on_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class composite_curve_on_surface : public virtual composite_curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of composite_curve_on_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        composite_curve_on_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "composite_curve_on_surface")
        {}

                /// <summary>
                /// Create new instace of composite_curve_on_surface and returns object of this C++ class to interact with
                /// </summary>
        static composite_curve_on_surface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "composite_curve_on_surface"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of boundary_curve
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class boundary_curve : public virtual composite_curve_on_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of boundary_curve
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        boundary_curve(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "boundary_curve")
        {}

                /// <summary>
                /// Create new instace of boundary_curve and returns object of this C++ class to interact with
                /// </summary>
        static boundary_curve Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "boundary_curve"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of pcurve
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class pcurve : public virtual curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of pcurve
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        pcurve(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "pcurve")
        {}

                /// <summary>
                /// Create new instace of pcurve and returns object of this C++ class to interact with
                /// </summary>
        static pcurve Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "pcurve"); assert(inst); return inst; }

        surface get_basis_surface();
        void put_basis_surface(surface inst);

        definitional_representation get_reference_to_curve();
        void put_reference_to_curve(definitional_representation inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of bounded_pcurve
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class bounded_pcurve : public virtual pcurve, public virtual bounded_curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of bounded_pcurve
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        bounded_pcurve(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "bounded_pcurve")
        {}

                /// <summary>
                /// Create new instace of bounded_pcurve and returns object of this C++ class to interact with
                /// </summary>
        static bounded_pcurve Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "bounded_pcurve"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of surface_curve
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class surface_curve : public virtual curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of surface_curve
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        surface_curve(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "surface_curve")
        {}

                /// <summary>
                /// Create new instace of surface_curve and returns object of this C++ class to interact with
                /// </summary>
        static surface_curve Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "surface_curve"); assert(inst); return inst; }

        curve get_curve_3d();
        void put_curve_3d(curve inst);

        //TList may be list_of_pcurve_or_surface or list of converible elements
        template <typename TList> void get_associated_geometry(TList& lst) { list_of_pcurve_or_surfaceSerializer<TList> sr; sr.FromAttr(lst, m_instance, "associated_geometry"); }

        //TList may be list_of_pcurve_or_surface or list of converible elements
        template <typename TList> void put_associated_geometry(TList& lst) { list_of_pcurve_or_surfaceSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "associated_geometry"); }

        Nullable<preferred_surface_curve_representation> get_master_representation() { int v = getENUM("master_representation", preferred_surface_curve_representation_); if (v >= 0) return (preferred_surface_curve_representation) v; else return Nullable<preferred_surface_curve_representation>(); }
        void put_master_representation(preferred_surface_curve_representation value) { TextValue val = preferred_surface_curve_representation_[(int) value]; sdaiPutAttrBN(m_instance, "master_representation", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of bounded_surface_curve
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class bounded_surface_curve : public virtual surface_curve, public virtual bounded_curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of bounded_surface_curve
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        bounded_surface_curve(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "bounded_surface_curve")
        {}

                /// <summary>
                /// Create new instace of bounded_surface_curve and returns object of this C++ class to interact with
                /// </summary>
        static bounded_surface_curve Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "bounded_surface_curve"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of box_domain
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class box_domain : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of box_domain
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        box_domain(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "box_domain")
        {}

                /// <summary>
                /// Create new instace of box_domain and returns object of this C++ class to interact with
                /// </summary>
        static box_domain Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "box_domain"); assert(inst); return inst; }

        cartesian_point get_corner();
        void put_corner(cartesian_point inst);

        Nullable<positive_length_measure> get_xlength() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "xlength", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_xlength(positive_length_measure value) { sdaiPutAttrBN(m_instance, "xlength", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_ylength() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "ylength", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_ylength(positive_length_measure value) { sdaiPutAttrBN(m_instance, "ylength", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_zlength() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "zlength", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_zlength(positive_length_measure value) { sdaiPutAttrBN(m_instance, "zlength", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of half_space_solid
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class half_space_solid : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of half_space_solid
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        half_space_solid(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "half_space_solid")
        {}

                /// <summary>
                /// Create new instace of half_space_solid and returns object of this C++ class to interact with
                /// </summary>
        static half_space_solid Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "half_space_solid"); assert(inst); return inst; }

        surface get_base_surface();
        void put_base_surface(surface inst);

        Nullable<bool> get_agreement_flag() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "agreement_flag", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_agreement_flag(bool value) { sdaiPutAttrBN(m_instance, "agreement_flag", sdaiBOOLEAN, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of boxed_half_space
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class boxed_half_space : public virtual half_space_solid
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of boxed_half_space
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        boxed_half_space(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "boxed_half_space")
        {}

                /// <summary>
                /// Create new instace of boxed_half_space and returns object of this C++ class to interact with
                /// </summary>
        static boxed_half_space Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "boxed_half_space"); assert(inst); return inst; }

        box_domain get_enclosure();
        void put_enclosure(box_domain inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of braze
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class braze : public virtual structural_frame_process
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of braze
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        braze(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "braze")
        {}

                /// <summary>
                /// Create new instace of braze and returns object of this C++ class to interact with
                /// </summary>
        static braze Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "braze"); assert(inst); return inst; }

        Nullable<brazing_type> get_braze_type() { int v = getENUM("braze_type", brazing_type_); if (v >= 0) return (brazing_type) v; else return Nullable<brazing_type>(); }
        void put_braze_type(brazing_type value) { TextValue val = brazing_type_[(int) value]; sdaiPutAttrBN(m_instance, "braze_type", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of solid_model
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class solid_model : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of solid_model
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        solid_model(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "solid_model")
        {}

                /// <summary>
                /// Create new instace of solid_model and returns object of this C++ class to interact with
                /// </summary>
        static solid_model Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "solid_model"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of brep_2d
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class brep_2d : public virtual solid_model
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of brep_2d
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        brep_2d(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "brep_2d")
        {}

                /// <summary>
                /// Create new instace of brep_2d and returns object of this C++ class to interact with
                /// </summary>
        static brep_2d Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "brep_2d"); assert(inst); return inst; }

        face get_extent();
        void put_extent(face inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of manifold_solid_brep
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class manifold_solid_brep : public virtual solid_model
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of manifold_solid_brep
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        manifold_solid_brep(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "manifold_solid_brep")
        {}

                /// <summary>
                /// Create new instace of manifold_solid_brep and returns object of this C++ class to interact with
                /// </summary>
        static manifold_solid_brep Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "manifold_solid_brep"); assert(inst); return inst; }

        closed_shell get_outer();
        void put_outer(closed_shell inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of brep_with_voids
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class brep_with_voids : public virtual manifold_solid_brep
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of brep_with_voids
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        brep_with_voids(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "brep_with_voids")
        {}

                /// <summary>
                /// Create new instace of brep_with_voids and returns object of this C++ class to interact with
                /// </summary>
        static brep_with_voids Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "brep_with_voids"); assert(inst); return inst; }

        //TList may be set_of_oriented_closed_shell or list of converible elements
        template <typename TList> void get_voids(TList& lst) { set_of_oriented_closed_shellSerializer<TList> sr; sr.FromAttr(lst, m_instance, "voids"); }

        //TList may be set_of_oriented_closed_shell or list of converible elements
        template <typename TList> void put_voids(TList& lst) { set_of_oriented_closed_shellSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "voids"); }

        //TArrayElem[] may be oriented_closed_shell[] or array of convertible elements
        template <typename TArrayElem> void put_voids(TArrayElem arr[], size_t n) { set_of_oriented_closed_shell lst; ArrayToList(arr, n, lst); put_voids(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of building
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class building : public virtual structural_frame_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of building
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        building(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "building")
        {}

                /// <summary>
                /// Create new instace of building and returns object of this C++ class to interact with
                /// </summary>
        static building Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "building"); assert(inst); return inst; }

        label get_building_class() { label val = NULL; if (sdaiGetAttrBN(m_instance, "building_class", sdaiSTRING, &val)) return val; else return NULL; }
        void put_building_class(label value) { sdaiPutAttrBN(m_instance, "building_class", sdaiSTRING, value); }

        person_and_organization get_owner();
        void put_owner(person_and_organization inst);

        //TList may be list_of_structure or list of converible elements
        template <typename TList> void get_building_structures(TList& lst) { list_of_structureSerializer<TList> sr; sr.FromAttr(lst, m_instance, "building_structures"); }

        //TList may be list_of_structure or list of converible elements
        template <typename TList> void put_building_structures(TList& lst) { list_of_structureSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "building_structures"); }

        //TArrayElem[] may be structure[] or array of convertible elements
        template <typename TArrayElem> void put_building_structures(TArrayElem arr[], size_t n) { list_of_structure lst; ArrayToList(arr, n, lst); put_building_structures(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of building_complex
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class building_complex : public virtual structural_frame_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of building_complex
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        building_complex(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "building_complex")
        {}

                /// <summary>
                /// Create new instace of building_complex and returns object of this C++ class to interact with
                /// </summary>
        static building_complex Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "building_complex"); assert(inst); return inst; }

        site get_building_site();
        void put_building_site(site inst);

        //TList may be list_of_building or list of converible elements
        template <typename TList> void get_buildings(TList& lst) { list_of_buildingSerializer<TList> sr; sr.FromAttr(lst, m_instance, "buildings"); }

        //TList may be list_of_building or list of converible elements
        template <typename TList> void put_buildings(TList& lst) { list_of_buildingSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "buildings"); }

        //TArrayElem[] may be building[] or array of convertible elements
        template <typename TArrayElem> void put_buildings(TArrayElem arr[], size_t n) { list_of_building lst; ArrayToList(arr, n, lst); put_buildings(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of building_with_shape
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class building_with_shape : public virtual building
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of building_with_shape
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        building_with_shape(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "building_with_shape")
        {}

                /// <summary>
                /// Create new instace of building_with_shape and returns object of this C++ class to interact with
                /// </summary>
        static building_with_shape Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "building_with_shape"); assert(inst); return inst; }

        shape_representation_with_units get_shape();
        void put_shape(shape_representation_with_units inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of date
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class date : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of date
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        date(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "date")
        {}

                /// <summary>
                /// Create new instace of date and returns object of this C++ class to interact with
                /// </summary>
        static date Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "date"); assert(inst); return inst; }

        Nullable<year_number> get_year_component() { year_number val = (year_number) 0; if (sdaiGetAttrBN(m_instance, "year_component", sdaiINTEGER, &val)) return val; else return Nullable<year_number>(); }
        void put_year_component(year_number value) { sdaiPutAttrBN(m_instance, "year_component", sdaiINTEGER, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of calendar_date
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class calendar_date : public virtual date
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of calendar_date
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        calendar_date(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "calendar_date")
        {}

                /// <summary>
                /// Create new instace of calendar_date and returns object of this C++ class to interact with
                /// </summary>
        static calendar_date Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "calendar_date"); assert(inst); return inst; }

        Nullable<day_in_month_number> get_day_component() { day_in_month_number val = (day_in_month_number) 0; if (sdaiGetAttrBN(m_instance, "day_component", sdaiINTEGER, &val)) return val; else return Nullable<day_in_month_number>(); }
        void put_day_component(day_in_month_number value) { sdaiPutAttrBN(m_instance, "day_component", sdaiINTEGER, &value); }

        Nullable<month_in_year_number> get_month_component() { month_in_year_number val = (month_in_year_number) 0; if (sdaiGetAttrBN(m_instance, "month_component", sdaiINTEGER, &val)) return val; else return Nullable<month_in_year_number>(); }
        void put_month_component(month_in_year_number value) { sdaiPutAttrBN(m_instance, "month_component", sdaiINTEGER, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of point
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class point : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of point
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        point(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "point")
        {}

                /// <summary>
                /// Create new instace of point and returns object of this C++ class to interact with
                /// </summary>
        static point Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "point"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of cartesian_point
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class cartesian_point : public virtual point
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of cartesian_point
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        cartesian_point(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "cartesian_point")
        {}

                /// <summary>
                /// Create new instace of cartesian_point and returns object of this C++ class to interact with
                /// </summary>
        static cartesian_point Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "cartesian_point"); assert(inst); return inst; }

        //TList may be list_of_length_measure or list of converible elements
        template <typename TList> void get_coordinates(TList& lst) { list_of_length_measureSerializer<TList> sr; sr.FromAttr(lst, m_instance, "coordinates"); }

        //TList may be list_of_length_measure or list of converible elements
        template <typename TList> void put_coordinates(TList& lst) { list_of_length_measureSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "coordinates"); }

        //TArrayElem[] may be length_measure[] or array of convertible elements
        template <typename TArrayElem> void put_coordinates(TArrayElem arr[], size_t n) { list_of_length_measure lst; ArrayToList(arr, n, lst); put_coordinates(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of functionally_defined_transformation
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class functionally_defined_transformation : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of functionally_defined_transformation
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        functionally_defined_transformation(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "functionally_defined_transformation")
        {}

                /// <summary>
                /// Create new instace of functionally_defined_transformation and returns object of this C++ class to interact with
                /// </summary>
        static functionally_defined_transformation Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "functionally_defined_transformation"); assert(inst); return inst; }

        label get_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_name(label value) { sdaiPutAttrBN(m_instance, "name", sdaiSTRING, value); }

        text get_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_description(text value) { sdaiPutAttrBN(m_instance, "description", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of cartesian_transformation_operator
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class cartesian_transformation_operator : public virtual geometric_representation_item, public virtual functionally_defined_transformation
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of cartesian_transformation_operator
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        cartesian_transformation_operator(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "cartesian_transformation_operator")
        {}

                /// <summary>
                /// Create new instace of cartesian_transformation_operator and returns object of this C++ class to interact with
                /// </summary>
        static cartesian_transformation_operator Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "cartesian_transformation_operator"); assert(inst); return inst; }

        direction get_axis1();
        void put_axis1(direction inst);

        direction get_axis2();
        void put_axis2(direction inst);

        cartesian_point get_local_origin();
        void put_local_origin(cartesian_point inst);

        Nullable<double> get_scale() { double val = (double) 0; if (sdaiGetAttrBN(m_instance, "scale", sdaiREAL, &val)) return val; else return Nullable<double>(); }
        void put_scale(double value) { sdaiPutAttrBN(m_instance, "scale", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of cartesian_transformation_operator_2d
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class cartesian_transformation_operator_2d : public virtual cartesian_transformation_operator
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of cartesian_transformation_operator_2d
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        cartesian_transformation_operator_2d(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "cartesian_transformation_operator_2d")
        {}

                /// <summary>
                /// Create new instace of cartesian_transformation_operator_2d and returns object of this C++ class to interact with
                /// </summary>
        static cartesian_transformation_operator_2d Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "cartesian_transformation_operator_2d"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of cartesian_transformation_operator_3d
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class cartesian_transformation_operator_3d : public virtual cartesian_transformation_operator
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of cartesian_transformation_operator_3d
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        cartesian_transformation_operator_3d(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "cartesian_transformation_operator_3d")
        {}

                /// <summary>
                /// Create new instace of cartesian_transformation_operator_3d and returns object of this C++ class to interact with
                /// </summary>
        static cartesian_transformation_operator_3d Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "cartesian_transformation_operator_3d"); assert(inst); return inst; }

        direction get_axis3();
        void put_axis3(direction inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of certification
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class certification : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of certification
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        certification(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "certification")
        {}

                /// <summary>
                /// Create new instace of certification and returns object of this C++ class to interact with
                /// </summary>
        static certification Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "certification"); assert(inst); return inst; }

        label get_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_name(label value) { sdaiPutAttrBN(m_instance, "name", sdaiSTRING, value); }

        label get_purpose() { label val = NULL; if (sdaiGetAttrBN(m_instance, "purpose", sdaiSTRING, &val)) return val; else return NULL; }
        void put_purpose(label value) { sdaiPutAttrBN(m_instance, "purpose", sdaiSTRING, value); }

        certification_type get_kind();
        void put_kind(certification_type inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of certification_type
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class certification_type : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of certification_type
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        certification_type(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "certification_type")
        {}

                /// <summary>
                /// Create new instace of certification_type and returns object of this C++ class to interact with
                /// </summary>
        static certification_type Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "certification_type"); assert(inst); return inst; }

        text get_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_description(text value) { sdaiPutAttrBN(m_instance, "description", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of chemical_mechanism
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class chemical_mechanism : public virtual structural_frame_product
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of chemical_mechanism
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        chemical_mechanism(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "chemical_mechanism")
        {}

                /// <summary>
                /// Create new instace of chemical_mechanism and returns object of this C++ class to interact with
                /// </summary>
        static chemical_mechanism Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "chemical_mechanism"); assert(inst); return inst; }

        positive_length_measure_with_unit get_layer_thickness();
        void put_layer_thickness(positive_length_measure_with_unit inst);

        pressure_measure_with_unit get_layer_design_strength();
        void put_layer_design_strength(pressure_measure_with_unit inst);

        Nullable<chemical_mechanism_type> get_layer_type() { int v = getENUM("layer_type", chemical_mechanism_type_); if (v >= 0) return (chemical_mechanism_type) v; else return Nullable<chemical_mechanism_type>(); }
        void put_layer_type(chemical_mechanism_type value) { TextValue val = chemical_mechanism_type_[(int) value]; sdaiPutAttrBN(m_instance, "layer_type", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of conic
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class conic : public virtual curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of conic
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        conic(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "conic")
        {}

                /// <summary>
                /// Create new instace of conic and returns object of this C++ class to interact with
                /// </summary>
        static conic Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "conic"); assert(inst); return inst; }

        axis2_placement_get get_position() { return axis2_placement_get(m_instance, "position", NULL); }
        axis2_placement_put put_position() { return axis2_placement_put(m_instance, "position", NULL); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of circle
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class circle : public virtual conic
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of circle
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        circle(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "circle")
        {}

                /// <summary>
                /// Create new instace of circle and returns object of this C++ class to interact with
                /// </summary>
        static circle Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "circle"); assert(inst); return inst; }

        Nullable<positive_length_measure> get_radius() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "radius", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_radius(positive_length_measure value) { sdaiPutAttrBN(m_instance, "radius", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of primitive_2d
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class primitive_2d : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of primitive_2d
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        primitive_2d(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "primitive_2d")
        {}

                /// <summary>
                /// Create new instace of primitive_2d and returns object of this C++ class to interact with
                /// </summary>
        static primitive_2d Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "primitive_2d"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of circular_area
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class circular_area : public virtual primitive_2d
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of circular_area
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        circular_area(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "circular_area")
        {}

                /// <summary>
                /// Create new instace of circular_area and returns object of this C++ class to interact with
                /// </summary>
        static circular_area Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "circular_area"); assert(inst); return inst; }

        cartesian_point get_centre();
        void put_centre(cartesian_point inst);

        Nullable<positive_length_measure> get_radius() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "radius", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_radius(positive_length_measure value) { sdaiPutAttrBN(m_instance, "radius", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of topological_representation_item
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class topological_representation_item : public virtual representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of topological_representation_item
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        topological_representation_item(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "topological_representation_item")
        {}

                /// <summary>
                /// Create new instace of topological_representation_item and returns object of this C++ class to interact with
                /// </summary>
        static topological_representation_item Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "topological_representation_item"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of connected_face_set
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class connected_face_set : public virtual topological_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of connected_face_set
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        connected_face_set(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "connected_face_set")
        {}

                /// <summary>
                /// Create new instace of connected_face_set and returns object of this C++ class to interact with
                /// </summary>
        static connected_face_set Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "connected_face_set"); assert(inst); return inst; }

        //TList may be set_of_face or list of converible elements
        template <typename TList> void get_cfs_faces(TList& lst) { set_of_faceSerializer<TList> sr; sr.FromAttr(lst, m_instance, "cfs_faces"); }

        //TList may be set_of_face or list of converible elements
        template <typename TList> void put_cfs_faces(TList& lst) { set_of_faceSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "cfs_faces"); }

        //TArrayElem[] may be face[] or array of convertible elements
        template <typename TArrayElem> void put_cfs_faces(TArrayElem arr[], size_t n) { set_of_face lst; ArrayToList(arr, n, lst); put_cfs_faces(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of closed_shell
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class closed_shell : public virtual connected_face_set
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of closed_shell
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        closed_shell(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "closed_shell")
        {}

                /// <summary>
                /// Create new instace of closed_shell and returns object of this C++ class to interact with
                /// </summary>
        static closed_shell Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "closed_shell"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of clothoid
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class clothoid : public virtual curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of clothoid
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        clothoid(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "clothoid")
        {}

                /// <summary>
                /// Create new instace of clothoid and returns object of this C++ class to interact with
                /// </summary>
        static clothoid Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "clothoid"); assert(inst); return inst; }

        axis2_placement_get get_position() { return axis2_placement_get(m_instance, "position", NULL); }
        axis2_placement_put put_position() { return axis2_placement_put(m_instance, "position", NULL); }

        Nullable<length_measure> get_clothoid_constant() { length_measure val = (length_measure) 0; if (sdaiGetAttrBN(m_instance, "clothoid_constant", sdaiREAL, &val)) return val; else return Nullable<length_measure>(); }
        void put_clothoid_constant(length_measure value) { sdaiPutAttrBN(m_instance, "clothoid_constant", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of coating
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class coating : public virtual structural_frame_product
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of coating
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        coating(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "coating")
        {}

                /// <summary>
                /// Create new instace of coating and returns object of this C++ class to interact with
                /// </summary>
        static coating Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "coating"); assert(inst); return inst; }

        Nullable<coating_purpose> get_primary_purpose() { int v = getENUM("primary_purpose", coating_purpose_); if (v >= 0) return (coating_purpose) v; else return Nullable<coating_purpose>(); }
        void put_primary_purpose(coating_purpose value) { TextValue val = coating_purpose_[(int) value]; sdaiPutAttrBN(m_instance, "primary_purpose", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of founded_item
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class founded_item : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of founded_item
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        founded_item(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "founded_item")
        {}

                /// <summary>
                /// Create new instace of founded_item and returns object of this C++ class to interact with
                /// </summary>
        static founded_item Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "founded_item"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of composite_curve_segment
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class composite_curve_segment : public virtual founded_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of composite_curve_segment
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        composite_curve_segment(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "composite_curve_segment")
        {}

                /// <summary>
                /// Create new instace of composite_curve_segment and returns object of this C++ class to interact with
                /// </summary>
        static composite_curve_segment Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "composite_curve_segment"); assert(inst); return inst; }

        Nullable<transition_code> get_transition() { int v = getENUM("transition", transition_code_); if (v >= 0) return (transition_code) v; else return Nullable<transition_code>(); }
        void put_transition(transition_code value) { TextValue val = transition_code_[(int) value]; sdaiPutAttrBN(m_instance, "transition", sdaiENUM, val); }

        Nullable<bool> get_same_sense() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "same_sense", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_same_sense(bool value) { sdaiPutAttrBN(m_instance, "same_sense", sdaiBOOLEAN, &value); }

        curve get_parent_curve();
        void put_parent_curve(curve inst);

        //TList may be bag_of_composite_curve or list of converible elements
        template <typename TList> void get_using_curves(TList& lst) { bag_of_composite_curveSerializer<TList> sr; sr.FromAttr(lst, m_instance, "using_curves"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of elementary_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class elementary_surface : public virtual surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of elementary_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        elementary_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "elementary_surface")
        {}

                /// <summary>
                /// Create new instace of elementary_surface and returns object of this C++ class to interact with
                /// </summary>
        static elementary_surface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "elementary_surface"); assert(inst); return inst; }

        axis2_placement_3d get_position();
        void put_position(axis2_placement_3d inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of conical_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class conical_surface : public virtual elementary_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of conical_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        conical_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "conical_surface")
        {}

                /// <summary>
                /// Create new instace of conical_surface and returns object of this C++ class to interact with
                /// </summary>
        static conical_surface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "conical_surface"); assert(inst); return inst; }

        Nullable<length_measure> get_radius() { length_measure val = (length_measure) 0; if (sdaiGetAttrBN(m_instance, "radius", sdaiREAL, &val)) return val; else return Nullable<length_measure>(); }
        void put_radius(length_measure value) { sdaiPutAttrBN(m_instance, "radius", sdaiREAL, &value); }

        Nullable<plane_angle_measure> get_semi_angle() { plane_angle_measure val = (plane_angle_measure) 0; if (sdaiGetAttrBN(m_instance, "semi_angle", sdaiREAL, &val)) return val; else return Nullable<plane_angle_measure>(); }
        void put_semi_angle(plane_angle_measure value) { sdaiPutAttrBN(m_instance, "semi_angle", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of connected_edge_set
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class connected_edge_set : public virtual topological_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of connected_edge_set
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        connected_edge_set(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "connected_edge_set")
        {}

                /// <summary>
                /// Create new instace of connected_edge_set and returns object of this C++ class to interact with
                /// </summary>
        static connected_edge_set Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "connected_edge_set"); assert(inst); return inst; }

        //TList may be set_of_edge or list of converible elements
        template <typename TList> void get_ces_edges(TList& lst) { set_of_edgeSerializer<TList> sr; sr.FromAttr(lst, m_instance, "ces_edges"); }

        //TList may be set_of_edge or list of converible elements
        template <typename TList> void put_ces_edges(TList& lst) { set_of_edgeSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "ces_edges"); }

        //TArrayElem[] may be edge[] or array of convertible elements
        template <typename TArrayElem> void put_ces_edges(TArrayElem arr[], size_t n) { set_of_edge lst; ArrayToList(arr, n, lst); put_ces_edges(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of context_dependent_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class context_dependent_unit : public virtual named_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of context_dependent_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        context_dependent_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "context_dependent_unit")
        {}

                /// <summary>
                /// Create new instace of context_dependent_unit and returns object of this C++ class to interact with
                /// </summary>
        static context_dependent_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "context_dependent_unit"); assert(inst); return inst; }

        label get_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_name(label value) { sdaiPutAttrBN(m_instance, "name", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of contract
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class contract : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of contract
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        contract(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "contract")
        {}

                /// <summary>
                /// Create new instace of contract and returns object of this C++ class to interact with
                /// </summary>
        static contract Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "contract"); assert(inst); return inst; }

        label get_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_name(label value) { sdaiPutAttrBN(m_instance, "name", sdaiSTRING, value); }

        label get_purpose() { label val = NULL; if (sdaiGetAttrBN(m_instance, "purpose", sdaiSTRING, &val)) return val; else return NULL; }
        void put_purpose(label value) { sdaiPutAttrBN(m_instance, "purpose", sdaiSTRING, value); }

        contract_type get_kind();
        void put_kind(contract_type inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of contract_type
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class contract_type : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of contract_type
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        contract_type(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "contract_type")
        {}

                /// <summary>
                /// Create new instace of contract_type and returns object of this C++ class to interact with
                /// </summary>
        static contract_type Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "contract_type"); assert(inst); return inst; }

        text get_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_description(text value) { sdaiPutAttrBN(m_instance, "description", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of conversion_based_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class conversion_based_unit : public virtual named_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of conversion_based_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        conversion_based_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "conversion_based_unit")
        {}

                /// <summary>
                /// Create new instace of conversion_based_unit and returns object of this C++ class to interact with
                /// </summary>
        static conversion_based_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "conversion_based_unit"); assert(inst); return inst; }

        label get_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_name(label value) { sdaiPutAttrBN(m_instance, "name", sdaiSTRING, value); }

        measure_with_unit get_conversion_factor();
        void put_conversion_factor(measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of faceted_primitive
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class faceted_primitive : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of faceted_primitive
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        faceted_primitive(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "faceted_primitive")
        {}

                /// <summary>
                /// Create new instace of faceted_primitive and returns object of this C++ class to interact with
                /// </summary>
        static faceted_primitive Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "faceted_primitive"); assert(inst); return inst; }

        //TList may be list_of_cartesian_point or list of converible elements
        template <typename TList> void get_points(TList& lst) { list_of_cartesian_pointSerializer<TList> sr; sr.FromAttr(lst, m_instance, "points"); }

        //TList may be list_of_cartesian_point or list of converible elements
        template <typename TList> void put_points(TList& lst) { list_of_cartesian_pointSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "points"); }

        //TArrayElem[] may be cartesian_point[] or array of convertible elements
        template <typename TArrayElem> void put_points(TArrayElem arr[], size_t n) { list_of_cartesian_point lst; ArrayToList(arr, n, lst); put_points(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of convex_hexahedron
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class convex_hexahedron : public virtual faceted_primitive
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of convex_hexahedron
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        convex_hexahedron(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "convex_hexahedron")
        {}

                /// <summary>
                /// Create new instace of convex_hexahedron and returns object of this C++ class to interact with
                /// </summary>
        static convex_hexahedron Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "convex_hexahedron"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of coord_system
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class coord_system : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of coord_system
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        coord_system(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "coord_system")
        {}


        label get_coord_system_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "coord_system_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_coord_system_name(label value) { sdaiPutAttrBN(m_instance, "coord_system_name", sdaiSTRING, value); }

        label get_coord_system_use() { label val = NULL; if (sdaiGetAttrBN(m_instance, "coord_system_use", sdaiSTRING, &val)) return val; else return NULL; }
        void put_coord_system_use(label value) { sdaiPutAttrBN(m_instance, "coord_system_use", sdaiSTRING, value); }

        text get_sign_convention() { text val = NULL; if (sdaiGetAttrBN(m_instance, "sign_convention", sdaiSTRING, &val)) return val; else return NULL; }
        void put_sign_convention(text value) { sdaiPutAttrBN(m_instance, "sign_convention", sdaiSTRING, value); }

        Nullable<dimension_count> get_coord_system_dimensionality() { dimension_count val = (dimension_count) 0; if (sdaiGetAttrBN(m_instance, "coord_system_dimensionality", sdaiINTEGER, &val)) return val; else return Nullable<dimension_count>(); }
        void put_coord_system_dimensionality(dimension_count value) { sdaiPutAttrBN(m_instance, "coord_system_dimensionality", sdaiINTEGER, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of coord_system_cartesian_2d
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class coord_system_cartesian_2d : public virtual coord_system
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of coord_system_cartesian_2d
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        coord_system_cartesian_2d(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "coord_system_cartesian_2d")
        {}

                /// <summary>
                /// Create new instace of coord_system_cartesian_2d and returns object of this C++ class to interact with
                /// </summary>
        static coord_system_cartesian_2d Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "coord_system_cartesian_2d"); assert(inst); return inst; }

        axis2_placement_2d get_axes_definition();
        void put_axes_definition(axis2_placement_2d inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of coord_system_cartesian_3d
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class coord_system_cartesian_3d : public virtual coord_system
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of coord_system_cartesian_3d
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        coord_system_cartesian_3d(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "coord_system_cartesian_3d")
        {}

                /// <summary>
                /// Create new instace of coord_system_cartesian_3d and returns object of this C++ class to interact with
                /// </summary>
        static coord_system_cartesian_3d Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "coord_system_cartesian_3d"); assert(inst); return inst; }

        axis2_placement_3d get_axes_definition();
        void put_axes_definition(axis2_placement_3d inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of coord_system_child
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class coord_system_child : public virtual coord_system
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of coord_system_child
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        coord_system_child(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "coord_system_child")
        {}

                /// <summary>
                /// Create new instace of coord_system_child and returns object of this C++ class to interact with
                /// </summary>
        static coord_system_child Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "coord_system_child"); assert(inst); return inst; }

        coord_system get_parent_coord_system();
        void put_parent_coord_system(coord_system inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of coord_system_cylindrical
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class coord_system_cylindrical : public virtual coord_system
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of coord_system_cylindrical
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        coord_system_cylindrical(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "coord_system_cylindrical")
        {}

                /// <summary>
                /// Create new instace of coord_system_cylindrical and returns object of this C++ class to interact with
                /// </summary>
        static coord_system_cylindrical Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "coord_system_cylindrical"); assert(inst); return inst; }

        cylindrical_point get_origin();
        void put_origin(cylindrical_point inst);

        //TList may be list_of_direction or list of converible elements
        template <typename TList> void get_axes_definition(TList& lst) { list_of_directionSerializer<TList> sr; sr.FromAttr(lst, m_instance, "axes_definition"); }

        //TList may be list_of_direction or list of converible elements
        template <typename TList> void put_axes_definition(TList& lst) { list_of_directionSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "axes_definition"); }

        //TArrayElem[] may be direction[] or array of convertible elements
        template <typename TArrayElem> void put_axes_definition(TArrayElem arr[], size_t n) { list_of_direction lst; ArrayToList(arr, n, lst); put_axes_definition(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of coord_system_spherical
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class coord_system_spherical : public virtual coord_system
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of coord_system_spherical
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        coord_system_spherical(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "coord_system_spherical")
        {}

                /// <summary>
                /// Create new instace of coord_system_spherical and returns object of this C++ class to interact with
                /// </summary>
        static coord_system_spherical Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "coord_system_spherical"); assert(inst); return inst; }

        spherical_point get_origin();
        void put_origin(spherical_point inst);

        //TList may be list_of_direction or list of converible elements
        template <typename TList> void get_axes_definition(TList& lst) { list_of_directionSerializer<TList> sr; sr.FromAttr(lst, m_instance, "axes_definition"); }

        //TList may be list_of_direction or list of converible elements
        template <typename TList> void put_axes_definition(TList& lst) { list_of_directionSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "axes_definition"); }

        //TArrayElem[] may be direction[] or array of convertible elements
        template <typename TArrayElem> void put_axes_definition(TArrayElem arr[], size_t n) { list_of_direction lst; ArrayToList(arr, n, lst); put_axes_definition(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of coordinated_universal_time_offset
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class coordinated_universal_time_offset : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of coordinated_universal_time_offset
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        coordinated_universal_time_offset(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "coordinated_universal_time_offset")
        {}

                /// <summary>
                /// Create new instace of coordinated_universal_time_offset and returns object of this C++ class to interact with
                /// </summary>
        static coordinated_universal_time_offset Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "coordinated_universal_time_offset"); assert(inst); return inst; }

        Nullable<hour_in_day> get_hour_offset() { hour_in_day val = (hour_in_day) 0; if (sdaiGetAttrBN(m_instance, "hour_offset", sdaiINTEGER, &val)) return val; else return Nullable<hour_in_day>(); }
        void put_hour_offset(hour_in_day value) { sdaiPutAttrBN(m_instance, "hour_offset", sdaiINTEGER, &value); }

        Nullable<minute_in_hour> get_minute_offset() { minute_in_hour val = (minute_in_hour) 0; if (sdaiGetAttrBN(m_instance, "minute_offset", sdaiINTEGER, &val)) return val; else return Nullable<minute_in_hour>(); }
        void put_minute_offset(minute_in_hour value) { sdaiPutAttrBN(m_instance, "minute_offset", sdaiINTEGER, &value); }

        Nullable<ahead_or_behind> get_sense() { int v = getENUM("sense", ahead_or_behind_); if (v >= 0) return (ahead_or_behind) v; else return Nullable<ahead_or_behind>(); }
        void put_sense(ahead_or_behind value) { TextValue val = ahead_or_behind_[(int) value]; sdaiPutAttrBN(m_instance, "sense", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of csg_solid
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class csg_solid : public virtual solid_model
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of csg_solid
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        csg_solid(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "csg_solid")
        {}

                /// <summary>
                /// Create new instace of csg_solid and returns object of this C++ class to interact with
                /// </summary>
        static csg_solid Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "csg_solid"); assert(inst); return inst; }

        csg_select_get get_tree_root_expression() { return csg_select_get(m_instance, "tree_root_expression", NULL); }
        csg_select_put put_tree_root_expression() { return csg_select_put(m_instance, "tree_root_expression", NULL); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of currency_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class currency_measure_with_unit : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of currency_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        currency_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "currency_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of currency_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static currency_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "currency_measure_with_unit"); assert(inst); return inst; }

        Nullable<double> get_amount() { double val = (double) 0; if (sdaiGetAttrBN(m_instance, "amount", sdaiREAL, &val)) return val; else return Nullable<double>(); }
        void put_amount(double value) { sdaiPutAttrBN(m_instance, "amount", sdaiREAL, &value); }

        currency_unit get_unit();
        void put_unit(currency_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of currency_rate_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class currency_rate_with_unit : public virtual currency_measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of currency_rate_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        currency_rate_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "currency_rate_with_unit")
        {}

                /// <summary>
                /// Create new instace of currency_rate_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static currency_rate_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "currency_rate_with_unit"); assert(inst); return inst; }

        measure_with_unit get_per_quantity();
        void put_per_quantity(measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of currency_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class currency_unit : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of currency_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        currency_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "currency_unit")
        {}

                /// <summary>
                /// Create new instace of currency_unit and returns object of this C++ class to interact with
                /// </summary>
        static currency_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "currency_unit"); assert(inst); return inst; }

        label get_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_name(label value) { sdaiPutAttrBN(m_instance, "name", sdaiSTRING, value); }

        text get_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_description(text value) { sdaiPutAttrBN(m_instance, "description", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of curve_bounded_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class curve_bounded_surface : public virtual bounded_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of curve_bounded_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        curve_bounded_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "curve_bounded_surface")
        {}

                /// <summary>
                /// Create new instace of curve_bounded_surface and returns object of this C++ class to interact with
                /// </summary>
        static curve_bounded_surface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "curve_bounded_surface"); assert(inst); return inst; }

        surface get_basis_surface();
        void put_basis_surface(surface inst);

        //TList may be set_of_boundary_curve or list of converible elements
        template <typename TList> void get_boundaries(TList& lst) { set_of_boundary_curveSerializer<TList> sr; sr.FromAttr(lst, m_instance, "boundaries"); }

        //TList may be set_of_boundary_curve or list of converible elements
        template <typename TList> void put_boundaries(TList& lst) { set_of_boundary_curveSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "boundaries"); }

        //TArrayElem[] may be boundary_curve[] or array of convertible elements
        template <typename TArrayElem> void put_boundaries(TArrayElem arr[], size_t n) { set_of_boundary_curve lst; ArrayToList(arr, n, lst); put_boundaries(lst); }

        Nullable<bool> get_implicit_outer() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "implicit_outer", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_implicit_outer(bool value) { sdaiPutAttrBN(m_instance, "implicit_outer", sdaiBOOLEAN, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of curve_replica
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class curve_replica : public virtual curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of curve_replica
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        curve_replica(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "curve_replica")
        {}

                /// <summary>
                /// Create new instace of curve_replica and returns object of this C++ class to interact with
                /// </summary>
        static curve_replica Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "curve_replica"); assert(inst); return inst; }

        curve get_parent_curve();
        void put_parent_curve(curve inst);

        cartesian_transformation_operator get_transformation();
        void put_transformation(cartesian_transformation_operator inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of cut
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class cut : public virtual structural_frame_process
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of cut
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        cut(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "cut")
        {}

                /// <summary>
                /// Create new instace of cut and returns object of this C++ class to interact with
                /// </summary>
        static cut Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "cut"); assert(inst); return inst; }

        Nullable<cutting_type> get_cutting_method() { int v = getENUM("cutting_method", cutting_type_); if (v >= 0) return (cutting_type) v; else return Nullable<cutting_type>(); }
        void put_cutting_method(cutting_type value) { TextValue val = cutting_type_[(int) value]; sdaiPutAttrBN(m_instance, "cutting_method", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of cyclide_segment_solid
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class cyclide_segment_solid : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of cyclide_segment_solid
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        cyclide_segment_solid(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "cyclide_segment_solid")
        {}

                /// <summary>
                /// Create new instace of cyclide_segment_solid and returns object of this C++ class to interact with
                /// </summary>
        static cyclide_segment_solid Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "cyclide_segment_solid"); assert(inst); return inst; }

        axis2_placement_3d get_position();
        void put_position(axis2_placement_3d inst);

        Nullable<positive_length_measure> get_radius1() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "radius1", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_radius1(positive_length_measure value) { sdaiPutAttrBN(m_instance, "radius1", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_radius2() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "radius2", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_radius2(positive_length_measure value) { sdaiPutAttrBN(m_instance, "radius2", sdaiREAL, &value); }

        Nullable<plane_angle_measure> get_cone_angle1() { plane_angle_measure val = (plane_angle_measure) 0; if (sdaiGetAttrBN(m_instance, "cone_angle1", sdaiREAL, &val)) return val; else return Nullable<plane_angle_measure>(); }
        void put_cone_angle1(plane_angle_measure value) { sdaiPutAttrBN(m_instance, "cone_angle1", sdaiREAL, &value); }

        Nullable<plane_angle_measure> get_cone_angle2() { plane_angle_measure val = (plane_angle_measure) 0; if (sdaiGetAttrBN(m_instance, "cone_angle2", sdaiREAL, &val)) return val; else return Nullable<plane_angle_measure>(); }
        void put_cone_angle2(plane_angle_measure value) { sdaiPutAttrBN(m_instance, "cone_angle2", sdaiREAL, &value); }

        Nullable<plane_angle_measure> get_turn_angle() { plane_angle_measure val = (plane_angle_measure) 0; if (sdaiGetAttrBN(m_instance, "turn_angle", sdaiREAL, &val)) return val; else return Nullable<plane_angle_measure>(); }
        void put_turn_angle(plane_angle_measure value) { sdaiPutAttrBN(m_instance, "turn_angle", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of cylindrical_point
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class cylindrical_point : public virtual cartesian_point
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of cylindrical_point
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        cylindrical_point(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "cylindrical_point")
        {}

                /// <summary>
                /// Create new instace of cylindrical_point and returns object of this C++ class to interact with
                /// </summary>
        static cylindrical_point Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "cylindrical_point"); assert(inst); return inst; }

        Nullable<length_measure> get_r() { length_measure val = (length_measure) 0; if (sdaiGetAttrBN(m_instance, "r", sdaiREAL, &val)) return val; else return Nullable<length_measure>(); }
        void put_r(length_measure value) { sdaiPutAttrBN(m_instance, "r", sdaiREAL, &value); }

        Nullable<plane_angle_measure> get_theta() { plane_angle_measure val = (plane_angle_measure) 0; if (sdaiGetAttrBN(m_instance, "theta", sdaiREAL, &val)) return val; else return Nullable<plane_angle_measure>(); }
        void put_theta(plane_angle_measure value) { sdaiPutAttrBN(m_instance, "theta", sdaiREAL, &value); }

        Nullable<length_measure> get_z() { length_measure val = (length_measure) 0; if (sdaiGetAttrBN(m_instance, "z", sdaiREAL, &val)) return val; else return Nullable<length_measure>(); }
        void put_z(length_measure value) { sdaiPutAttrBN(m_instance, "z", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of cylindrical_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class cylindrical_surface : public virtual elementary_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of cylindrical_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        cylindrical_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "cylindrical_surface")
        {}

                /// <summary>
                /// Create new instace of cylindrical_surface and returns object of this C++ class to interact with
                /// </summary>
        static cylindrical_surface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "cylindrical_surface"); assert(inst); return inst; }

        Nullable<positive_length_measure> get_radius() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "radius", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_radius(positive_length_measure value) { sdaiPutAttrBN(m_instance, "radius", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of cylindrical_volume
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class cylindrical_volume : public virtual volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of cylindrical_volume
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        cylindrical_volume(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "cylindrical_volume")
        {}

                /// <summary>
                /// Create new instace of cylindrical_volume and returns object of this C++ class to interact with
                /// </summary>
        static cylindrical_volume Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "cylindrical_volume"); assert(inst); return inst; }

        axis2_placement_3d get_position();
        void put_position(axis2_placement_3d inst);

        Nullable<positive_length_measure> get_radius() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "radius", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_radius(positive_length_measure value) { sdaiPutAttrBN(m_instance, "radius", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_height() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "height", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_height(positive_length_measure value) { sdaiPutAttrBN(m_instance, "height", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of date_and_time
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class date_and_time : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of date_and_time
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        date_and_time(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "date_and_time")
        {}

                /// <summary>
                /// Create new instace of date_and_time and returns object of this C++ class to interact with
                /// </summary>
        static date_and_time Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "date_and_time"); assert(inst); return inst; }

        calendar_date get_date_component();
        void put_date_component(calendar_date inst);

        local_time get_time_component();
        void put_time_component(local_time inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of representation
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class representation : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of representation
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        representation(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "representation")
        {}

                /// <summary>
                /// Create new instace of representation and returns object of this C++ class to interact with
                /// </summary>
        static representation Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "representation"); assert(inst); return inst; }

        label get_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_name(label value) { sdaiPutAttrBN(m_instance, "name", sdaiSTRING, value); }

        //TList may be set_of_representation_item or list of converible elements
        template <typename TList> void get_items(TList& lst) { set_of_representation_itemSerializer<TList> sr; sr.FromAttr(lst, m_instance, "items"); }

        //TList may be set_of_representation_item or list of converible elements
        template <typename TList> void put_items(TList& lst) { set_of_representation_itemSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "items"); }

        //TArrayElem[] may be representation_item[] or array of convertible elements
        template <typename TArrayElem> void put_items(TArrayElem arr[], size_t n) { set_of_representation_item lst; ArrayToList(arr, n, lst); put_items(lst); }

        representation_context get_context_of_items();
        void put_context_of_items(representation_context inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of definitional_representation
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class definitional_representation : public virtual representation
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of definitional_representation
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        definitional_representation(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "definitional_representation")
        {}

                /// <summary>
                /// Create new instace of definitional_representation and returns object of this C++ class to interact with
                /// </summary>
        static definitional_representation Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "definitional_representation"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of degenerate_pcurve
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class degenerate_pcurve : public virtual point
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of degenerate_pcurve
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        degenerate_pcurve(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "degenerate_pcurve")
        {}

                /// <summary>
                /// Create new instace of degenerate_pcurve and returns object of this C++ class to interact with
                /// </summary>
        static degenerate_pcurve Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "degenerate_pcurve"); assert(inst); return inst; }

        surface get_basis_surface();
        void put_basis_surface(surface inst);

        definitional_representation get_reference_to_curve();
        void put_reference_to_curve(definitional_representation inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of toroidal_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class toroidal_surface : public virtual elementary_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of toroidal_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        toroidal_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "toroidal_surface")
        {}

                /// <summary>
                /// Create new instace of toroidal_surface and returns object of this C++ class to interact with
                /// </summary>
        static toroidal_surface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "toroidal_surface"); assert(inst); return inst; }

        Nullable<positive_length_measure> get_major_radius() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "major_radius", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_major_radius(positive_length_measure value) { sdaiPutAttrBN(m_instance, "major_radius", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_minor_radius() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "minor_radius", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_minor_radius(positive_length_measure value) { sdaiPutAttrBN(m_instance, "minor_radius", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of degenerate_toroidal_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class degenerate_toroidal_surface : public virtual toroidal_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of degenerate_toroidal_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        degenerate_toroidal_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "degenerate_toroidal_surface")
        {}

                /// <summary>
                /// Create new instace of degenerate_toroidal_surface and returns object of this C++ class to interact with
                /// </summary>
        static degenerate_toroidal_surface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "degenerate_toroidal_surface"); assert(inst); return inst; }

        Nullable<bool> get_select_outer() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "select_outer", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_select_outer(bool value) { sdaiPutAttrBN(m_instance, "select_outer", sdaiBOOLEAN, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of derived_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class derived_measure_with_unit : public virtual measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of derived_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        derived_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "derived_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of derived_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static derived_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "derived_measure_with_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of derived_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class derived_unit : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of derived_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        derived_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "derived_unit")
        {}

                /// <summary>
                /// Create new instace of derived_unit and returns object of this C++ class to interact with
                /// </summary>
        static derived_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "derived_unit"); assert(inst); return inst; }

        //TList may be set_of_derived_unit_element or list of converible elements
        template <typename TList> void get_elements(TList& lst) { set_of_derived_unit_elementSerializer<TList> sr; sr.FromAttr(lst, m_instance, "elements"); }

        //TList may be set_of_derived_unit_element or list of converible elements
        template <typename TList> void put_elements(TList& lst) { set_of_derived_unit_elementSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "elements"); }

        //TArrayElem[] may be derived_unit_element[] or array of convertible elements
        template <typename TArrayElem> void put_elements(TArrayElem arr[], size_t n) { set_of_derived_unit_element lst; ArrayToList(arr, n, lst); put_elements(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of derived_unit_element
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class derived_unit_element : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of derived_unit_element
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        derived_unit_element(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "derived_unit_element")
        {}

                /// <summary>
                /// Create new instace of derived_unit_element and returns object of this C++ class to interact with
                /// </summary>
        static derived_unit_element Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "derived_unit_element"); assert(inst); return inst; }

        named_unit get_unit();
        void put_unit(named_unit inst);

        Nullable<double> get_exponent() { double val = (double) 0; if (sdaiGetAttrBN(m_instance, "exponent", sdaiREAL, &val)) return val; else return Nullable<double>(); }
        void put_exponent(double value) { sdaiPutAttrBN(m_instance, "exponent", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of description_attribute
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class description_attribute : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of description_attribute
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        description_attribute(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "description_attribute")
        {}

                /// <summary>
                /// Create new instace of description_attribute and returns object of this C++ class to interact with
                /// </summary>
        static description_attribute Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "description_attribute"); assert(inst); return inst; }

        text get_attribute_value() { text val = NULL; if (sdaiGetAttrBN(m_instance, "attribute_value", sdaiSTRING, &val)) return val; else return NULL; }
        void put_attribute_value(text value) { sdaiPutAttrBN(m_instance, "attribute_value", sdaiSTRING, value); }

        description_attribute_select_get get_described_item() { return description_attribute_select_get(m_instance, "described_item", NULL); }
        description_attribute_select_put put_described_item() { return description_attribute_select_put(m_instance, "described_item", NULL); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of design_criterion
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class design_criterion : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of design_criterion
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        design_criterion(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "design_criterion")
        {}

                /// <summary>
                /// Create new instace of design_criterion and returns object of this C++ class to interact with
                /// </summary>
        static design_criterion Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "design_criterion"); assert(inst); return inst; }

        label get_criterion_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "criterion_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_criterion_name(label value) { sdaiPutAttrBN(m_instance, "criterion_name", sdaiSTRING, value); }

        text get_criterion_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "criterion_description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_criterion_description(text value) { sdaiPutAttrBN(m_instance, "criterion_description", sdaiSTRING, value); }

        text get_design_assumptions() { text val = NULL; if (sdaiGetAttrBN(m_instance, "design_assumptions", sdaiSTRING, &val)) return val; else return NULL; }
        void put_design_assumptions(text value) { sdaiPutAttrBN(m_instance, "design_assumptions", sdaiSTRING, value); }

        //TList may be set_of_assembly_design or list of converible elements
        template <typename TList> void get_governed_assemblies(TList& lst) { set_of_assembly_designSerializer<TList> sr; sr.FromAttr(lst, m_instance, "governed_assemblies"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of design_criterion_documented
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class design_criterion_documented : public virtual design_criterion
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of design_criterion_documented
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        design_criterion_documented(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "design_criterion_documented")
        {}

                /// <summary>
                /// Create new instace of design_criterion_documented and returns object of this C++ class to interact with
                /// </summary>
        static design_criterion_documented Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "design_criterion_documented"); assert(inst); return inst; }

        document_usage_constraint get_documented_reference();
        void put_documented_reference(document_usage_constraint inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of design_joint_system
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class design_joint_system : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of design_joint_system
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        design_joint_system(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "design_joint_system")
        {}

                /// <summary>
                /// Create new instace of design_joint_system and returns object of this C++ class to interact with
                /// </summary>
        static design_joint_system Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "design_joint_system"); assert(inst); return inst; }

        label get_design_joint_system_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "design_joint_system_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_design_joint_system_name(label value) { sdaiPutAttrBN(m_instance, "design_joint_system_name", sdaiSTRING, value); }

        joint_system get_design_joint_system_spec();
        void put_design_joint_system_spec(joint_system inst);

        //TList may be list_of_assembly_design or list of converible elements
        template <typename TList> void get_parent_assemblies(TList& lst) { list_of_assembly_designSerializer<TList> sr; sr.FromAttr(lst, m_instance, "parent_assemblies"); }

        //TList may be list_of_assembly_design or list of converible elements
        template <typename TList> void put_parent_assemblies(TList& lst) { list_of_assembly_designSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "parent_assemblies"); }

        //TArrayElem[] may be assembly_design[] or array of convertible elements
        template <typename TArrayElem> void put_parent_assemblies(TArrayElem arr[], size_t n) { list_of_assembly_design lst; ArrayToList(arr, n, lst); put_parent_assemblies(lst); }

        //TList may be list_of_coord_system or list of converible elements
        template <typename TList> void get_locations(TList& lst) { list_of_coord_systemSerializer<TList> sr; sr.FromAttr(lst, m_instance, "locations"); }

        //TList may be list_of_coord_system or list of converible elements
        template <typename TList> void put_locations(TList& lst) { list_of_coord_systemSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "locations"); }

        //TArrayElem[] may be coord_system[] or array of convertible elements
        template <typename TArrayElem> void put_locations(TArrayElem arr[], size_t n) { list_of_coord_system lst; ArrayToList(arr, n, lst); put_locations(lst); }

        //TList may be set_of_design_part or list of converible elements
        template <typename TList> void get_connected_parts(TList& lst) { set_of_design_partSerializer<TList> sr; sr.FromAttr(lst, m_instance, "connected_parts"); }

        //TList may be set_of_design_part or list of converible elements
        template <typename TList> void put_connected_parts(TList& lst) { set_of_design_partSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "connected_parts"); }

        //TArrayElem[] may be design_part[] or array of convertible elements
        template <typename TArrayElem> void put_connected_parts(TArrayElem arr[], size_t n) { set_of_design_part lst; ArrayToList(arr, n, lst); put_connected_parts(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of design_part
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class design_part : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of design_part
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        design_part(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "design_part")
        {}

                /// <summary>
                /// Create new instace of design_part and returns object of this C++ class to interact with
                /// </summary>
        static design_part Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "design_part"); assert(inst); return inst; }

        label get_design_part_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "design_part_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_design_part_name(label value) { sdaiPutAttrBN(m_instance, "design_part_name", sdaiSTRING, value); }

        part get_design_part_spec();
        void put_design_part_spec(part inst);

        //TList may be list_of_assembly_design or list of converible elements
        template <typename TList> void get_parent_assemblies(TList& lst) { list_of_assembly_designSerializer<TList> sr; sr.FromAttr(lst, m_instance, "parent_assemblies"); }

        //TList may be list_of_assembly_design or list of converible elements
        template <typename TList> void put_parent_assemblies(TList& lst) { list_of_assembly_designSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "parent_assemblies"); }

        //TArrayElem[] may be assembly_design[] or array of convertible elements
        template <typename TArrayElem> void put_parent_assemblies(TArrayElem arr[], size_t n) { list_of_assembly_design lst; ArrayToList(arr, n, lst); put_parent_assemblies(lst); }

        //TList may be list_of_coord_system or list of converible elements
        template <typename TList> void get_locations(TList& lst) { list_of_coord_systemSerializer<TList> sr; sr.FromAttr(lst, m_instance, "locations"); }

        //TList may be list_of_coord_system or list of converible elements
        template <typename TList> void put_locations(TList& lst) { list_of_coord_systemSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "locations"); }

        //TArrayElem[] may be coord_system[] or array of convertible elements
        template <typename TArrayElem> void put_locations(TArrayElem arr[], size_t n) { list_of_coord_system lst; ArrayToList(arr, n, lst); put_locations(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of design_result
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class design_result : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of design_result
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        design_result(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "design_result")
        {}


        label get_design_result_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "design_result_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_design_result_name(label value) { sdaiPutAttrBN(m_instance, "design_result_name", sdaiSTRING, value); }

        resistance get_design_resistance();
        void put_design_resistance(resistance inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of design_result_connection
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class design_result_connection : public virtual design_result
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of design_result_connection
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        design_result_connection(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "design_result_connection")
        {}

                /// <summary>
                /// Create new instace of design_result_connection and returns object of this C++ class to interact with
                /// </summary>
        static design_result_connection Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "design_result_connection"); assert(inst); return inst; }

        assembly_design_structural_connection get_result_for_connection();
        void put_result_for_connection(assembly_design_structural_connection inst);

        point get_result_position();
        void put_result_position(point inst);

        label get_position_label() { label val = NULL; if (sdaiGetAttrBN(m_instance, "position_label", sdaiSTRING, &val)) return val; else return NULL; }
        void put_position_label(label value) { sdaiPutAttrBN(m_instance, "position_label", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of design_result_joint_system
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class design_result_joint_system : public virtual design_result
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of design_result_joint_system
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        design_result_joint_system(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "design_result_joint_system")
        {}

                /// <summary>
                /// Create new instace of design_result_joint_system and returns object of this C++ class to interact with
                /// </summary>
        static design_result_joint_system Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "design_result_joint_system"); assert(inst); return inst; }

        design_joint_system get_result_for_joint_system();
        void put_result_for_joint_system(design_joint_system inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of design_result_mapped
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class design_result_mapped : public virtual design_result
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of design_result_mapped
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        design_result_mapped(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "design_result_mapped")
        {}

                /// <summary>
                /// Create new instace of design_result_mapped and returns object of this C++ class to interact with
                /// </summary>
        static design_result_mapped Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "design_result_mapped"); assert(inst); return inst; }

        analysis_results_set get_origin_of_forces();
        void put_origin_of_forces(analysis_results_set inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of design_result_member
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class design_result_member : public virtual design_result
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of design_result_member
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        design_result_member(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "design_result_member")
        {}

                /// <summary>
                /// Create new instace of design_result_member and returns object of this C++ class to interact with
                /// </summary>
        static design_result_member Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "design_result_member"); assert(inst); return inst; }

        assembly_design_structural_member get_result_for_member();
        void put_result_for_member(assembly_design_structural_member inst);

        point get_result_position();
        void put_result_position(point inst);

        label get_position_label() { label val = NULL; if (sdaiGetAttrBN(m_instance, "position_label", sdaiSTRING, &val)) return val; else return NULL; }
        void put_position_label(label value) { sdaiPutAttrBN(m_instance, "position_label", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of design_result_part
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class design_result_part : public virtual design_result
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of design_result_part
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        design_result_part(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "design_result_part")
        {}

                /// <summary>
                /// Create new instace of design_result_part and returns object of this C++ class to interact with
                /// </summary>
        static design_result_part Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "design_result_part"); assert(inst); return inst; }

        design_part get_result_for_part();
        void put_result_for_part(design_part inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of design_result_resolved
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class design_result_resolved : public virtual design_result
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of design_result_resolved
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        design_result_resolved(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "design_result_resolved")
        {}

                /// <summary>
                /// Create new instace of design_result_resolved and returns object of this C++ class to interact with
                /// </summary>
        static design_result_resolved Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "design_result_resolved"); assert(inst); return inst; }

        reaction_force get_design_forces();
        void put_design_forces(reaction_force inst);

        Nullable<double> get_design_factor() { double val = (double) 0; if (sdaiGetAttrBN(m_instance, "design_factor", sdaiREAL, &val)) return val; else return Nullable<double>(); }
        void put_design_factor(double value) { sdaiPutAttrBN(m_instance, "design_factor", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of dimensional_exponents
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class dimensional_exponents : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of dimensional_exponents
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        dimensional_exponents(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "dimensional_exponents")
        {}

                /// <summary>
                /// Create new instace of dimensional_exponents and returns object of this C++ class to interact with
                /// </summary>
        static dimensional_exponents Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "dimensional_exponents"); assert(inst); return inst; }

        Nullable<double> get_length_exponent() { double val = (double) 0; if (sdaiGetAttrBN(m_instance, "length_exponent", sdaiREAL, &val)) return val; else return Nullable<double>(); }
        void put_length_exponent(double value) { sdaiPutAttrBN(m_instance, "length_exponent", sdaiREAL, &value); }

        Nullable<double> get_mass_exponent() { double val = (double) 0; if (sdaiGetAttrBN(m_instance, "mass_exponent", sdaiREAL, &val)) return val; else return Nullable<double>(); }
        void put_mass_exponent(double value) { sdaiPutAttrBN(m_instance, "mass_exponent", sdaiREAL, &value); }

        Nullable<double> get_time_exponent() { double val = (double) 0; if (sdaiGetAttrBN(m_instance, "time_exponent", sdaiREAL, &val)) return val; else return Nullable<double>(); }
        void put_time_exponent(double value) { sdaiPutAttrBN(m_instance, "time_exponent", sdaiREAL, &value); }

        Nullable<double> get_electric_current_exponent() { double val = (double) 0; if (sdaiGetAttrBN(m_instance, "electric_current_exponent", sdaiREAL, &val)) return val; else return Nullable<double>(); }
        void put_electric_current_exponent(double value) { sdaiPutAttrBN(m_instance, "electric_current_exponent", sdaiREAL, &value); }

        Nullable<double> get_thermodynamic_temperature_exponent() { double val = (double) 0; if (sdaiGetAttrBN(m_instance, "thermodynamic_temperature_exponent", sdaiREAL, &val)) return val; else return Nullable<double>(); }
        void put_thermodynamic_temperature_exponent(double value) { sdaiPutAttrBN(m_instance, "thermodynamic_temperature_exponent", sdaiREAL, &value); }

        Nullable<double> get_amount_of_substance_exponent() { double val = (double) 0; if (sdaiGetAttrBN(m_instance, "amount_of_substance_exponent", sdaiREAL, &val)) return val; else return Nullable<double>(); }
        void put_amount_of_substance_exponent(double value) { sdaiPutAttrBN(m_instance, "amount_of_substance_exponent", sdaiREAL, &value); }

        Nullable<double> get_luminous_intensity_exponent() { double val = (double) 0; if (sdaiGetAttrBN(m_instance, "luminous_intensity_exponent", sdaiREAL, &val)) return val; else return Nullable<double>(); }
        void put_luminous_intensity_exponent(double value) { sdaiPutAttrBN(m_instance, "luminous_intensity_exponent", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of executed_action
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class executed_action : public virtual action
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of executed_action
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        executed_action(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "executed_action")
        {}

                /// <summary>
                /// Create new instace of executed_action and returns object of this C++ class to interact with
                /// </summary>
        static executed_action Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "executed_action"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of directed_action
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class directed_action : public virtual executed_action
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of directed_action
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        directed_action(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "directed_action")
        {}

                /// <summary>
                /// Create new instace of directed_action and returns object of this C++ class to interact with
                /// </summary>
        static directed_action Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "directed_action"); assert(inst); return inst; }

        action_directive get_directive();
        void put_directive(action_directive inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of direction
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class direction : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of direction
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        direction(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "direction")
        {}

                /// <summary>
                /// Create new instace of direction and returns object of this C++ class to interact with
                /// </summary>
        static direction Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "direction"); assert(inst); return inst; }

        //TList may be list_of_double or list of converible elements
        template <typename TList> void get_direction_ratios(TList& lst) { list_of_doubleSerializer<TList> sr; sr.FromAttr(lst, m_instance, "direction_ratios"); }

        //TList may be list_of_double or list of converible elements
        template <typename TList> void put_direction_ratios(TList& lst) { list_of_doubleSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "direction_ratios"); }

        //TArrayElem[] may be double[] or array of convertible elements
        template <typename TArrayElem> void put_direction_ratios(TArrayElem arr[], size_t n) { list_of_double lst; ArrayToList(arr, n, lst); put_direction_ratios(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of dispatch
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class dispatch : public virtual structural_frame_process
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of dispatch
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        dispatch(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "dispatch")
        {}

                /// <summary>
                /// Create new instace of dispatch and returns object of this C++ class to interact with
                /// </summary>
        static dispatch Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "dispatch"); assert(inst); return inst; }

        //TList may be list_of_product_item_select or list of converible elements
        template <typename TList> void get_transported_products(TList& lst) { list_of_product_item_selectSerializer<TList> sr; sr.FromAttr(lst, m_instance, "transported_products"); }

        //TList may be list_of_product_item_select or list of converible elements
        template <typename TList> void put_transported_products(TList& lst) { list_of_product_item_selectSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "transported_products"); }

        organizational_address get_dispatch_address();
        void put_dispatch_address(organizational_address inst);

        organizational_address get_delivery_address();
        void put_delivery_address(organizational_address inst);

        calendar_date get_dispatch_date();
        void put_dispatch_date(calendar_date inst);

        calendar_date get_delivery_date();
        void put_delivery_date(calendar_date inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of document
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class document : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of document
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        document(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "document")
        {}

                /// <summary>
                /// Create new instace of document and returns object of this C++ class to interact with
                /// </summary>
        static document Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "document"); assert(inst); return inst; }

        identifier get_id() { identifier val = NULL; if (sdaiGetAttrBN(m_instance, "id", sdaiSTRING, &val)) return val; else return NULL; }
        void put_id(identifier value) { sdaiPutAttrBN(m_instance, "id", sdaiSTRING, value); }

        label get_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_name(label value) { sdaiPutAttrBN(m_instance, "name", sdaiSTRING, value); }

        text get_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_description(text value) { sdaiPutAttrBN(m_instance, "description", sdaiSTRING, value); }

        document_type get_kind();
        void put_kind(document_type inst);

        //TList may be set_of_document_representation_type or list of converible elements
        template <typename TList> void get_representation_types(TList& lst) { set_of_document_representation_typeSerializer<TList> sr; sr.FromAttr(lst, m_instance, "representation_types"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of document_relationship
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class document_relationship : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of document_relationship
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        document_relationship(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "document_relationship")
        {}

                /// <summary>
                /// Create new instace of document_relationship and returns object of this C++ class to interact with
                /// </summary>
        static document_relationship Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "document_relationship"); assert(inst); return inst; }

        label get_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_name(label value) { sdaiPutAttrBN(m_instance, "name", sdaiSTRING, value); }

        text get_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_description(text value) { sdaiPutAttrBN(m_instance, "description", sdaiSTRING, value); }

        document get_relating_document();
        void put_relating_document(document inst);

        document get_related_document();
        void put_related_document(document inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of document_representation_type
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class document_representation_type : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of document_representation_type
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        document_representation_type(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "document_representation_type")
        {}

                /// <summary>
                /// Create new instace of document_representation_type and returns object of this C++ class to interact with
                /// </summary>
        static document_representation_type Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "document_representation_type"); assert(inst); return inst; }

        label get_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_name(label value) { sdaiPutAttrBN(m_instance, "name", sdaiSTRING, value); }

        document get_represented_document();
        void put_represented_document(document inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of document_with_class
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class document_with_class : public virtual document
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of document_with_class
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        document_with_class(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "document_with_class")
        {}

                /// <summary>
                /// Create new instace of document_with_class and returns object of this C++ class to interact with
                /// </summary>
        static document_with_class Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "document_with_class"); assert(inst); return inst; }

        identifier get_class_() { identifier val = NULL; if (sdaiGetAttrBN(m_instance, "class_", sdaiSTRING, &val)) return val; else return NULL; }
        void put_class_(identifier value) { sdaiPutAttrBN(m_instance, "class_", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of document_standard
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class document_standard : public virtual document_with_class
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of document_standard
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        document_standard(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "document_standard")
        {}

                /// <summary>
                /// Create new instace of document_standard and returns object of this C++ class to interact with
                /// </summary>
        static document_standard Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "document_standard"); assert(inst); return inst; }

        //TList may be set_of_document_usage_constraint or list of converible elements
        template <typename TList> void get_relevant_clauses(TList& lst) { set_of_document_usage_constraintSerializer<TList> sr; sr.FromAttr(lst, m_instance, "relevant_clauses"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of document_type
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class document_type : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of document_type
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        document_type(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "document_type")
        {}

                /// <summary>
                /// Create new instace of document_type and returns object of this C++ class to interact with
                /// </summary>
        static document_type Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "document_type"); assert(inst); return inst; }

        label get_product_data_type() { label val = NULL; if (sdaiGetAttrBN(m_instance, "product_data_type", sdaiSTRING, &val)) return val; else return NULL; }
        void put_product_data_type(label value) { sdaiPutAttrBN(m_instance, "product_data_type", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of document_usage
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class document_usage : public virtual document_relationship
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of document_usage
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        document_usage(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "document_usage")
        {}

                /// <summary>
                /// Create new instace of document_usage and returns object of this C++ class to interact with
                /// </summary>
        static document_usage Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "document_usage"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of document_usage_constraint
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class document_usage_constraint : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of document_usage_constraint
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        document_usage_constraint(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "document_usage_constraint")
        {}

                /// <summary>
                /// Create new instace of document_usage_constraint and returns object of this C++ class to interact with
                /// </summary>
        static document_usage_constraint Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "document_usage_constraint"); assert(inst); return inst; }

        document get_source();
        void put_source(document inst);

        label get_subject_element() { label val = NULL; if (sdaiGetAttrBN(m_instance, "subject_element", sdaiSTRING, &val)) return val; else return NULL; }
        void put_subject_element(label value) { sdaiPutAttrBN(m_instance, "subject_element", sdaiSTRING, value); }

        text get_subject_element_value() { text val = NULL; if (sdaiGetAttrBN(m_instance, "subject_element_value", sdaiSTRING, &val)) return val; else return NULL; }
        void put_subject_element_value(text value) { sdaiPutAttrBN(m_instance, "subject_element_value", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of eccentric_cone
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class eccentric_cone : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of eccentric_cone
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        eccentric_cone(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "eccentric_cone")
        {}

                /// <summary>
                /// Create new instace of eccentric_cone and returns object of this C++ class to interact with
                /// </summary>
        static eccentric_cone Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "eccentric_cone"); assert(inst); return inst; }

        axis2_placement_3d get_position();
        void put_position(axis2_placement_3d inst);

        Nullable<positive_length_measure> get_semi_axis_1() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "semi_axis_1", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_semi_axis_1(positive_length_measure value) { sdaiPutAttrBN(m_instance, "semi_axis_1", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_semi_axis_2() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "semi_axis_2", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_semi_axis_2(positive_length_measure value) { sdaiPutAttrBN(m_instance, "semi_axis_2", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_height() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "height", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_height(positive_length_measure value) { sdaiPutAttrBN(m_instance, "height", sdaiREAL, &value); }

        Nullable<length_measure> get_x_offset() { length_measure val = (length_measure) 0; if (sdaiGetAttrBN(m_instance, "x_offset", sdaiREAL, &val)) return val; else return Nullable<length_measure>(); }
        void put_x_offset(length_measure value) { sdaiPutAttrBN(m_instance, "x_offset", sdaiREAL, &value); }

        Nullable<length_measure> get_y_offset() { length_measure val = (length_measure) 0; if (sdaiGetAttrBN(m_instance, "y_offset", sdaiREAL, &val)) return val; else return Nullable<length_measure>(); }
        void put_y_offset(length_measure value) { sdaiPutAttrBN(m_instance, "y_offset", sdaiREAL, &value); }

        Nullable<double> get_ratio() { double val = (double) 0; if (sdaiGetAttrBN(m_instance, "ratio", sdaiREAL, &val)) return val; else return Nullable<double>(); }
        void put_ratio(double value) { sdaiPutAttrBN(m_instance, "ratio", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of eccentric_conical_volume
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class eccentric_conical_volume : public virtual volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of eccentric_conical_volume
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        eccentric_conical_volume(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "eccentric_conical_volume")
        {}

                /// <summary>
                /// Create new instace of eccentric_conical_volume and returns object of this C++ class to interact with
                /// </summary>
        static eccentric_conical_volume Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "eccentric_conical_volume"); assert(inst); return inst; }

        axis2_placement_3d get_position();
        void put_position(axis2_placement_3d inst);

        Nullable<positive_length_measure> get_semi_axis_1() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "semi_axis_1", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_semi_axis_1(positive_length_measure value) { sdaiPutAttrBN(m_instance, "semi_axis_1", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_semi_axis_2() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "semi_axis_2", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_semi_axis_2(positive_length_measure value) { sdaiPutAttrBN(m_instance, "semi_axis_2", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_height() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "height", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_height(positive_length_measure value) { sdaiPutAttrBN(m_instance, "height", sdaiREAL, &value); }

        Nullable<length_measure> get_x_offset() { length_measure val = (length_measure) 0; if (sdaiGetAttrBN(m_instance, "x_offset", sdaiREAL, &val)) return val; else return Nullable<length_measure>(); }
        void put_x_offset(length_measure value) { sdaiPutAttrBN(m_instance, "x_offset", sdaiREAL, &value); }

        Nullable<length_measure> get_y_offset() { length_measure val = (length_measure) 0; if (sdaiGetAttrBN(m_instance, "y_offset", sdaiREAL, &val)) return val; else return Nullable<length_measure>(); }
        void put_y_offset(length_measure value) { sdaiPutAttrBN(m_instance, "y_offset", sdaiREAL, &value); }

        Nullable<double> get_ratio() { double val = (double) 0; if (sdaiGetAttrBN(m_instance, "ratio", sdaiREAL, &val)) return val; else return Nullable<double>(); }
        void put_ratio(double value) { sdaiPutAttrBN(m_instance, "ratio", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of edge
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class edge : public virtual topological_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of edge
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        edge(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "edge")
        {}

                /// <summary>
                /// Create new instace of edge and returns object of this C++ class to interact with
                /// </summary>
        static edge Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "edge"); assert(inst); return inst; }

        vertex get_edge_start();
        void put_edge_start(vertex inst);

        vertex get_edge_end();
        void put_edge_end(vertex inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of edge_based_wireframe_model
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class edge_based_wireframe_model : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of edge_based_wireframe_model
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        edge_based_wireframe_model(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "edge_based_wireframe_model")
        {}

                /// <summary>
                /// Create new instace of edge_based_wireframe_model and returns object of this C++ class to interact with
                /// </summary>
        static edge_based_wireframe_model Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "edge_based_wireframe_model"); assert(inst); return inst; }

        //TList may be set_of_connected_edge_set or list of converible elements
        template <typename TList> void get_ebwm_boundary(TList& lst) { set_of_connected_edge_setSerializer<TList> sr; sr.FromAttr(lst, m_instance, "ebwm_boundary"); }

        //TList may be set_of_connected_edge_set or list of converible elements
        template <typename TList> void put_ebwm_boundary(TList& lst) { set_of_connected_edge_setSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "ebwm_boundary"); }

        //TArrayElem[] may be connected_edge_set[] or array of convertible elements
        template <typename TArrayElem> void put_ebwm_boundary(TArrayElem arr[], size_t n) { set_of_connected_edge_set lst; ArrayToList(arr, n, lst); put_ebwm_boundary(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of edge_curve
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class edge_curve : public virtual edge, public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of edge_curve
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        edge_curve(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "edge_curve")
        {}

                /// <summary>
                /// Create new instace of edge_curve and returns object of this C++ class to interact with
                /// </summary>
        static edge_curve Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "edge_curve"); assert(inst); return inst; }

        curve get_edge_geometry();
        void put_edge_geometry(curve inst);

        Nullable<bool> get_same_sense() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "same_sense", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_same_sense(bool value) { sdaiPutAttrBN(m_instance, "same_sense", sdaiBOOLEAN, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of loop
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class loop : public virtual topological_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of loop
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        loop(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "loop")
        {}

                /// <summary>
                /// Create new instace of loop and returns object of this C++ class to interact with
                /// </summary>
        static loop Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "loop"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of path
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class path : public virtual topological_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of path
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        path(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "path")
        {}

                /// <summary>
                /// Create new instace of path and returns object of this C++ class to interact with
                /// </summary>
        static path Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "path"); assert(inst); return inst; }

        //TList may be list_of_oriented_edge or list of converible elements
        template <typename TList> void get_edge_list(TList& lst) { list_of_oriented_edgeSerializer<TList> sr; sr.FromAttr(lst, m_instance, "edge_list"); }

        //TList may be list_of_oriented_edge or list of converible elements
        template <typename TList> void put_edge_list(TList& lst) { list_of_oriented_edgeSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "edge_list"); }

        //TArrayElem[] may be oriented_edge[] or array of convertible elements
        template <typename TArrayElem> void put_edge_list(TArrayElem arr[], size_t n) { list_of_oriented_edge lst; ArrayToList(arr, n, lst); put_edge_list(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of edge_loop
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class edge_loop : public virtual loop, public virtual path
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of edge_loop
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        edge_loop(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "edge_loop")
        {}

                /// <summary>
                /// Create new instace of edge_loop and returns object of this C++ class to interact with
                /// </summary>
        static edge_loop Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "edge_loop"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of effective_buckling_length
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class effective_buckling_length : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of effective_buckling_length
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        effective_buckling_length(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "effective_buckling_length")
        {}

                /// <summary>
                /// Create new instace of effective_buckling_length and returns object of this C++ class to interact with
                /// </summary>
        static effective_buckling_length Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "effective_buckling_length"); assert(inst); return inst; }

        label get_effective_length_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "effective_length_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_effective_length_name(label value) { sdaiPutAttrBN(m_instance, "effective_length_name", sdaiSTRING, value); }

        Nullable<double> get_effective_length_factor() { double val = (double) 0; if (sdaiGetAttrBN(m_instance, "effective_length_factor", sdaiREAL, &val)) return val; else return Nullable<double>(); }
        void put_effective_length_factor(double value) { sdaiPutAttrBN(m_instance, "effective_length_factor", sdaiREAL, &value); }

        text get_effective_length_use() { text val = NULL; if (sdaiGetAttrBN(m_instance, "effective_length_use", sdaiSTRING, &val)) return val; else return NULL; }
        void put_effective_length_use(text value) { sdaiPutAttrBN(m_instance, "effective_length_use", sdaiSTRING, value); }

        Nullable<buckling_direction> get_effective_length_direction() { int v = getENUM("effective_length_direction", buckling_direction_); if (v >= 0) return (buckling_direction) v; else return Nullable<buckling_direction>(); }
        void put_effective_length_direction(buckling_direction value) { TextValue val = buckling_direction_[(int) value]; sdaiPutAttrBN(m_instance, "effective_length_direction", sdaiENUM, val); }

        assembly_design_structural_member get_applicable_member();
        void put_applicable_member(assembly_design_structural_member inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of element
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class element : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of element
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        element(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "element")
        {}

                /// <summary>
                /// Create new instace of element and returns object of this C++ class to interact with
                /// </summary>
        static element Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "element"); assert(inst); return inst; }

        label get_element_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "element_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_element_name(label value) { sdaiPutAttrBN(m_instance, "element_name", sdaiSTRING, value); }

        text get_element_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "element_description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_element_description(text value) { sdaiPutAttrBN(m_instance, "element_description", sdaiSTRING, value); }

        analysis_model get_parent_model();
        void put_parent_model(analysis_model inst);

        Nullable<IntValue> get_element_dimensionality() { IntValue val = (IntValue) 0; if (sdaiGetAttrBN(m_instance, "element_dimensionality", sdaiINTEGER, &val)) return val; else return Nullable<IntValue>(); }
        void put_element_dimensionality(IntValue value) { sdaiPutAttrBN(m_instance, "element_dimensionality", sdaiINTEGER, &value); }

        //TList may be set_of_element_node_connectivity or list of converible elements
        template <typename TList> void get_connectivity(TList& lst) { set_of_element_node_connectivitySerializer<TList> sr; sr.FromAttr(lst, m_instance, "connectivity"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of element_curve
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class element_curve : public virtual element
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of element_curve
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        element_curve(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "element_curve")
        {}


        Nullable<IntValue> get_element_subdivision() { IntValue val = (IntValue) 0; if (sdaiGetAttrBN(m_instance, "element_subdivision", sdaiINTEGER, &val)) return val; else return Nullable<IntValue>(); }
        void put_element_subdivision(IntValue value) { sdaiPutAttrBN(m_instance, "element_subdivision", sdaiINTEGER, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of element_curve_complex
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class element_curve_complex : public virtual element_curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of element_curve_complex
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        element_curve_complex(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "element_curve_complex")
        {}

                /// <summary>
                /// Create new instace of element_curve_complex and returns object of this C++ class to interact with
                /// </summary>
        static element_curve_complex Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "element_curve_complex"); assert(inst); return inst; }

        //TList may be list_of_section_profile or list of converible elements
        template <typename TList> void get_cross_sections(TList& lst) { list_of_section_profileSerializer<TList> sr; sr.FromAttr(lst, m_instance, "cross_sections"); }

        //TList may be list_of_section_profile or list of converible elements
        template <typename TList> void put_cross_sections(TList& lst) { list_of_section_profileSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "cross_sections"); }

        //TArrayElem[] may be section_profile[] or array of convertible elements
        template <typename TArrayElem> void put_cross_sections(TArrayElem arr[], size_t n) { list_of_section_profile lst; ArrayToList(arr, n, lst); put_cross_sections(lst); }

        //TList may be list_of_point_on_curve or list of converible elements
        template <typename TList> void get_points_defining_element_axis(TList& lst) { list_of_point_on_curveSerializer<TList> sr; sr.FromAttr(lst, m_instance, "points_defining_element_axis"); }

        //TList may be list_of_point_on_curve or list of converible elements
        template <typename TList> void put_points_defining_element_axis(TList& lst) { list_of_point_on_curveSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "points_defining_element_axis"); }

        //TArrayElem[] may be point_on_curve[] or array of convertible elements
        template <typename TArrayElem> void put_points_defining_element_axis(TArrayElem arr[], size_t n) { list_of_point_on_curve lst; ArrayToList(arr, n, lst); put_points_defining_element_axis(lst); }

        //TList may be list_of_orientation_select or list of converible elements
        template <typename TList> void get_element_orientations(TList& lst) { list_of_orientation_selectSerializer<TList> sr; sr.FromAttr(lst, m_instance, "element_orientations"); }

        //TList may be list_of_orientation_select or list of converible elements
        template <typename TList> void put_element_orientations(TList& lst) { list_of_orientation_selectSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "element_orientations"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of element_curve_simple
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class element_curve_simple : public virtual element_curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of element_curve_simple
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        element_curve_simple(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "element_curve_simple")
        {}

                /// <summary>
                /// Create new instace of element_curve_simple and returns object of this C++ class to interact with
                /// </summary>
        static element_curve_simple Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "element_curve_simple"); assert(inst); return inst; }

        section_profile get_cross_section();
        void put_cross_section(section_profile inst);

        orientation_select_get get_element_orientation() { return orientation_select_get(m_instance, "element_orientation", NULL); }
        orientation_select_put put_element_orientation() { return orientation_select_put(m_instance, "element_orientation", NULL); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of element_eccentricity
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class element_eccentricity : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of element_eccentricity
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        element_eccentricity(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "element_eccentricity")
        {}

                /// <summary>
                /// Create new instace of element_eccentricity and returns object of this C++ class to interact with
                /// </summary>
        static element_eccentricity Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "element_eccentricity"); assert(inst); return inst; }

        label get_element_eccentricity_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "element_eccentricity_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_element_eccentricity_name(label value) { sdaiPutAttrBN(m_instance, "element_eccentricity_name", sdaiSTRING, value); }

        length_measure_with_unit get_x_eccentricity();
        void put_x_eccentricity(length_measure_with_unit inst);

        length_measure_with_unit get_y_eccentricity();
        void put_y_eccentricity(length_measure_with_unit inst);

        length_measure_with_unit get_z_eccentricity();
        void put_z_eccentricity(length_measure_with_unit inst);

        //TList may be set_of_element_node_connectivity or list of converible elements
        template <typename TList> void get_eccentric_connectivities(TList& lst) { set_of_element_node_connectivitySerializer<TList> sr; sr.FromAttr(lst, m_instance, "eccentric_connectivities"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of element_mapping
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class element_mapping : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of element_mapping
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        element_mapping(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "element_mapping")
        {}

                /// <summary>
                /// Create new instace of element_mapping and returns object of this C++ class to interact with
                /// </summary>
        static element_mapping Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "element_mapping"); assert(inst); return inst; }

        element get_mapped_element();
        void put_mapped_element(element inst);

        part_select_get get_represented_part() { return part_select_get(m_instance, "represented_part", NULL); }
        part_select_put put_represented_part() { return part_select_put(m_instance, "represented_part", NULL); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of element_node_connectivity
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class element_node_connectivity : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of element_node_connectivity
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        element_node_connectivity(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "element_node_connectivity")
        {}

                /// <summary>
                /// Create new instace of element_node_connectivity and returns object of this C++ class to interact with
                /// </summary>
        static element_node_connectivity Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "element_node_connectivity"); assert(inst); return inst; }

        Nullable<IntValue> get_connectivity_number() { IntValue val = (IntValue) 0; if (sdaiGetAttrBN(m_instance, "connectivity_number", sdaiINTEGER, &val)) return val; else return Nullable<IntValue>(); }
        void put_connectivity_number(IntValue value) { sdaiPutAttrBN(m_instance, "connectivity_number", sdaiINTEGER, &value); }

        label get_connectivity_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "connectivity_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_connectivity_name(label value) { sdaiPutAttrBN(m_instance, "connectivity_name", sdaiSTRING, value); }

        node get_connecting_node();
        void put_connecting_node(node inst);

        element get_connecting_element();
        void put_connecting_element(element inst);

        element_eccentricity get_eccentricity();
        void put_eccentricity(element_eccentricity inst);

        release get_fixity();
        void put_fixity(release inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of element_point
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class element_point : public virtual element
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of element_point
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        element_point(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "element_point")
        {}

    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of element_point_grounded_damper
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class element_point_grounded_damper : public virtual element_point
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of element_point_grounded_damper
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        element_point_grounded_damper(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "element_point_grounded_damper")
        {}

                /// <summary>
                /// Create new instace of element_point_grounded_damper and returns object of this C++ class to interact with
                /// </summary>
        static element_point_grounded_damper Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "element_point_grounded_damper"); assert(inst); return inst; }

        //TList may be array_of_double or list of converible elements
        template <typename TList> void get_damping_coefficients(TList& lst) { array_of_doubleSerializer<TList> sr; sr.FromAttr(lst, m_instance, "damping_coefficients"); }

        //TList may be array_of_double or list of converible elements
        template <typename TList> void put_damping_coefficients(TList& lst) { array_of_doubleSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "damping_coefficients"); }

        //TArrayElem[] may be double[] or array of convertible elements
        template <typename TArrayElem> void put_damping_coefficients(TArrayElem arr[], size_t n) { array_of_double lst; ArrayToList(arr, n, lst); put_damping_coefficients(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of element_point_grounded_spring
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class element_point_grounded_spring : public virtual element_point
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of element_point_grounded_spring
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        element_point_grounded_spring(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "element_point_grounded_spring")
        {}

                /// <summary>
                /// Create new instace of element_point_grounded_spring and returns object of this C++ class to interact with
                /// </summary>
        static element_point_grounded_spring Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "element_point_grounded_spring"); assert(inst); return inst; }

        //TList may be array_of_double or list of converible elements
        template <typename TList> void get_stiffness_coefficients(TList& lst) { array_of_doubleSerializer<TList> sr; sr.FromAttr(lst, m_instance, "stiffness_coefficients"); }

        //TList may be array_of_double or list of converible elements
        template <typename TList> void put_stiffness_coefficients(TList& lst) { array_of_doubleSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "stiffness_coefficients"); }

        //TArrayElem[] may be double[] or array of convertible elements
        template <typename TArrayElem> void put_stiffness_coefficients(TArrayElem arr[], size_t n) { array_of_double lst; ArrayToList(arr, n, lst); put_stiffness_coefficients(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of element_point_stationary_mass
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class element_point_stationary_mass : public virtual element_point
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of element_point_stationary_mass
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        element_point_stationary_mass(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "element_point_stationary_mass")
        {}

                /// <summary>
                /// Create new instace of element_point_stationary_mass and returns object of this C++ class to interact with
                /// </summary>
        static element_point_stationary_mass Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "element_point_stationary_mass"); assert(inst); return inst; }

        //TList may be array_of_double or list of converible elements
        template <typename TList> void get_masses(TList& lst) { array_of_doubleSerializer<TList> sr; sr.FromAttr(lst, m_instance, "masses"); }

        //TList may be array_of_double or list of converible elements
        template <typename TList> void put_masses(TList& lst) { array_of_doubleSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "masses"); }

        //TArrayElem[] may be double[] or array of convertible elements
        template <typename TArrayElem> void put_masses(TArrayElem arr[], size_t n) { array_of_double lst; ArrayToList(arr, n, lst); put_masses(lst); }

        //TList may be array_of_array_of_double or list of converible elements
        template <typename TList> void get_moments_of_inertia(TList& lst) { array_of_array_of_doubleSerializer<TList> sr; sr.FromAttr(lst, m_instance, "moments_of_inertia"); }

        //TList may be array_of_array_of_double or list of converible elements
        template <typename TList> void put_moments_of_inertia(TList& lst) { array_of_array_of_doubleSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "moments_of_inertia"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of element_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class element_surface : public virtual element
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of element_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        element_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "element_surface")
        {}

                /// <summary>
                /// Create new instace of element_surface and returns object of this C++ class to interact with
                /// </summary>
        static element_surface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "element_surface"); assert(inst); return inst; }

        positive_length_measure_with_unit get_thickness();
        void put_thickness(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of element_surface_complex
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class element_surface_complex : public virtual element_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of element_surface_complex
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        element_surface_complex(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "element_surface_complex")
        {}

                /// <summary>
                /// Create new instace of element_surface_complex and returns object of this C++ class to interact with
                /// </summary>
        static element_surface_complex Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "element_surface_complex"); assert(inst); return inst; }

        surface get_surface_definition();
        void put_surface_definition(surface inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of element_surface_plane
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class element_surface_plane : public virtual element_surface_complex
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of element_surface_plane
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        element_surface_plane(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "element_surface_plane")
        {}

                /// <summary>
                /// Create new instace of element_surface_plane and returns object of this C++ class to interact with
                /// </summary>
        static element_surface_plane Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "element_surface_plane"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of element_surface_profiled
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class element_surface_profiled : public virtual element_surface_complex
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of element_surface_profiled
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        element_surface_profiled(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "element_surface_profiled")
        {}

                /// <summary>
                /// Create new instace of element_surface_profiled and returns object of this C++ class to interact with
                /// </summary>
        static element_surface_profiled Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "element_surface_profiled"); assert(inst); return inst; }

        curve get_profile();
        void put_profile(curve inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of element_surface_simple
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class element_surface_simple : public virtual element_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of element_surface_simple
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        element_surface_simple(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "element_surface_simple")
        {}

                /// <summary>
                /// Create new instace of element_surface_simple and returns object of this C++ class to interact with
                /// </summary>
        static element_surface_simple Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "element_surface_simple"); assert(inst); return inst; }

        Nullable<element_surface_shape> get_shape() { int v = getENUM("shape", element_surface_shape_); if (v >= 0) return (element_surface_shape) v; else return Nullable<element_surface_shape>(); }
        void put_shape(element_surface_shape value) { TextValue val = element_surface_shape_[(int) value]; sdaiPutAttrBN(m_instance, "shape", sdaiENUM, val); }

        Nullable<plane_stress_or_strain> get_assumption() { int v = getENUM("assumption", plane_stress_or_strain_); if (v >= 0) return (plane_stress_or_strain) v; else return Nullable<plane_stress_or_strain>(); }
        void put_assumption(plane_stress_or_strain value) { TextValue val = plane_stress_or_strain_[(int) value]; sdaiPutAttrBN(m_instance, "assumption", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of element_volume
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class element_volume : public virtual element
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of element_volume
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        element_volume(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "element_volume")
        {}

    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of element_volume_complex
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class element_volume_complex : public virtual element_volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of element_volume_complex
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        element_volume_complex(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "element_volume_complex")
        {}

                /// <summary>
                /// Create new instace of element_volume_complex and returns object of this C++ class to interact with
                /// </summary>
        static element_volume_complex Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "element_volume_complex"); assert(inst); return inst; }

        shape_representation_with_units get_shape();
        void put_shape(shape_representation_with_units inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of element_volume_simple
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class element_volume_simple : public virtual element_volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of element_volume_simple
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        element_volume_simple(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "element_volume_simple")
        {}

                /// <summary>
                /// Create new instace of element_volume_simple and returns object of this C++ class to interact with
                /// </summary>
        static element_volume_simple Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "element_volume_simple"); assert(inst); return inst; }

        Nullable<element_volume_shape> get_shape() { int v = getENUM("shape", element_volume_shape_); if (v >= 0) return (element_volume_shape) v; else return Nullable<element_volume_shape>(); }
        void put_shape(element_volume_shape value) { TextValue val = element_volume_shape_[(int) value]; sdaiPutAttrBN(m_instance, "shape", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of element_with_material
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class element_with_material : public virtual element
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of element_with_material
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        element_with_material(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "element_with_material")
        {}

                /// <summary>
                /// Create new instace of element_with_material and returns object of this C++ class to interact with
                /// </summary>
        static element_with_material Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "element_with_material"); assert(inst); return inst; }

        material get_material_definition();
        void put_material_definition(material inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of ellipse
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class ellipse : public virtual conic
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of ellipse
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        ellipse(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "ellipse")
        {}

                /// <summary>
                /// Create new instace of ellipse and returns object of this C++ class to interact with
                /// </summary>
        static ellipse Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "ellipse"); assert(inst); return inst; }

        Nullable<positive_length_measure> get_semi_axis_1() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "semi_axis_1", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_semi_axis_1(positive_length_measure value) { sdaiPutAttrBN(m_instance, "semi_axis_1", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_semi_axis_2() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "semi_axis_2", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_semi_axis_2(positive_length_measure value) { sdaiPutAttrBN(m_instance, "semi_axis_2", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of ellipsoid
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class ellipsoid : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of ellipsoid
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        ellipsoid(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "ellipsoid")
        {}

                /// <summary>
                /// Create new instace of ellipsoid and returns object of this C++ class to interact with
                /// </summary>
        static ellipsoid Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "ellipsoid"); assert(inst); return inst; }

        axis2_placement_3d get_position();
        void put_position(axis2_placement_3d inst);

        Nullable<positive_length_measure> get_semi_axis_1() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "semi_axis_1", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_semi_axis_1(positive_length_measure value) { sdaiPutAttrBN(m_instance, "semi_axis_1", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_semi_axis_2() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "semi_axis_2", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_semi_axis_2(positive_length_measure value) { sdaiPutAttrBN(m_instance, "semi_axis_2", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_semi_axis_3() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "semi_axis_3", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_semi_axis_3(positive_length_measure value) { sdaiPutAttrBN(m_instance, "semi_axis_3", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of ellipsoid_volume
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class ellipsoid_volume : public virtual volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of ellipsoid_volume
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        ellipsoid_volume(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "ellipsoid_volume")
        {}

                /// <summary>
                /// Create new instace of ellipsoid_volume and returns object of this C++ class to interact with
                /// </summary>
        static ellipsoid_volume Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "ellipsoid_volume"); assert(inst); return inst; }

        axis2_placement_3d get_position();
        void put_position(axis2_placement_3d inst);

        Nullable<positive_length_measure> get_semi_axis_1() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "semi_axis_1", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_semi_axis_1(positive_length_measure value) { sdaiPutAttrBN(m_instance, "semi_axis_1", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_semi_axis_2() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "semi_axis_2", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_semi_axis_2(positive_length_measure value) { sdaiPutAttrBN(m_instance, "semi_axis_2", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_semi_axis_3() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "semi_axis_3", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_semi_axis_3(positive_length_measure value) { sdaiPutAttrBN(m_instance, "semi_axis_3", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of elliptic_area
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class elliptic_area : public virtual primitive_2d
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of elliptic_area
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        elliptic_area(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "elliptic_area")
        {}

                /// <summary>
                /// Create new instace of elliptic_area and returns object of this C++ class to interact with
                /// </summary>
        static elliptic_area Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "elliptic_area"); assert(inst); return inst; }

        axis2_placement_2d get_position();
        void put_position(axis2_placement_2d inst);

        Nullable<positive_length_measure> get_semi_axis_1() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "semi_axis_1", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_semi_axis_1(positive_length_measure value) { sdaiPutAttrBN(m_instance, "semi_axis_1", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_semi_axis_2() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "semi_axis_2", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_semi_axis_2(positive_length_measure value) { sdaiPutAttrBN(m_instance, "semi_axis_2", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of evaluated_degenerate_pcurve
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class evaluated_degenerate_pcurve : public virtual degenerate_pcurve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of evaluated_degenerate_pcurve
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        evaluated_degenerate_pcurve(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "evaluated_degenerate_pcurve")
        {}

                /// <summary>
                /// Create new instace of evaluated_degenerate_pcurve and returns object of this C++ class to interact with
                /// </summary>
        static evaluated_degenerate_pcurve Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "evaluated_degenerate_pcurve"); assert(inst); return inst; }

        cartesian_point get_equivalent_point();
        void put_equivalent_point(cartesian_point inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of swept_area_solid
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class swept_area_solid : public virtual solid_model
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of swept_area_solid
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        swept_area_solid(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "swept_area_solid")
        {}

                /// <summary>
                /// Create new instace of swept_area_solid and returns object of this C++ class to interact with
                /// </summary>
        static swept_area_solid Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "swept_area_solid"); assert(inst); return inst; }

        curve_bounded_surface get_swept_area();
        void put_swept_area(curve_bounded_surface inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of extruded_area_solid
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class extruded_area_solid : public virtual swept_area_solid
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of extruded_area_solid
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        extruded_area_solid(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "extruded_area_solid")
        {}

                /// <summary>
                /// Create new instace of extruded_area_solid and returns object of this C++ class to interact with
                /// </summary>
        static extruded_area_solid Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "extruded_area_solid"); assert(inst); return inst; }

        direction get_extruded_direction();
        void put_extruded_direction(direction inst);

        Nullable<positive_length_measure> get_depth() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "depth", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_depth(positive_length_measure value) { sdaiPutAttrBN(m_instance, "depth", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of swept_face_solid
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class swept_face_solid : public virtual solid_model
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of swept_face_solid
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        swept_face_solid(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "swept_face_solid")
        {}

                /// <summary>
                /// Create new instace of swept_face_solid and returns object of this C++ class to interact with
                /// </summary>
        static swept_face_solid Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "swept_face_solid"); assert(inst); return inst; }

        face_surface get_swept_face();
        void put_swept_face(face_surface inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of extruded_face_solid
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class extruded_face_solid : public virtual swept_face_solid
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of extruded_face_solid
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        extruded_face_solid(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "extruded_face_solid")
        {}

                /// <summary>
                /// Create new instace of extruded_face_solid and returns object of this C++ class to interact with
                /// </summary>
        static extruded_face_solid Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "extruded_face_solid"); assert(inst); return inst; }

        direction get_extruded_direction();
        void put_extruded_direction(direction inst);

        Nullable<positive_length_measure> get_depth() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "depth", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_depth(positive_length_measure value) { sdaiPutAttrBN(m_instance, "depth", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of face
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class face : public virtual topological_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of face
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        face(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "face")
        {}

                /// <summary>
                /// Create new instace of face and returns object of this C++ class to interact with
                /// </summary>
        static face Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "face"); assert(inst); return inst; }

        //TList may be set_of_face_bound or list of converible elements
        template <typename TList> void get_bounds(TList& lst) { set_of_face_boundSerializer<TList> sr; sr.FromAttr(lst, m_instance, "bounds"); }

        //TList may be set_of_face_bound or list of converible elements
        template <typename TList> void put_bounds(TList& lst) { set_of_face_boundSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "bounds"); }

        //TArrayElem[] may be face_bound[] or array of convertible elements
        template <typename TArrayElem> void put_bounds(TArrayElem arr[], size_t n) { set_of_face_bound lst; ArrayToList(arr, n, lst); put_bounds(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of face_based_surface_model
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class face_based_surface_model : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of face_based_surface_model
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        face_based_surface_model(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "face_based_surface_model")
        {}

                /// <summary>
                /// Create new instace of face_based_surface_model and returns object of this C++ class to interact with
                /// </summary>
        static face_based_surface_model Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "face_based_surface_model"); assert(inst); return inst; }

        //TList may be set_of_connected_face_set or list of converible elements
        template <typename TList> void get_fbsm_faces(TList& lst) { set_of_connected_face_setSerializer<TList> sr; sr.FromAttr(lst, m_instance, "fbsm_faces"); }

        //TList may be set_of_connected_face_set or list of converible elements
        template <typename TList> void put_fbsm_faces(TList& lst) { set_of_connected_face_setSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "fbsm_faces"); }

        //TArrayElem[] may be connected_face_set[] or array of convertible elements
        template <typename TArrayElem> void put_fbsm_faces(TArrayElem arr[], size_t n) { set_of_connected_face_set lst; ArrayToList(arr, n, lst); put_fbsm_faces(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of face_bound
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class face_bound : public virtual topological_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of face_bound
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        face_bound(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "face_bound")
        {}

                /// <summary>
                /// Create new instace of face_bound and returns object of this C++ class to interact with
                /// </summary>
        static face_bound Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "face_bound"); assert(inst); return inst; }

        loop get_bound();
        void put_bound(loop inst);

        Nullable<bool> get_orientation() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "orientation", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_orientation(bool value) { sdaiPutAttrBN(m_instance, "orientation", sdaiBOOLEAN, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of face_outer_bound
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class face_outer_bound : public virtual face_bound
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of face_outer_bound
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        face_outer_bound(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "face_outer_bound")
        {}

                /// <summary>
                /// Create new instace of face_outer_bound and returns object of this C++ class to interact with
                /// </summary>
        static face_outer_bound Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "face_outer_bound"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of face_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class face_surface : public virtual face, public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of face_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        face_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "face_surface")
        {}

                /// <summary>
                /// Create new instace of face_surface and returns object of this C++ class to interact with
                /// </summary>
        static face_surface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "face_surface"); assert(inst); return inst; }

        surface get_face_geometry();
        void put_face_geometry(surface inst);

        Nullable<bool> get_same_sense() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "same_sense", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_same_sense(bool value) { sdaiPutAttrBN(m_instance, "same_sense", sdaiBOOLEAN, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of faceted_brep
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class faceted_brep : public virtual manifold_solid_brep
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of faceted_brep
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        faceted_brep(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "faceted_brep")
        {}

                /// <summary>
                /// Create new instace of faceted_brep and returns object of this C++ class to interact with
                /// </summary>
        static faceted_brep Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "faceted_brep"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener : public virtual structural_frame_product
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener")
        {}

                /// <summary>
                /// Create new instace of fastener and returns object of this C++ class to interact with
                /// </summary>
        static fastener Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener"); assert(inst); return inst; }

        label get_fastener_grade() { label val = NULL; if (sdaiGetAttrBN(m_instance, "fastener_grade", sdaiSTRING, &val)) return val; else return NULL; }
        void put_fastener_grade(label value) { sdaiPutAttrBN(m_instance, "fastener_grade", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_complex
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_complex : public virtual fastener
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_complex
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_complex(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_complex")
        {}

                /// <summary>
                /// Create new instace of fastener_complex and returns object of this C++ class to interact with
                /// </summary>
        static fastener_complex Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_complex"); assert(inst); return inst; }

        shape_representation_with_units get_fastener_shape();
        void put_fastener_shape(shape_representation_with_units inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_mechanism
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_mechanism : public virtual structural_frame_product
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_mechanism
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_mechanism(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_mechanism")
        {}

                /// <summary>
                /// Create new instace of fastener_mechanism and returns object of this C++ class to interact with
                /// </summary>
        static fastener_mechanism Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_mechanism"); assert(inst); return inst; }

        text get_sequence() { text val = NULL; if (sdaiGetAttrBN(m_instance, "sequence", sdaiSTRING, &val)) return val; else return NULL; }
        void put_sequence(text value) { sdaiPutAttrBN(m_instance, "sequence", sdaiSTRING, value); }

        //TList may be list_of_fastener or list of converible elements
        template <typename TList> void get_fasteners(TList& lst) { list_of_fastenerSerializer<TList> sr; sr.FromAttr(lst, m_instance, "fasteners"); }

        //TList may be list_of_fastener or list of converible elements
        template <typename TList> void put_fasteners(TList& lst) { list_of_fastenerSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "fasteners"); }

        //TArrayElem[] may be fastener[] or array of convertible elements
        template <typename TArrayElem> void put_fasteners(TArrayElem arr[], size_t n) { list_of_fastener lst; ArrayToList(arr, n, lst); put_fasteners(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_mechanism_with_position
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_mechanism_with_position : public virtual fastener_mechanism
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_mechanism_with_position
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_mechanism_with_position(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_mechanism_with_position")
        {}

                /// <summary>
                /// Create new instace of fastener_mechanism_with_position and returns object of this C++ class to interact with
                /// </summary>
        static fastener_mechanism_with_position Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_mechanism_with_position"); assert(inst); return inst; }

        //TList may be list_of_length_measure_with_unit or list of converible elements
        template <typename TList> void get_fastener_positions(TList& lst) { list_of_length_measure_with_unitSerializer<TList> sr; sr.FromAttr(lst, m_instance, "fastener_positions"); }

        //TList may be list_of_length_measure_with_unit or list of converible elements
        template <typename TList> void put_fastener_positions(TList& lst) { list_of_length_measure_with_unitSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "fastener_positions"); }

        //TArrayElem[] may be length_measure_with_unit[] or array of convertible elements
        template <typename TArrayElem> void put_fastener_positions(TArrayElem arr[], size_t n) { list_of_length_measure_with_unit lst; ArrayToList(arr, n, lst); put_fastener_positions(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_simple
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_simple : public virtual fastener
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_simple
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_simple(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_simple")
        {}

                /// <summary>
                /// Create new instace of fastener_simple and returns object of this C++ class to interact with
                /// </summary>
        static fastener_simple Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_simple"); assert(inst); return inst; }

        positive_length_measure_with_unit get_nominal_diameter();
        void put_nominal_diameter(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_nominal_length();
        void put_nominal_length(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_simple_bolt
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_simple_bolt : public virtual fastener_simple
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_simple_bolt
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_simple_bolt(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_simple_bolt")
        {}

                /// <summary>
                /// Create new instace of fastener_simple_bolt and returns object of this C++ class to interact with
                /// </summary>
        static fastener_simple_bolt Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_simple_bolt"); assert(inst); return inst; }

        positive_length_measure_with_unit get_length_of_shank();
        void put_length_of_shank(positive_length_measure_with_unit inst);

        force_measure_with_unit get_bolt_preload();
        void put_bolt_preload(force_measure_with_unit inst);

        area_measure_with_unit get_full_section_area();
        void put_full_section_area(area_measure_with_unit inst);

        area_measure_with_unit get_reduced_section_area();
        void put_reduced_section_area(area_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_simple_bolt_circular_head
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_simple_bolt_circular_head : public virtual fastener_simple_bolt
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_simple_bolt_circular_head
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_simple_bolt_circular_head(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_simple_bolt_circular_head")
        {}

                /// <summary>
                /// Create new instace of fastener_simple_bolt_circular_head and returns object of this C++ class to interact with
                /// </summary>
        static fastener_simple_bolt_circular_head Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_simple_bolt_circular_head"); assert(inst); return inst; }

        positive_length_measure_with_unit get_bolt_head_height();
        void put_bolt_head_height(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_head_diameter();
        void put_head_diameter(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_simple_bolt_hexagonal_head
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_simple_bolt_hexagonal_head : public virtual fastener_simple_bolt
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_simple_bolt_hexagonal_head
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_simple_bolt_hexagonal_head(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_simple_bolt_hexagonal_head")
        {}

                /// <summary>
                /// Create new instace of fastener_simple_bolt_hexagonal_head and returns object of this C++ class to interact with
                /// </summary>
        static fastener_simple_bolt_hexagonal_head Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_simple_bolt_hexagonal_head"); assert(inst); return inst; }

        positive_length_measure_with_unit get_bolt_head_height();
        void put_bolt_head_height(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_distance_across_vertices();
        void put_distance_across_vertices(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_distance_across_flats();
        void put_distance_across_flats(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_simple_bolt_square_head
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_simple_bolt_square_head : public virtual fastener_simple_bolt
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_simple_bolt_square_head
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_simple_bolt_square_head(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_simple_bolt_square_head")
        {}

                /// <summary>
                /// Create new instace of fastener_simple_bolt_square_head and returns object of this C++ class to interact with
                /// </summary>
        static fastener_simple_bolt_square_head Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_simple_bolt_square_head"); assert(inst); return inst; }

        positive_length_measure_with_unit get_bolt_head_height();
        void put_bolt_head_height(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_distance_across_flats();
        void put_distance_across_flats(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_simple_countersunk
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_simple_countersunk : public virtual fastener_simple
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_simple_countersunk
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_simple_countersunk(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_simple_countersunk")
        {}

                /// <summary>
                /// Create new instace of fastener_simple_countersunk and returns object of this C++ class to interact with
                /// </summary>
        static fastener_simple_countersunk Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_simple_countersunk"); assert(inst); return inst; }

        plane_angle_measure_with_unit get_countersink_angle();
        void put_countersink_angle(plane_angle_measure_with_unit inst);

        positive_length_measure_with_unit get_countersink_depth();
        void put_countersink_depth(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_simple_curved
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_simple_curved : public virtual fastener_simple
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_simple_curved
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_simple_curved(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_simple_curved")
        {}

                /// <summary>
                /// Create new instace of fastener_simple_curved and returns object of this C++ class to interact with
                /// </summary>
        static fastener_simple_curved Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_simple_curved"); assert(inst); return inst; }

        curve get_curve_definition();
        void put_curve_definition(curve inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_simple_nail
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_simple_nail : public virtual fastener_simple
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_simple_nail
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_simple_nail(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_simple_nail")
        {}

                /// <summary>
                /// Create new instace of fastener_simple_nail and returns object of this C++ class to interact with
                /// </summary>
        static fastener_simple_nail Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_simple_nail"); assert(inst); return inst; }

        text get_nail_type() { text val = NULL; if (sdaiGetAttrBN(m_instance, "nail_type", sdaiSTRING, &val)) return val; else return NULL; }
        void put_nail_type(text value) { sdaiPutAttrBN(m_instance, "nail_type", sdaiSTRING, value); }

        text get_nail_drive_type() { text val = NULL; if (sdaiGetAttrBN(m_instance, "nail_drive_type", sdaiSTRING, &val)) return val; else return NULL; }
        void put_nail_drive_type(text value) { sdaiPutAttrBN(m_instance, "nail_drive_type", sdaiSTRING, value); }

        text get_nail_head_shape() { text val = NULL; if (sdaiGetAttrBN(m_instance, "nail_head_shape", sdaiSTRING, &val)) return val; else return NULL; }
        void put_nail_head_shape(text value) { sdaiPutAttrBN(m_instance, "nail_head_shape", sdaiSTRING, value); }

        text get_nail_point_type() { text val = NULL; if (sdaiGetAttrBN(m_instance, "nail_point_type", sdaiSTRING, &val)) return val; else return NULL; }
        void put_nail_point_type(text value) { sdaiPutAttrBN(m_instance, "nail_point_type", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_simple_nut
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_simple_nut : public virtual fastener_simple
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_simple_nut
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_simple_nut(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_simple_nut")
        {}

                /// <summary>
                /// Create new instace of fastener_simple_nut and returns object of this C++ class to interact with
                /// </summary>
        static fastener_simple_nut Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_simple_nut"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_simple_nut_circular
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_simple_nut_circular : public virtual fastener_simple_nut
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_simple_nut_circular
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_simple_nut_circular(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_simple_nut_circular")
        {}

                /// <summary>
                /// Create new instace of fastener_simple_nut_circular and returns object of this C++ class to interact with
                /// </summary>
        static fastener_simple_nut_circular Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_simple_nut_circular"); assert(inst); return inst; }

        positive_length_measure_with_unit get_outside_diameter();
        void put_outside_diameter(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_simple_nut_closed
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_simple_nut_closed : public virtual fastener_simple_nut
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_simple_nut_closed
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_simple_nut_closed(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_simple_nut_closed")
        {}

                /// <summary>
                /// Create new instace of fastener_simple_nut_closed and returns object of this C++ class to interact with
                /// </summary>
        static fastener_simple_nut_closed Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_simple_nut_closed"); assert(inst); return inst; }

        positive_length_measure_with_unit get_nut_depth();
        void put_nut_depth(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_simple_nut_hexagonal
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_simple_nut_hexagonal : public virtual fastener_simple_nut
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_simple_nut_hexagonal
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_simple_nut_hexagonal(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_simple_nut_hexagonal")
        {}

                /// <summary>
                /// Create new instace of fastener_simple_nut_hexagonal and returns object of this C++ class to interact with
                /// </summary>
        static fastener_simple_nut_hexagonal Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_simple_nut_hexagonal"); assert(inst); return inst; }

        positive_length_measure_with_unit get_distance_across_vertices();
        void put_distance_across_vertices(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_distance_across_flats();
        void put_distance_across_flats(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_simple_nut_square
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_simple_nut_square : public virtual fastener_simple_nut
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_simple_nut_square
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_simple_nut_square(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_simple_nut_square")
        {}

                /// <summary>
                /// Create new instace of fastener_simple_nut_square and returns object of this C++ class to interact with
                /// </summary>
        static fastener_simple_nut_square Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_simple_nut_square"); assert(inst); return inst; }

        positive_length_measure_with_unit get_distance_across_flats();
        void put_distance_across_flats(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_simple_pin
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_simple_pin : public virtual fastener_simple
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_simple_pin
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_simple_pin(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_simple_pin")
        {}

                /// <summary>
                /// Create new instace of fastener_simple_pin and returns object of this C++ class to interact with
                /// </summary>
        static fastener_simple_pin Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_simple_pin"); assert(inst); return inst; }

        text get_pin_type() { text val = NULL; if (sdaiGetAttrBN(m_instance, "pin_type", sdaiSTRING, &val)) return val; else return NULL; }
        void put_pin_type(text value) { sdaiPutAttrBN(m_instance, "pin_type", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_simple_screw
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_simple_screw : public virtual fastener_simple
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_simple_screw
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_simple_screw(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_simple_screw")
        {}

                /// <summary>
                /// Create new instace of fastener_simple_screw and returns object of this C++ class to interact with
                /// </summary>
        static fastener_simple_screw Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_simple_screw"); assert(inst); return inst; }

        text get_screw_type() { text val = NULL; if (sdaiGetAttrBN(m_instance, "screw_type", sdaiSTRING, &val)) return val; else return NULL; }
        void put_screw_type(text value) { sdaiPutAttrBN(m_instance, "screw_type", sdaiSTRING, value); }

        text get_screw_drive_type() { text val = NULL; if (sdaiGetAttrBN(m_instance, "screw_drive_type", sdaiSTRING, &val)) return val; else return NULL; }
        void put_screw_drive_type(text value) { sdaiPutAttrBN(m_instance, "screw_drive_type", sdaiSTRING, value); }

        text get_screw_point_type() { text val = NULL; if (sdaiGetAttrBN(m_instance, "screw_point_type", sdaiSTRING, &val)) return val; else return NULL; }
        void put_screw_point_type(text value) { sdaiPutAttrBN(m_instance, "screw_point_type", sdaiSTRING, value); }

        positive_length_measure_with_unit get_screw_head_height();
        void put_screw_head_height(positive_length_measure_with_unit inst);

        area_measure_with_unit get_full_section_area();
        void put_full_section_area(area_measure_with_unit inst);

        area_measure_with_unit get_reduced_section_area();
        void put_reduced_section_area(area_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_simple_screw_machine
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_simple_screw_machine : public virtual fastener_simple_screw
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_simple_screw_machine
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_simple_screw_machine(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_simple_screw_machine")
        {}

                /// <summary>
                /// Create new instace of fastener_simple_screw_machine and returns object of this C++ class to interact with
                /// </summary>
        static fastener_simple_screw_machine Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_simple_screw_machine"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_simple_screw_self_drilling
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_simple_screw_self_drilling : public virtual fastener_simple_screw
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_simple_screw_self_drilling
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_simple_screw_self_drilling(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_simple_screw_self_drilling")
        {}

                /// <summary>
                /// Create new instace of fastener_simple_screw_self_drilling and returns object of this C++ class to interact with
                /// </summary>
        static fastener_simple_screw_self_drilling Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_simple_screw_self_drilling"); assert(inst); return inst; }

        Nullable<cutting_type> get_hole_cutting_method() { int v = getENUM("hole_cutting_method", cutting_type_); if (v >= 0) return (cutting_type) v; else return Nullable<cutting_type>(); }
        void put_hole_cutting_method(cutting_type value) { TextValue val = cutting_type_[(int) value]; sdaiPutAttrBN(m_instance, "hole_cutting_method", sdaiENUM, val); }

        positive_length_measure_with_unit get_pilot_hole_diameter();
        void put_pilot_hole_diameter(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_drill_diameter();
        void put_drill_diameter(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_simple_screw_self_tapping
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_simple_screw_self_tapping : public virtual fastener_simple_screw
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_simple_screw_self_tapping
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_simple_screw_self_tapping(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_simple_screw_self_tapping")
        {}

                /// <summary>
                /// Create new instace of fastener_simple_screw_self_tapping and returns object of this C++ class to interact with
                /// </summary>
        static fastener_simple_screw_self_tapping Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_simple_screw_self_tapping"); assert(inst); return inst; }

        Nullable<cutting_type> get_thread_cutting_method() { int v = getENUM("thread_cutting_method", cutting_type_); if (v >= 0) return (cutting_type) v; else return Nullable<cutting_type>(); }
        void put_thread_cutting_method(cutting_type value) { TextValue val = cutting_type_[(int) value]; sdaiPutAttrBN(m_instance, "thread_cutting_method", sdaiENUM, val); }

        positive_length_measure_with_unit get_pilot_hole_diameter();
        void put_pilot_hole_diameter(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_simple_screw_tapered
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_simple_screw_tapered : public virtual fastener_simple_screw
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_simple_screw_tapered
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_simple_screw_tapered(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_simple_screw_tapered")
        {}

                /// <summary>
                /// Create new instace of fastener_simple_screw_tapered and returns object of this C++ class to interact with
                /// </summary>
        static fastener_simple_screw_tapered Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_simple_screw_tapered"); assert(inst); return inst; }

        length_measure_with_unit get_absolute_taper();
        void put_absolute_taper(length_measure_with_unit inst);

        ratio_measure_with_unit get_relative_taper();
        void put_relative_taper(ratio_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_simple_shear_connector
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_simple_shear_connector : public virtual fastener_simple
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_simple_shear_connector
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_simple_shear_connector(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_simple_shear_connector")
        {}

                /// <summary>
                /// Create new instace of fastener_simple_shear_connector and returns object of this C++ class to interact with
                /// </summary>
        static fastener_simple_shear_connector Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_simple_shear_connector"); assert(inst); return inst; }

        text get_head_shape() { text val = NULL; if (sdaiGetAttrBN(m_instance, "head_shape", sdaiSTRING, &val)) return val; else return NULL; }
        void put_head_shape(text value) { sdaiPutAttrBN(m_instance, "head_shape", sdaiSTRING, value); }

        text get_connector_type() { text val = NULL; if (sdaiGetAttrBN(m_instance, "connector_type", sdaiSTRING, &val)) return val; else return NULL; }
        void put_connector_type(text value) { sdaiPutAttrBN(m_instance, "connector_type", sdaiSTRING, value); }

        text get_connection_method() { text val = NULL; if (sdaiGetAttrBN(m_instance, "connection_method", sdaiSTRING, &val)) return val; else return NULL; }
        void put_connection_method(text value) { sdaiPutAttrBN(m_instance, "connection_method", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_simple_stud
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_simple_stud : public virtual fastener_simple
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_simple_stud
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_simple_stud(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_simple_stud")
        {}

                /// <summary>
                /// Create new instace of fastener_simple_stud and returns object of this C++ class to interact with
                /// </summary>
        static fastener_simple_stud Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_simple_stud"); assert(inst); return inst; }

        positive_length_measure_with_unit get_thread_length_1();
        void put_thread_length_1(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_thread_length_2();
        void put_thread_length_2(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_length_of_shank();
        void put_length_of_shank(positive_length_measure_with_unit inst);

        area_measure_with_unit get_full_section_area();
        void put_full_section_area(area_measure_with_unit inst);

        area_measure_with_unit get_reduced_section_area();
        void put_reduced_section_area(area_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_simple_washer
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_simple_washer : public virtual fastener_simple
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_simple_washer
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_simple_washer(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_simple_washer")
        {}

                /// <summary>
                /// Create new instace of fastener_simple_washer and returns object of this C++ class to interact with
                /// </summary>
        static fastener_simple_washer Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_simple_washer"); assert(inst); return inst; }

        text get_washer_shape() { text val = NULL; if (sdaiGetAttrBN(m_instance, "washer_shape", sdaiSTRING, &val)) return val; else return NULL; }
        void put_washer_shape(text value) { sdaiPutAttrBN(m_instance, "washer_shape", sdaiSTRING, value); }

        positive_length_measure_with_unit get_inside_diameter();
        void put_inside_diameter(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_external_dimension();
        void put_external_dimension(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_simple_washer_load_indicating
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_simple_washer_load_indicating : public virtual fastener_simple_washer
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_simple_washer_load_indicating
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_simple_washer_load_indicating(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_simple_washer_load_indicating")
        {}

                /// <summary>
                /// Create new instace of fastener_simple_washer_load_indicating and returns object of this C++ class to interact with
                /// </summary>
        static fastener_simple_washer_load_indicating Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_simple_washer_load_indicating"); assert(inst); return inst; }

        positive_length_measure_with_unit get_final_gap();
        void put_final_gap(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fastener_simple_washer_tapered
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fastener_simple_washer_tapered : public virtual fastener_simple_washer
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fastener_simple_washer_tapered
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fastener_simple_washer_tapered(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fastener_simple_washer_tapered")
        {}

                /// <summary>
                /// Create new instace of fastener_simple_washer_tapered and returns object of this C++ class to interact with
                /// </summary>
        static fastener_simple_washer_tapered Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fastener_simple_washer_tapered"); assert(inst); return inst; }

        ratio_measure_with_unit get_taper();
        void put_taper(ratio_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature : public virtual structural_frame_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature")
        {}

                /// <summary>
                /// Create new instace of feature and returns object of this C++ class to interact with
                /// </summary>
        static feature Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_cutting_plane
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_cutting_plane : public virtual feature
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_cutting_plane
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_cutting_plane(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_cutting_plane")
        {}

                /// <summary>
                /// Create new instace of feature_cutting_plane and returns object of this C++ class to interact with
                /// </summary>
        static feature_cutting_plane Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_cutting_plane"); assert(inst); return inst; }

        plane get_plane_definition();
        void put_plane_definition(plane inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_edge_chamfer
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_edge_chamfer : public virtual feature
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_edge_chamfer
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_edge_chamfer(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_edge_chamfer")
        {}


        Nullable<bool> get_follow_round() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "follow_round", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_follow_round(bool value) { sdaiPutAttrBN(m_instance, "follow_round", sdaiBOOLEAN, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_edge_chamfer_fillet
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_edge_chamfer_fillet : public virtual feature_edge_chamfer
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_edge_chamfer_fillet
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_edge_chamfer_fillet(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_edge_chamfer_fillet")
        {}

                /// <summary>
                /// Create new instace of feature_edge_chamfer_fillet and returns object of this C++ class to interact with
                /// </summary>
        static feature_edge_chamfer_fillet Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_edge_chamfer_fillet"); assert(inst); return inst; }

        positive_length_measure_with_unit get_edge_fillet_radius();
        void put_edge_fillet_radius(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_edge_chamfer_rounding
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_edge_chamfer_rounding : public virtual feature_edge_chamfer
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_edge_chamfer_rounding
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_edge_chamfer_rounding(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_edge_chamfer_rounding")
        {}

                /// <summary>
                /// Create new instace of feature_edge_chamfer_rounding and returns object of this C++ class to interact with
                /// </summary>
        static feature_edge_chamfer_rounding Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_edge_chamfer_rounding"); assert(inst); return inst; }

        positive_length_measure_with_unit get_edge_rounding_radius();
        void put_edge_rounding_radius(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_edge_chamfer_straight
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_edge_chamfer_straight : public virtual feature_edge_chamfer
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_edge_chamfer_straight
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_edge_chamfer_straight(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_edge_chamfer_straight")
        {}

                /// <summary>
                /// Create new instace of feature_edge_chamfer_straight and returns object of this C++ class to interact with
                /// </summary>
        static feature_edge_chamfer_straight Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_edge_chamfer_straight"); assert(inst); return inst; }

        positive_length_measure_with_unit get_edge_chamfer_width();
        void put_edge_chamfer_width(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_edge_chamfer_depth();
        void put_edge_chamfer_depth(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_surface : public virtual feature
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_surface")
        {}

    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_surface_complex
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_surface_complex : public virtual feature_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_surface_complex
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_surface_complex(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_surface_complex")
        {}

                /// <summary>
                /// Create new instace of feature_surface_complex and returns object of this C++ class to interact with
                /// </summary>
        static feature_surface_complex Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_surface_complex"); assert(inst); return inst; }

        bounded_surface get_feature_boundary();
        void put_feature_boundary(bounded_surface inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_surface_name_tag
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_surface_name_tag : public virtual feature_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_surface_name_tag
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_surface_name_tag(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_surface_name_tag")
        {}

                /// <summary>
                /// Create new instace of feature_surface_name_tag and returns object of this C++ class to interact with
                /// </summary>
        static feature_surface_name_tag Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_surface_name_tag"); assert(inst); return inst; }

        //TList may be list_of_text or list of converible elements
        template <typename TList> void get_name_tag_items(TList& lst) { list_of_textSerializer<TList> sr; sr.FromAttr(lst, m_instance, "name_tag_items"); }

        //TList may be list_of_text or list of converible elements
        template <typename TList> void put_name_tag_items(TList& lst) { list_of_textSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "name_tag_items"); }

        //TArrayElem[] may be text[] or array of convertible elements
        template <typename TArrayElem> void put_name_tag_items(TArrayElem arr[], size_t n) { list_of_text lst; ArrayToList(arr, n, lst); put_name_tag_items(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_surface_point
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_surface_point : public virtual feature_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_surface_point
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_surface_point(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_surface_point")
        {}

                /// <summary>
                /// Create new instace of feature_surface_point and returns object of this C++ class to interact with
                /// </summary>
        static feature_surface_point Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_surface_point"); assert(inst); return inst; }

        point get_feature_point();
        void put_feature_point(point inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_surface_point_mark
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_surface_point_mark : public virtual feature_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_surface_point_mark
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_surface_point_mark(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_surface_point_mark")
        {}

                /// <summary>
                /// Create new instace of feature_surface_point_mark and returns object of this C++ class to interact with
                /// </summary>
        static feature_surface_point_mark Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_surface_point_mark"); assert(inst); return inst; }

        surface_treatment_hard_stamp get_marking_process();
        void put_marking_process(surface_treatment_hard_stamp inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_surface_simple
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_surface_simple : public virtual feature_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_surface_simple
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_surface_simple(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_surface_simple")
        {}

                /// <summary>
                /// Create new instace of feature_surface_simple and returns object of this C++ class to interact with
                /// </summary>
        static feature_surface_simple Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_surface_simple"); assert(inst); return inst; }

        //TList may be list_of_point or list of converible elements
        template <typename TList> void get_feature_boundary(TList& lst) { list_of_pointSerializer<TList> sr; sr.FromAttr(lst, m_instance, "feature_boundary"); }

        //TList may be list_of_point or list of converible elements
        template <typename TList> void put_feature_boundary(TList& lst) { list_of_pointSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "feature_boundary"); }

        //TArrayElem[] may be point[] or array of convertible elements
        template <typename TArrayElem> void put_feature_boundary(TArrayElem arr[], size_t n) { list_of_point lst; ArrayToList(arr, n, lst); put_feature_boundary(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_surface_treatment
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_surface_treatment : public virtual feature_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_surface_treatment
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_surface_treatment(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_surface_treatment")
        {}

                /// <summary>
                /// Create new instace of feature_surface_treatment and returns object of this C++ class to interact with
                /// </summary>
        static feature_surface_treatment Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_surface_treatment"); assert(inst); return inst; }

        surface_treatment get_treatment_definition();
        void put_treatment_definition(surface_treatment inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_surface_with_layout
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_surface_with_layout : public virtual feature_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_surface_with_layout
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_surface_with_layout(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_surface_with_layout")
        {}

                /// <summary>
                /// Create new instace of feature_surface_with_layout and returns object of this C++ class to interact with
                /// </summary>
        static feature_surface_with_layout Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_surface_with_layout"); assert(inst); return inst; }

        //TList may be set_of_point or list of converible elements
        template <typename TList> void get_layout(TList& lst) { set_of_pointSerializer<TList> sr; sr.FromAttr(lst, m_instance, "layout"); }

        //TList may be set_of_point or list of converible elements
        template <typename TList> void put_layout(TList& lst) { set_of_pointSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "layout"); }

        //TArrayElem[] may be point[] or array of convertible elements
        template <typename TArrayElem> void put_layout(TArrayElem arr[], size_t n) { set_of_point lst; ArrayToList(arr, n, lst); put_layout(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_thread
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_thread : public virtual feature
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_thread
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_thread(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_thread")
        {}

                /// <summary>
                /// Create new instace of feature_thread and returns object of this C++ class to interact with
                /// </summary>
        static feature_thread Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_thread"); assert(inst); return inst; }

        positive_length_measure_with_unit get_thread_pitch();
        void put_thread_pitch(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_thread_length();
        void put_thread_length(positive_length_measure_with_unit inst);

        shape_representation_with_units get_thread_profile();
        void put_thread_profile(shape_representation_with_units inst);

        Nullable<bool> get_right_handed() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "right_handed", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_right_handed(bool value) { sdaiPutAttrBN(m_instance, "right_handed", sdaiBOOLEAN, &value); }

        Nullable<IntValue> get_number_of_threads() { IntValue val = (IntValue) 0; if (sdaiGetAttrBN(m_instance, "number_of_threads", sdaiINTEGER, &val)) return val; else return Nullable<IntValue>(); }
        void put_number_of_threads(IntValue value) { sdaiPutAttrBN(m_instance, "number_of_threads", sdaiINTEGER, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_volume
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_volume : public virtual feature
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_volume
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_volume(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_volume")
        {}

    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_volume_complex
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_volume_complex : public virtual feature_volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_volume_complex
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_volume_complex(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_volume_complex")
        {}

                /// <summary>
                /// Create new instace of feature_volume_complex and returns object of this C++ class to interact with
                /// </summary>
        static feature_volume_complex Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_volume_complex"); assert(inst); return inst; }

        shape_representation_with_units get_feature_shape();
        void put_feature_shape(shape_representation_with_units inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_volume_curved
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_volume_curved : public virtual feature_volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_volume_curved
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_volume_curved(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_volume_curved")
        {}

                /// <summary>
                /// Create new instace of feature_volume_curved and returns object of this C++ class to interact with
                /// </summary>
        static feature_volume_curved Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_volume_curved"); assert(inst); return inst; }

        curve get_feature_trace();
        void put_feature_trace(curve inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_volume_curved_line
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_volume_curved_line : public virtual feature_volume_curved
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_volume_curved_line
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_volume_curved_line(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_volume_curved_line")
        {}

                /// <summary>
                /// Create new instace of feature_volume_curved_line and returns object of this C++ class to interact with
                /// </summary>
        static feature_volume_curved_line Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_volume_curved_line"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_volume_hole
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_volume_hole : public virtual feature_volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_volume_hole
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_volume_hole(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_volume_hole")
        {}

    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_volume_hole_circular
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_volume_hole_circular : public virtual feature_volume_hole
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_volume_hole_circular
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_volume_hole_circular(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_volume_hole_circular")
        {}

                /// <summary>
                /// Create new instace of feature_volume_hole_circular and returns object of this C++ class to interact with
                /// </summary>
        static feature_volume_hole_circular Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_volume_hole_circular"); assert(inst); return inst; }

        positive_length_measure_with_unit get_hole_radius();
        void put_hole_radius(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_volume_hole_circular_threaded
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_volume_hole_circular_threaded : public virtual feature_volume_hole_circular
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_volume_hole_circular_threaded
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_volume_hole_circular_threaded(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_volume_hole_circular_threaded")
        {}

                /// <summary>
                /// Create new instace of feature_volume_hole_circular_threaded and returns object of this C++ class to interact with
                /// </summary>
        static feature_volume_hole_circular_threaded Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_volume_hole_circular_threaded"); assert(inst); return inst; }

        feature_thread get_thread_definition();
        void put_thread_definition(feature_thread inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_volume_hole_rectangular
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_volume_hole_rectangular : public virtual feature_volume_hole
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_volume_hole_rectangular
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_volume_hole_rectangular(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_volume_hole_rectangular")
        {}

                /// <summary>
                /// Create new instace of feature_volume_hole_rectangular and returns object of this C++ class to interact with
                /// </summary>
        static feature_volume_hole_rectangular Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_volume_hole_rectangular"); assert(inst); return inst; }

        positive_length_measure_with_unit get_hole_length();
        void put_hole_length(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_hole_height();
        void put_hole_height(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_fillet_radius();
        void put_fillet_radius(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_volume_hole_slotted
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_volume_hole_slotted : public virtual feature_volume_hole
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_volume_hole_slotted
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_volume_hole_slotted(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_volume_hole_slotted")
        {}

                /// <summary>
                /// Create new instace of feature_volume_hole_slotted and returns object of this C++ class to interact with
                /// </summary>
        static feature_volume_hole_slotted Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_volume_hole_slotted"); assert(inst); return inst; }

        positive_length_measure_with_unit get_slot_height();
        void put_slot_height(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_slot_length();
        void put_slot_length(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_volume_hole_slotted_curved
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_volume_hole_slotted_curved : public virtual feature_volume_hole_slotted
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_volume_hole_slotted_curved
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_volume_hole_slotted_curved(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_volume_hole_slotted_curved")
        {}

                /// <summary>
                /// Create new instace of feature_volume_hole_slotted_curved and returns object of this C++ class to interact with
                /// </summary>
        static feature_volume_hole_slotted_curved Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_volume_hole_slotted_curved"); assert(inst); return inst; }

        positive_length_measure_with_unit get_curve_radius();
        void put_curve_radius(positive_length_measure_with_unit inst);

        plane_angle_measure_with_unit get_sector_angle();
        void put_sector_angle(plane_angle_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_volume_prismatic
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_volume_prismatic : public virtual feature_volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_volume_prismatic
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_volume_prismatic(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_volume_prismatic")
        {}


        Nullable<top_or_bottom> get_top_or_bottom_edge() { int v = getENUM("top_or_bottom_edge", top_or_bottom_); if (v >= 0) return (top_or_bottom) v; else return Nullable<top_or_bottom>(); }
        void put_top_or_bottom_edge(top_or_bottom value) { TextValue val = top_or_bottom_[(int) value]; sdaiPutAttrBN(m_instance, "top_or_bottom_edge", sdaiENUM, val); }

        Nullable<start_or_end_face> get_start_or_end() { int v = getENUM("start_or_end", start_or_end_face_); if (v >= 0) return (start_or_end_face) v; else return Nullable<start_or_end_face>(); }
        void put_start_or_end(start_or_end_face value) { TextValue val = start_or_end_face_[(int) value]; sdaiPutAttrBN(m_instance, "start_or_end", sdaiENUM, val); }

        Nullable<bool> get_original_face() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "original_face", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_original_face(bool value) { sdaiPutAttrBN(m_instance, "original_face", sdaiBOOLEAN, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_volume_prismatic_chamfer
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_volume_prismatic_chamfer : public virtual feature_volume_prismatic
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_volume_prismatic_chamfer
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_volume_prismatic_chamfer(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_volume_prismatic_chamfer")
        {}

                /// <summary>
                /// Create new instace of feature_volume_prismatic_chamfer and returns object of this C++ class to interact with
                /// </summary>
        static feature_volume_prismatic_chamfer Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_volume_prismatic_chamfer"); assert(inst); return inst; }

        positive_length_measure_with_unit get_chamfer_length();
        void put_chamfer_length(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_chamfer_depth();
        void put_chamfer_depth(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_volume_prismatic_flange_chamfer
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_volume_prismatic_flange_chamfer : public virtual feature_volume_prismatic
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_volume_prismatic_flange_chamfer
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_volume_prismatic_flange_chamfer(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_volume_prismatic_flange_chamfer")
        {}

                /// <summary>
                /// Create new instace of feature_volume_prismatic_flange_chamfer and returns object of this C++ class to interact with
                /// </summary>
        static feature_volume_prismatic_flange_chamfer Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_volume_prismatic_flange_chamfer"); assert(inst); return inst; }

        Nullable<left_or_right> get_left_or_right_hand() { int v = getENUM("left_or_right_hand", left_or_right_); if (v >= 0) return (left_or_right) v; else return Nullable<left_or_right>(); }
        void put_left_or_right_hand(left_or_right value) { TextValue val = left_or_right_[(int) value]; sdaiPutAttrBN(m_instance, "left_or_right_hand", sdaiENUM, val); }

        positive_length_measure_with_unit get_flange_chamfer_length();
        void put_flange_chamfer_length(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_flange_chamfer_width();
        void put_flange_chamfer_width(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_volume_prismatic_flange_notch
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_volume_prismatic_flange_notch : public virtual feature_volume_prismatic
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_volume_prismatic_flange_notch
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_volume_prismatic_flange_notch(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_volume_prismatic_flange_notch")
        {}

                /// <summary>
                /// Create new instace of feature_volume_prismatic_flange_notch and returns object of this C++ class to interact with
                /// </summary>
        static feature_volume_prismatic_flange_notch Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_volume_prismatic_flange_notch"); assert(inst); return inst; }

        Nullable<left_or_right> get_left_or_right_hand() { int v = getENUM("left_or_right_hand", left_or_right_); if (v >= 0) return (left_or_right) v; else return Nullable<left_or_right>(); }
        void put_left_or_right_hand(left_or_right value) { TextValue val = left_or_right_[(int) value]; sdaiPutAttrBN(m_instance, "left_or_right_hand", sdaiENUM, val); }

        positive_length_measure_with_unit get_flange_notch_length();
        void put_flange_notch_length(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_flange_notch_width();
        void put_flange_notch_width(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_flange_notch_radius();
        void put_flange_notch_radius(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_volume_prismatic_notch
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_volume_prismatic_notch : public virtual feature_volume_prismatic
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_volume_prismatic_notch
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_volume_prismatic_notch(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_volume_prismatic_notch")
        {}

                /// <summary>
                /// Create new instace of feature_volume_prismatic_notch and returns object of this C++ class to interact with
                /// </summary>
        static feature_volume_prismatic_notch Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_volume_prismatic_notch"); assert(inst); return inst; }

        positive_length_measure_with_unit get_notch_length();
        void put_notch_length(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_notch_depth();
        void put_notch_depth(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_notch_radius();
        void put_notch_radius(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_volume_prismatic_skewed_end
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_volume_prismatic_skewed_end : public virtual feature_volume_prismatic
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_volume_prismatic_skewed_end
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_volume_prismatic_skewed_end(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_volume_prismatic_skewed_end")
        {}

                /// <summary>
                /// Create new instace of feature_volume_prismatic_skewed_end and returns object of this C++ class to interact with
                /// </summary>
        static feature_volume_prismatic_skewed_end Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_volume_prismatic_skewed_end"); assert(inst); return inst; }

        plane_angle_measure_with_unit get_skew_angle_1();
        void put_skew_angle_1(plane_angle_measure_with_unit inst);

        plane_angle_measure_with_unit get_skew_angle_2();
        void put_skew_angle_2(plane_angle_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_volume_with_depth
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_volume_with_depth : public virtual feature_volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_volume_with_depth
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_volume_with_depth(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_volume_with_depth")
        {}

                /// <summary>
                /// Create new instace of feature_volume_with_depth and returns object of this C++ class to interact with
                /// </summary>
        static feature_volume_with_depth Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_volume_with_depth"); assert(inst); return inst; }

        positive_length_measure_with_unit get_penetration_depth();
        void put_penetration_depth(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_volume_with_layout
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_volume_with_layout : public virtual feature_volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_volume_with_layout
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_volume_with_layout(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_volume_with_layout")
        {}

                /// <summary>
                /// Create new instace of feature_volume_with_layout and returns object of this C++ class to interact with
                /// </summary>
        static feature_volume_with_layout Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_volume_with_layout"); assert(inst); return inst; }

        //TList may be set_of_point or list of converible elements
        template <typename TList> void get_layout(TList& lst) { set_of_pointSerializer<TList> sr; sr.FromAttr(lst, m_instance, "layout"); }

        //TList may be set_of_point or list of converible elements
        template <typename TList> void put_layout(TList& lst) { set_of_pointSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "layout"); }

        //TArrayElem[] may be point[] or array of convertible elements
        template <typename TArrayElem> void put_layout(TArrayElem arr[], size_t n) { set_of_point lst; ArrayToList(arr, n, lst); put_layout(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_volume_with_limit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_volume_with_limit : public virtual feature_volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_volume_with_limit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_volume_with_limit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_volume_with_limit")
        {}

                /// <summary>
                /// Create new instace of feature_volume_with_limit and returns object of this C++ class to interact with
                /// </summary>
        static feature_volume_with_limit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_volume_with_limit"); assert(inst); return inst; }

        Nullable<IntValue> get_penetration_limit() { IntValue val = (IntValue) 0; if (sdaiGetAttrBN(m_instance, "penetration_limit", sdaiINTEGER, &val)) return val; else return Nullable<IntValue>(); }
        void put_penetration_limit(IntValue value) { sdaiPutAttrBN(m_instance, "penetration_limit", sdaiINTEGER, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of feature_volume_with_process
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class feature_volume_with_process : public virtual feature_volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of feature_volume_with_process
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        feature_volume_with_process(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "feature_volume_with_process")
        {}

                /// <summary>
                /// Create new instace of feature_volume_with_process and returns object of this C++ class to interact with
                /// </summary>
        static feature_volume_with_process Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "feature_volume_with_process"); assert(inst); return inst; }

        cut get_process_definition();
        void put_process_definition(cut inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of swept_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class swept_surface : public virtual surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of swept_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        swept_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "swept_surface")
        {}

                /// <summary>
                /// Create new instace of swept_surface and returns object of this C++ class to interact with
                /// </summary>
        static swept_surface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "swept_surface"); assert(inst); return inst; }

        curve get_swept_curve();
        void put_swept_curve(curve inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of fixed_reference_swept_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class fixed_reference_swept_surface : public virtual swept_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of fixed_reference_swept_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        fixed_reference_swept_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "fixed_reference_swept_surface")
        {}

                /// <summary>
                /// Create new instace of fixed_reference_swept_surface and returns object of this C++ class to interact with
                /// </summary>
        static fixed_reference_swept_surface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "fixed_reference_swept_surface"); assert(inst); return inst; }

        curve get_directrix();
        void put_directrix(curve inst);

        direction get_fixed_reference();
        void put_fixed_reference(direction inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of group_assignment
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class group_assignment : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of group_assignment
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        group_assignment(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "group_assignment")
        {}


        group get_assigned_group();
        void put_assigned_group(group inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of flavour
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class flavour : public virtual group_assignment
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of flavour
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        flavour(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "flavour")
        {}

                /// <summary>
                /// Create new instace of flavour and returns object of this C++ class to interact with
                /// </summary>
        static flavour Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "flavour"); assert(inst); return inst; }

        //TList may be set_of_item_reference or list of converible elements
        template <typename TList> void get_items(TList& lst) { set_of_item_referenceSerializer<TList> sr; sr.FromAttr(lst, m_instance, "items"); }

        //TList may be set_of_item_reference or list of converible elements
        template <typename TList> void put_items(TList& lst) { set_of_item_referenceSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "items"); }

        //TArrayElem[] may be item_reference[] or array of convertible elements
        template <typename TArrayElem> void put_items(TArrayElem arr[], size_t n) { set_of_item_reference lst; ArrayToList(arr, n, lst); put_items(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of force_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class force_measure_with_unit : public virtual measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of force_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        force_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "force_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of force_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static force_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "force_measure_with_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of force_per_length_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class force_per_length_measure_with_unit : public virtual derived_measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of force_per_length_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        force_per_length_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "force_per_length_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of force_per_length_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static force_per_length_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "force_per_length_measure_with_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of force_per_length_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class force_per_length_unit : public virtual derived_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of force_per_length_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        force_per_length_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "force_per_length_unit")
        {}

                /// <summary>
                /// Create new instace of force_per_length_unit and returns object of this C++ class to interact with
                /// </summary>
        static force_per_length_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "force_per_length_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of force_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class force_unit : public virtual named_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of force_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        force_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "force_unit")
        {}

                /// <summary>
                /// Create new instace of force_unit and returns object of this C++ class to interact with
                /// </summary>
        static force_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "force_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of frequency_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class frequency_measure_with_unit : public virtual measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of frequency_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        frequency_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "frequency_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of frequency_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static frequency_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "frequency_measure_with_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of frequency_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class frequency_unit : public virtual named_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of frequency_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        frequency_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "frequency_unit")
        {}

                /// <summary>
                /// Create new instace of frequency_unit and returns object of this C++ class to interact with
                /// </summary>
        static frequency_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "frequency_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of functional_role
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class functional_role : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of functional_role
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        functional_role(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "functional_role")
        {}

                /// <summary>
                /// Create new instace of functional_role and returns object of this C++ class to interact with
                /// </summary>
        static functional_role Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "functional_role"); assert(inst); return inst; }

        label get_functional_role_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "functional_role_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_functional_role_name(label value) { sdaiPutAttrBN(m_instance, "functional_role_name", sdaiSTRING, value); }

        text get_functional_role_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "functional_role_description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_functional_role_description(text value) { sdaiPutAttrBN(m_instance, "functional_role_description", sdaiSTRING, value); }

        //TList may be set_of_assembly_design or list of converible elements
        template <typename TList> void get_role_for_assemblies(TList& lst) { set_of_assembly_designSerializer<TList> sr; sr.FromAttr(lst, m_instance, "role_for_assemblies"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of functional_role_documented
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class functional_role_documented : public virtual functional_role
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of functional_role_documented
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        functional_role_documented(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "functional_role_documented")
        {}

                /// <summary>
                /// Create new instace of functional_role_documented and returns object of this C++ class to interact with
                /// </summary>
        static functional_role_documented Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "functional_role_documented"); assert(inst); return inst; }

        document_usage_constraint get_document_reference();
        void put_document_reference(document_usage_constraint inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of geographical_location
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class geographical_location : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of geographical_location
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        geographical_location(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "geographical_location")
        {}


        length_measure_with_unit get_height_above_datum();
        void put_height_above_datum(length_measure_with_unit inst);

        label get_datum_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "datum_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_datum_name(label value) { sdaiPutAttrBN(m_instance, "datum_name", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of geometric_set
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class geometric_set : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of geometric_set
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        geometric_set(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "geometric_set")
        {}

                /// <summary>
                /// Create new instace of geometric_set and returns object of this C++ class to interact with
                /// </summary>
        static geometric_set Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "geometric_set"); assert(inst); return inst; }

        //TList may be set_of_geometric_set_select or list of converible elements
        template <typename TList> void get_elements(TList& lst) { set_of_geometric_set_selectSerializer<TList> sr; sr.FromAttr(lst, m_instance, "elements"); }

        //TList may be set_of_geometric_set_select or list of converible elements
        template <typename TList> void put_elements(TList& lst) { set_of_geometric_set_selectSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "elements"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of geometric_curve_set
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class geometric_curve_set : public virtual geometric_set
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of geometric_curve_set
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        geometric_curve_set(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "geometric_curve_set")
        {}

                /// <summary>
                /// Create new instace of geometric_curve_set and returns object of this C++ class to interact with
                /// </summary>
        static geometric_curve_set Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "geometric_curve_set"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of representation_context
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class representation_context : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of representation_context
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        representation_context(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "representation_context")
        {}

                /// <summary>
                /// Create new instace of representation_context and returns object of this C++ class to interact with
                /// </summary>
        static representation_context Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "representation_context"); assert(inst); return inst; }

        identifier get_context_identifier() { identifier val = NULL; if (sdaiGetAttrBN(m_instance, "context_identifier", sdaiSTRING, &val)) return val; else return NULL; }
        void put_context_identifier(identifier value) { sdaiPutAttrBN(m_instance, "context_identifier", sdaiSTRING, value); }

        text get_context_type() { text val = NULL; if (sdaiGetAttrBN(m_instance, "context_type", sdaiSTRING, &val)) return val; else return NULL; }
        void put_context_type(text value) { sdaiPutAttrBN(m_instance, "context_type", sdaiSTRING, value); }

        //TList may be set_of_representation or list of converible elements
        template <typename TList> void get_representations_in_context(TList& lst) { set_of_representationSerializer<TList> sr; sr.FromAttr(lst, m_instance, "representations_in_context"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of geometric_representation_context
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class geometric_representation_context : public virtual representation_context
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of geometric_representation_context
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        geometric_representation_context(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "geometric_representation_context")
        {}

                /// <summary>
                /// Create new instace of geometric_representation_context and returns object of this C++ class to interact with
                /// </summary>
        static geometric_representation_context Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "geometric_representation_context"); assert(inst); return inst; }

        Nullable<dimension_count> get_coordinate_space_dimension() { dimension_count val = (dimension_count) 0; if (sdaiGetAttrBN(m_instance, "coordinate_space_dimension", sdaiINTEGER, &val)) return val; else return Nullable<dimension_count>(); }
        void put_coordinate_space_dimension(dimension_count value) { sdaiPutAttrBN(m_instance, "coordinate_space_dimension", sdaiINTEGER, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of geometric_set_replica
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class geometric_set_replica : public virtual geometric_set
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of geometric_set_replica
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        geometric_set_replica(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "geometric_set_replica")
        {}

                /// <summary>
                /// Create new instace of geometric_set_replica and returns object of this C++ class to interact with
                /// </summary>
        static geometric_set_replica Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "geometric_set_replica"); assert(inst); return inst; }

        geometric_set get_parent_set();
        void put_parent_set(geometric_set inst);

        cartesian_transformation_operator get_transformation();
        void put_transformation(cartesian_transformation_operator inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of global_location
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class global_location : public virtual geographical_location
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of global_location
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        global_location(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "global_location")
        {}

                /// <summary>
                /// Create new instace of global_location and returns object of this C++ class to interact with
                /// </summary>
        static global_location Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "global_location"); assert(inst); return inst; }

        Nullable<degrees_rotation> get_latitude_degrees() { degrees_rotation val = (degrees_rotation) 0; if (sdaiGetAttrBN(m_instance, "latitude_degrees", sdaiINTEGER, &val)) return val; else return Nullable<degrees_rotation>(); }
        void put_latitude_degrees(degrees_rotation value) { sdaiPutAttrBN(m_instance, "latitude_degrees", sdaiINTEGER, &value); }

        Nullable<minutes_rotation> get_latitude_minutes() { minutes_rotation val = (minutes_rotation) 0; if (sdaiGetAttrBN(m_instance, "latitude_minutes", sdaiINTEGER, &val)) return val; else return Nullable<minutes_rotation>(); }
        void put_latitude_minutes(minutes_rotation value) { sdaiPutAttrBN(m_instance, "latitude_minutes", sdaiINTEGER, &value); }

        Nullable<seconds_rotation> get_latitude_seconds() { seconds_rotation val = (seconds_rotation) 0; if (sdaiGetAttrBN(m_instance, "latitude_seconds", sdaiREAL, &val)) return val; else return Nullable<seconds_rotation>(); }
        void put_latitude_seconds(seconds_rotation value) { sdaiPutAttrBN(m_instance, "latitude_seconds", sdaiREAL, &value); }

        Nullable<degrees_rotation> get_longitude_degrees() { degrees_rotation val = (degrees_rotation) 0; if (sdaiGetAttrBN(m_instance, "longitude_degrees", sdaiINTEGER, &val)) return val; else return Nullable<degrees_rotation>(); }
        void put_longitude_degrees(degrees_rotation value) { sdaiPutAttrBN(m_instance, "longitude_degrees", sdaiINTEGER, &value); }

        Nullable<minutes_rotation> get_longitude_minutes() { minutes_rotation val = (minutes_rotation) 0; if (sdaiGetAttrBN(m_instance, "longitude_minutes", sdaiINTEGER, &val)) return val; else return Nullable<minutes_rotation>(); }
        void put_longitude_minutes(minutes_rotation value) { sdaiPutAttrBN(m_instance, "longitude_minutes", sdaiINTEGER, &value); }

        Nullable<seconds_rotation> get_longitude_seconds() { seconds_rotation val = (seconds_rotation) 0; if (sdaiGetAttrBN(m_instance, "longitude_seconds", sdaiREAL, &val)) return val; else return Nullable<seconds_rotation>(); }
        void put_longitude_seconds(seconds_rotation value) { sdaiPutAttrBN(m_instance, "longitude_seconds", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of global_uncertainty_assigned_context
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class global_uncertainty_assigned_context : public virtual representation_context
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of global_uncertainty_assigned_context
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        global_uncertainty_assigned_context(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "global_uncertainty_assigned_context")
        {}

                /// <summary>
                /// Create new instace of global_uncertainty_assigned_context and returns object of this C++ class to interact with
                /// </summary>
        static global_uncertainty_assigned_context Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "global_uncertainty_assigned_context"); assert(inst); return inst; }

        //TList may be set_of_uncertainty_measure_with_unit or list of converible elements
        template <typename TList> void get_uncertainty(TList& lst) { set_of_uncertainty_measure_with_unitSerializer<TList> sr; sr.FromAttr(lst, m_instance, "uncertainty"); }

        //TList may be set_of_uncertainty_measure_with_unit or list of converible elements
        template <typename TList> void put_uncertainty(TList& lst) { set_of_uncertainty_measure_with_unitSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "uncertainty"); }

        //TArrayElem[] may be uncertainty_measure_with_unit[] or array of convertible elements
        template <typename TArrayElem> void put_uncertainty(TArrayElem arr[], size_t n) { set_of_uncertainty_measure_with_unit lst; ArrayToList(arr, n, lst); put_uncertainty(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of global_unit_assigned_context
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class global_unit_assigned_context : public virtual representation_context
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of global_unit_assigned_context
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        global_unit_assigned_context(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "global_unit_assigned_context")
        {}

                /// <summary>
                /// Create new instace of global_unit_assigned_context and returns object of this C++ class to interact with
                /// </summary>
        static global_unit_assigned_context Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "global_unit_assigned_context"); assert(inst); return inst; }

        //TList may be set_of_unit or list of converible elements
        template <typename TList> void get_units(TList& lst) { set_of_unitSerializer<TList> sr; sr.FromAttr(lst, m_instance, "units"); }

        //TList may be set_of_unit or list of converible elements
        template <typename TList> void put_units(TList& lst) { set_of_unitSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "units"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of grid
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class grid : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of grid
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        grid(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "grid")
        {}

                /// <summary>
                /// Create new instace of grid and returns object of this C++ class to interact with
                /// </summary>
        static grid Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "grid"); assert(inst); return inst; }

        label get_grid_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "grid_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_grid_name(label value) { sdaiPutAttrBN(m_instance, "grid_name", sdaiSTRING, value); }

        text get_grid_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "grid_description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_grid_description(text value) { sdaiPutAttrBN(m_instance, "grid_description", sdaiSTRING, value); }

        text get_grid_use() { text val = NULL; if (sdaiGetAttrBN(m_instance, "grid_use", sdaiSTRING, &val)) return val; else return NULL; }
        void put_grid_use(text value) { sdaiPutAttrBN(m_instance, "grid_use", sdaiSTRING, value); }

        //TList may be set_of_gridline or list of converible elements
        template <typename TList> void get_constituent_lines(TList& lst) { set_of_gridlineSerializer<TList> sr; sr.FromAttr(lst, m_instance, "constituent_lines"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of grid_intersection
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class grid_intersection : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of grid_intersection
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        grid_intersection(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "grid_intersection")
        {}

                /// <summary>
                /// Create new instace of grid_intersection and returns object of this C++ class to interact with
                /// </summary>
        static grid_intersection Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "grid_intersection"); assert(inst); return inst; }

        label get_grid_intersection_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "grid_intersection_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_grid_intersection_name(label value) { sdaiPutAttrBN(m_instance, "grid_intersection_name", sdaiSTRING, value); }

        //TList may be set_of_gridline or list of converible elements
        template <typename TList> void get_gridlines(TList& lst) { set_of_gridlineSerializer<TList> sr; sr.FromAttr(lst, m_instance, "gridlines"); }

        //TList may be set_of_gridline or list of converible elements
        template <typename TList> void put_gridlines(TList& lst) { set_of_gridlineSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "gridlines"); }

        //TArrayElem[] may be gridline[] or array of convertible elements
        template <typename TArrayElem> void put_gridlines(TArrayElem arr[], size_t n) { set_of_gridline lst; ArrayToList(arr, n, lst); put_gridlines(lst); }

        grid_level get_level();
        void put_level(grid_level inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of grid_intersection_resolved
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class grid_intersection_resolved : public virtual grid_intersection
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of grid_intersection_resolved
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        grid_intersection_resolved(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "grid_intersection_resolved")
        {}

                /// <summary>
                /// Create new instace of grid_intersection_resolved and returns object of this C++ class to interact with
                /// </summary>
        static grid_intersection_resolved Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "grid_intersection_resolved"); assert(inst); return inst; }

        geographical_location get_resolution_point();
        void put_resolution_point(geographical_location inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of plane
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class plane : public virtual elementary_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of plane
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        plane(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "plane")
        {}

                /// <summary>
                /// Create new instace of plane and returns object of this C++ class to interact with
                /// </summary>
        static plane Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "plane"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of grid_level
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class grid_level : public virtual plane
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of grid_level
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        grid_level(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "grid_level")
        {}

                /// <summary>
                /// Create new instace of grid_level and returns object of this C++ class to interact with
                /// </summary>
        static grid_level Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "grid_level"); assert(inst); return inst; }

        grid get_parent_grid();
        void put_parent_grid(grid inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of grid_of_building
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class grid_of_building : public virtual grid
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of grid_of_building
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        grid_of_building(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "grid_of_building")
        {}

                /// <summary>
                /// Create new instace of grid_of_building and returns object of this C++ class to interact with
                /// </summary>
        static grid_of_building Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "grid_of_building"); assert(inst); return inst; }

        building get_grid_for_building();
        void put_grid_for_building(building inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of grid_of_site
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class grid_of_site : public virtual grid
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of grid_of_site
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        grid_of_site(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "grid_of_site")
        {}

                /// <summary>
                /// Create new instace of grid_of_site and returns object of this C++ class to interact with
                /// </summary>
        static grid_of_site Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "grid_of_site"); assert(inst); return inst; }

        site get_grid_for_site();
        void put_grid_for_site(site inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of grid_of_structure
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class grid_of_structure : public virtual grid
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of grid_of_structure
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        grid_of_structure(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "grid_of_structure")
        {}

                /// <summary>
                /// Create new instace of grid_of_structure and returns object of this C++ class to interact with
                /// </summary>
        static grid_of_structure Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "grid_of_structure"); assert(inst); return inst; }

        structure get_grid_for_structure();
        void put_grid_for_structure(structure inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of grid_offset
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class grid_offset : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of grid_offset
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        grid_offset(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "grid_offset")
        {}

                /// <summary>
                /// Create new instace of grid_offset and returns object of this C++ class to interact with
                /// </summary>
        static grid_offset Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "grid_offset"); assert(inst); return inst; }

        grid_intersection get_intersection();
        void put_intersection(grid_intersection inst);

        //TList may be list_of_length_measure_with_unit or list of converible elements
        template <typename TList> void get_offset(TList& lst) { list_of_length_measure_with_unitSerializer<TList> sr; sr.FromAttr(lst, m_instance, "offset"); }

        //TList may be list_of_length_measure_with_unit or list of converible elements
        template <typename TList> void put_offset(TList& lst) { list_of_length_measure_with_unitSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "offset"); }

        //TArrayElem[] may be length_measure_with_unit[] or array of convertible elements
        template <typename TArrayElem> void put_offset(TArrayElem arr[], size_t n) { list_of_length_measure_with_unit lst; ArrayToList(arr, n, lst); put_offset(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of grid_orthogonal
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class grid_orthogonal : public virtual grid
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of grid_orthogonal
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        grid_orthogonal(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "grid_orthogonal")
        {}

                /// <summary>
                /// Create new instace of grid_orthogonal and returns object of this C++ class to interact with
                /// </summary>
        static grid_orthogonal Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "grid_orthogonal"); assert(inst); return inst; }

        //TList may be list_of_positive_length_measure_with_unit or list of converible elements
        template <typename TList> void get_spacing_1(TList& lst) { list_of_positive_length_measure_with_unitSerializer<TList> sr; sr.FromAttr(lst, m_instance, "spacing_1"); }

        //TList may be list_of_positive_length_measure_with_unit or list of converible elements
        template <typename TList> void put_spacing_1(TList& lst) { list_of_positive_length_measure_with_unitSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "spacing_1"); }

        //TArrayElem[] may be positive_length_measure_with_unit[] or array of convertible elements
        template <typename TArrayElem> void put_spacing_1(TArrayElem arr[], size_t n) { list_of_positive_length_measure_with_unit lst; ArrayToList(arr, n, lst); put_spacing_1(lst); }

        //TList may be list_of_positive_length_measure_with_unit or list of converible elements
        template <typename TList> void get_spacing_2(TList& lst) { list_of_positive_length_measure_with_unitSerializer<TList> sr; sr.FromAttr(lst, m_instance, "spacing_2"); }

        //TList may be list_of_positive_length_measure_with_unit or list of converible elements
        template <typename TList> void put_spacing_2(TList& lst) { list_of_positive_length_measure_with_unitSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "spacing_2"); }

        //TArrayElem[] may be positive_length_measure_with_unit[] or array of convertible elements
        template <typename TArrayElem> void put_spacing_2(TArrayElem arr[], size_t n) { list_of_positive_length_measure_with_unit lst; ArrayToList(arr, n, lst); put_spacing_2(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of grid_radial
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class grid_radial : public virtual grid
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of grid_radial
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        grid_radial(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "grid_radial")
        {}

                /// <summary>
                /// Create new instace of grid_radial and returns object of this C++ class to interact with
                /// </summary>
        static grid_radial Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "grid_radial"); assert(inst); return inst; }

        //TList may be list_of_plane_angle_measure_with_unit or list of converible elements
        template <typename TList> void get_spacing_1(TList& lst) { list_of_plane_angle_measure_with_unitSerializer<TList> sr; sr.FromAttr(lst, m_instance, "spacing_1"); }

        //TList may be list_of_plane_angle_measure_with_unit or list of converible elements
        template <typename TList> void put_spacing_1(TList& lst) { list_of_plane_angle_measure_with_unitSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "spacing_1"); }

        //TArrayElem[] may be plane_angle_measure_with_unit[] or array of convertible elements
        template <typename TArrayElem> void put_spacing_1(TArrayElem arr[], size_t n) { list_of_plane_angle_measure_with_unit lst; ArrayToList(arr, n, lst); put_spacing_1(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of grid_skewed
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class grid_skewed : public virtual grid
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of grid_skewed
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        grid_skewed(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "grid_skewed")
        {}

                /// <summary>
                /// Create new instace of grid_skewed and returns object of this C++ class to interact with
                /// </summary>
        static grid_skewed Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "grid_skewed"); assert(inst); return inst; }

        plane_angle_measure_with_unit get_skew_angle();
        void put_skew_angle(plane_angle_measure_with_unit inst);

        //TList may be list_of_positive_length_measure_with_unit or list of converible elements
        template <typename TList> void get_spacing_1(TList& lst) { list_of_positive_length_measure_with_unitSerializer<TList> sr; sr.FromAttr(lst, m_instance, "spacing_1"); }

        //TList may be list_of_positive_length_measure_with_unit or list of converible elements
        template <typename TList> void put_spacing_1(TList& lst) { list_of_positive_length_measure_with_unitSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "spacing_1"); }

        //TArrayElem[] may be positive_length_measure_with_unit[] or array of convertible elements
        template <typename TArrayElem> void put_spacing_1(TArrayElem arr[], size_t n) { list_of_positive_length_measure_with_unit lst; ArrayToList(arr, n, lst); put_spacing_1(lst); }

        //TList may be list_of_positive_length_measure_with_unit or list of converible elements
        template <typename TList> void get_spacing_2(TList& lst) { list_of_positive_length_measure_with_unitSerializer<TList> sr; sr.FromAttr(lst, m_instance, "spacing_2"); }

        //TList may be list_of_positive_length_measure_with_unit or list of converible elements
        template <typename TList> void put_spacing_2(TList& lst) { list_of_positive_length_measure_with_unitSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "spacing_2"); }

        //TArrayElem[] may be positive_length_measure_with_unit[] or array of convertible elements
        template <typename TArrayElem> void put_spacing_2(TArrayElem arr[], size_t n) { list_of_positive_length_measure_with_unit lst; ArrayToList(arr, n, lst); put_spacing_2(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of gridline
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class gridline : public virtual plane
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of gridline
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        gridline(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "gridline")
        {}

                /// <summary>
                /// Create new instace of gridline and returns object of this C++ class to interact with
                /// </summary>
        static gridline Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "gridline"); assert(inst); return inst; }

        grid get_parent_grid();
        void put_parent_grid(grid inst);

        gridline get_preceding_line();
        void put_preceding_line(gridline inst);

        //TList may be set_of_gridline or list of converible elements
        template <typename TList> void get_succeeding_line(TList& lst) { set_of_gridlineSerializer<TList> sr; sr.FromAttr(lst, m_instance, "succeeding_line"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of group
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class group : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of group
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        group(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "group")
        {}

                /// <summary>
                /// Create new instace of group and returns object of this C++ class to interact with
                /// </summary>
        static group Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "group"); assert(inst); return inst; }

        label get_group_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "group_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_group_name(label value) { sdaiPutAttrBN(m_instance, "group_name", sdaiSTRING, value); }

        text get_group_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "group_description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_group_description(text value) { sdaiPutAttrBN(m_instance, "group_description", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of group_assignment_actioned
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class group_assignment_actioned : public virtual group_assignment
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of group_assignment_actioned
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        group_assignment_actioned(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "group_assignment_actioned")
        {}

                /// <summary>
                /// Create new instace of group_assignment_actioned and returns object of this C++ class to interact with
                /// </summary>
        static group_assignment_actioned Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "group_assignment_actioned"); assert(inst); return inst; }

        action get_assigned_action();
        void put_assigned_action(action inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of group_assignment_approved
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class group_assignment_approved : public virtual group_assignment
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of group_assignment_approved
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        group_assignment_approved(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "group_assignment_approved")
        {}

                /// <summary>
                /// Create new instace of group_assignment_approved and returns object of this C++ class to interact with
                /// </summary>
        static group_assignment_approved Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "group_assignment_approved"); assert(inst); return inst; }

        approval get_assigned_approval();
        void put_assigned_approval(approval inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of group_of_analysis_data
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class group_of_analysis_data : public virtual group_assignment
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of group_of_analysis_data
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        group_of_analysis_data(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "group_of_analysis_data")
        {}

                /// <summary>
                /// Create new instace of group_of_analysis_data and returns object of this C++ class to interact with
                /// </summary>
        static group_of_analysis_data Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "group_of_analysis_data"); assert(inst); return inst; }

        //TList may be set_of_select_analysis_item or list of converible elements
        template <typename TList> void get_items(TList& lst) { set_of_select_analysis_itemSerializer<TList> sr; sr.FromAttr(lst, m_instance, "items"); }

        //TList may be set_of_select_analysis_item or list of converible elements
        template <typename TList> void put_items(TList& lst) { set_of_select_analysis_itemSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "items"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of group_of_design_data
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class group_of_design_data : public virtual group_assignment
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of group_of_design_data
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        group_of_design_data(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "group_of_design_data")
        {}

                /// <summary>
                /// Create new instace of group_of_design_data and returns object of this C++ class to interact with
                /// </summary>
        static group_of_design_data Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "group_of_design_data"); assert(inst); return inst; }

        //TList may be set_of_select_design_item or list of converible elements
        template <typename TList> void get_items(TList& lst) { set_of_select_design_itemSerializer<TList> sr; sr.FromAttr(lst, m_instance, "items"); }

        //TList may be set_of_select_design_item or list of converible elements
        template <typename TList> void put_items(TList& lst) { set_of_select_design_itemSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "items"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of group_of_generic_data
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class group_of_generic_data : public virtual group_assignment
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of group_of_generic_data
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        group_of_generic_data(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "group_of_generic_data")
        {}

                /// <summary>
                /// Create new instace of group_of_generic_data and returns object of this C++ class to interact with
                /// </summary>
        static group_of_generic_data Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "group_of_generic_data"); assert(inst); return inst; }

        //TList may be set_of_select_generic_item or list of converible elements
        template <typename TList> void get_items(TList& lst) { set_of_select_generic_itemSerializer<TList> sr; sr.FromAttr(lst, m_instance, "items"); }

        //TList may be set_of_select_generic_item or list of converible elements
        template <typename TList> void put_items(TList& lst) { set_of_select_generic_itemSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "items"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of group_of_physical_data
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class group_of_physical_data : public virtual group_assignment
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of group_of_physical_data
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        group_of_physical_data(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "group_of_physical_data")
        {}

                /// <summary>
                /// Create new instace of group_of_physical_data and returns object of this C++ class to interact with
                /// </summary>
        static group_of_physical_data Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "group_of_physical_data"); assert(inst); return inst; }

        //TList may be set_of_select_physical_item or list of converible elements
        template <typename TList> void get_items(TList& lst) { set_of_select_physical_itemSerializer<TList> sr; sr.FromAttr(lst, m_instance, "items"); }

        //TList may be set_of_select_physical_item or list of converible elements
        template <typename TList> void put_items(TList& lst) { set_of_select_physical_itemSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "items"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of group_of_project_definition_data
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class group_of_project_definition_data : public virtual group_assignment
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of group_of_project_definition_data
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        group_of_project_definition_data(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "group_of_project_definition_data")
        {}

                /// <summary>
                /// Create new instace of group_of_project_definition_data and returns object of this C++ class to interact with
                /// </summary>
        static group_of_project_definition_data Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "group_of_project_definition_data"); assert(inst); return inst; }

        //TList may be set_of_select_project_definition_item or list of converible elements
        template <typename TList> void get_items(TList& lst) { set_of_select_project_definition_itemSerializer<TList> sr; sr.FromAttr(lst, m_instance, "items"); }

        //TList may be set_of_select_project_definition_item or list of converible elements
        template <typename TList> void put_items(TList& lst) { set_of_select_project_definition_itemSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "items"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of group_of_structural_data
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class group_of_structural_data : public virtual group_assignment
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of group_of_structural_data
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        group_of_structural_data(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "group_of_structural_data")
        {}

                /// <summary>
                /// Create new instace of group_of_structural_data and returns object of this C++ class to interact with
                /// </summary>
        static group_of_structural_data Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "group_of_structural_data"); assert(inst); return inst; }

        //TList may be set_of_select_structural_item or list of converible elements
        template <typename TList> void get_items(TList& lst) { set_of_select_structural_itemSerializer<TList> sr; sr.FromAttr(lst, m_instance, "items"); }

        //TList may be set_of_select_structural_item or list of converible elements
        template <typename TList> void put_items(TList& lst) { set_of_select_structural_itemSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "items"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of group_relationship
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class group_relationship : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of group_relationship
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        group_relationship(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "group_relationship")
        {}

                /// <summary>
                /// Create new instace of group_relationship and returns object of this C++ class to interact with
                /// </summary>
        static group_relationship Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "group_relationship"); assert(inst); return inst; }

        label get_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_name(label value) { sdaiPutAttrBN(m_instance, "name", sdaiSTRING, value); }

        text get_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_description(text value) { sdaiPutAttrBN(m_instance, "description", sdaiSTRING, value); }

        group get_relating_group();
        void put_relating_group(group inst);

        group get_related_group();
        void put_related_group(group inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of group_usage
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class group_usage : public virtual group_relationship
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of group_usage
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        group_usage(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "group_usage")
        {}

                /// <summary>
                /// Create new instace of group_usage and returns object of this C++ class to interact with
                /// </summary>
        static group_usage Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "group_usage"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of half_space_2d
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class half_space_2d : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of half_space_2d
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        half_space_2d(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "half_space_2d")
        {}

                /// <summary>
                /// Create new instace of half_space_2d and returns object of this C++ class to interact with
                /// </summary>
        static half_space_2d Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "half_space_2d"); assert(inst); return inst; }

        curve get_base_curve();
        void put_base_curve(curve inst);

        Nullable<bool> get_agreement_flag() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "agreement_flag", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_agreement_flag(bool value) { sdaiPutAttrBN(m_instance, "agreement_flag", sdaiBOOLEAN, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of hexahedron_volume
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class hexahedron_volume : public virtual volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of hexahedron_volume
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        hexahedron_volume(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "hexahedron_volume")
        {}

                /// <summary>
                /// Create new instace of hexahedron_volume and returns object of this C++ class to interact with
                /// </summary>
        static hexahedron_volume Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "hexahedron_volume"); assert(inst); return inst; }

        //TList may be list_of_cartesian_point or list of converible elements
        template <typename TList> void get_points(TList& lst) { list_of_cartesian_pointSerializer<TList> sr; sr.FromAttr(lst, m_instance, "points"); }

        //TList may be list_of_cartesian_point or list of converible elements
        template <typename TList> void put_points(TList& lst) { list_of_cartesian_pointSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "points"); }

        //TArrayElem[] may be cartesian_point[] or array of convertible elements
        template <typename TArrayElem> void put_points(TArrayElem arr[], size_t n) { list_of_cartesian_point lst; ArrayToList(arr, n, lst); put_points(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of hyperbola
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class hyperbola : public virtual conic
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of hyperbola
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        hyperbola(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "hyperbola")
        {}

                /// <summary>
                /// Create new instace of hyperbola and returns object of this C++ class to interact with
                /// </summary>
        static hyperbola Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "hyperbola"); assert(inst); return inst; }

        Nullable<positive_length_measure> get_semi_axis() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "semi_axis", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_semi_axis(positive_length_measure value) { sdaiPutAttrBN(m_instance, "semi_axis", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_semi_imag_axis() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "semi_imag_axis", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_semi_imag_axis(positive_length_measure value) { sdaiPutAttrBN(m_instance, "semi_imag_axis", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of id_attribute
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class id_attribute : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of id_attribute
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        id_attribute(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "id_attribute")
        {}

                /// <summary>
                /// Create new instace of id_attribute and returns object of this C++ class to interact with
                /// </summary>
        static id_attribute Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "id_attribute"); assert(inst); return inst; }

        identifier get_attribute_value() { identifier val = NULL; if (sdaiGetAttrBN(m_instance, "attribute_value", sdaiSTRING, &val)) return val; else return NULL; }
        void put_attribute_value(identifier value) { sdaiPutAttrBN(m_instance, "attribute_value", sdaiSTRING, value); }

        id_attribute_select_get get_identified_item() { return id_attribute_select_get(m_instance, "identified_item", NULL); }
        id_attribute_select_put put_identified_item() { return id_attribute_select_put(m_instance, "identified_item", NULL); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of inertia_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class inertia_measure_with_unit : public virtual derived_measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of inertia_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        inertia_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "inertia_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of inertia_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static inertia_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "inertia_measure_with_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of inertia_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class inertia_unit : public virtual derived_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of inertia_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        inertia_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "inertia_unit")
        {}

                /// <summary>
                /// Create new instace of inertia_unit and returns object of this C++ class to interact with
                /// </summary>
        static inertia_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "inertia_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of intersection_curve
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class intersection_curve : public virtual surface_curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of intersection_curve
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        intersection_curve(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "intersection_curve")
        {}

                /// <summary>
                /// Create new instace of intersection_curve and returns object of this C++ class to interact with
                /// </summary>
        static intersection_curve Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "intersection_curve"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of item_cost_code
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class item_cost_code : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of item_cost_code
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        item_cost_code(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "item_cost_code")
        {}

                /// <summary>
                /// Create new instace of item_cost_code and returns object of this C++ class to interact with
                /// </summary>
        static item_cost_code Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "item_cost_code"); assert(inst); return inst; }

        label get_cost_code() { label val = NULL; if (sdaiGetAttrBN(m_instance, "cost_code", sdaiSTRING, &val)) return val; else return NULL; }
        void put_cost_code(label value) { sdaiPutAttrBN(m_instance, "cost_code", sdaiSTRING, value); }

        text get_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_description(text value) { sdaiPutAttrBN(m_instance, "description", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of item_cost_code_assigned
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class item_cost_code_assigned : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of item_cost_code_assigned
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        item_cost_code_assigned(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "item_cost_code_assigned")
        {}

                /// <summary>
                /// Create new instace of item_cost_code_assigned and returns object of this C++ class to interact with
                /// </summary>
        static item_cost_code_assigned Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "item_cost_code_assigned"); assert(inst); return inst; }

        item_cost_code get_code();
        void put_code(item_cost_code inst);

        structural_frame_item get_costed_item();
        void put_costed_item(structural_frame_item inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of item_cost_code_with_source
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class item_cost_code_with_source : public virtual item_cost_code
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of item_cost_code_with_source
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        item_cost_code_with_source(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "item_cost_code_with_source")
        {}

                /// <summary>
                /// Create new instace of item_cost_code_with_source and returns object of this C++ class to interact with
                /// </summary>
        static item_cost_code_with_source Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "item_cost_code_with_source"); assert(inst); return inst; }

        item_ref_source get_source();
        void put_source(item_ref_source inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of item_defined_transformation
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class item_defined_transformation : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of item_defined_transformation
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        item_defined_transformation(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "item_defined_transformation")
        {}

                /// <summary>
                /// Create new instace of item_defined_transformation and returns object of this C++ class to interact with
                /// </summary>
        static item_defined_transformation Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "item_defined_transformation"); assert(inst); return inst; }

        label get_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_name(label value) { sdaiPutAttrBN(m_instance, "name", sdaiSTRING, value); }

        text get_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_description(text value) { sdaiPutAttrBN(m_instance, "description", sdaiSTRING, value); }

        representation_item get_transform_item_1();
        void put_transform_item_1(representation_item inst);

        representation_item get_transform_item_2();
        void put_transform_item_2(representation_item inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of item_property
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class item_property : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of item_property
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        item_property(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "item_property")
        {}

                /// <summary>
                /// Create new instace of item_property and returns object of this C++ class to interact with
                /// </summary>
        static item_property Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "item_property"); assert(inst); return inst; }

        label get_property_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "property_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_property_name(label value) { sdaiPutAttrBN(m_instance, "property_name", sdaiSTRING, value); }

        text get_property_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "property_description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_property_description(text value) { sdaiPutAttrBN(m_instance, "property_description", sdaiSTRING, value); }

        measure_select_get get_property_value() { return measure_select_get(m_instance, "property_value", NULL); }
        measure_select_put put_property_value() { return measure_select_put(m_instance, "property_value", NULL); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of item_property_assigned
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class item_property_assigned : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of item_property_assigned
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        item_property_assigned(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "item_property_assigned")
        {}

                /// <summary>
                /// Create new instace of item_property_assigned and returns object of this C++ class to interact with
                /// </summary>
        static item_property_assigned Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "item_property_assigned"); assert(inst); return inst; }

        item_property get_property();
        void put_property(item_property inst);

        structural_frame_item get_item();
        void put_item(structural_frame_item inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of item_property_with_source
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class item_property_with_source : public virtual item_property
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of item_property_with_source
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        item_property_with_source(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "item_property_with_source")
        {}

                /// <summary>
                /// Create new instace of item_property_with_source and returns object of this C++ class to interact with
                /// </summary>
        static item_property_with_source Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "item_property_with_source"); assert(inst); return inst; }

        item_ref_source get_source();
        void put_source(item_ref_source inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of item_ref_source
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class item_ref_source : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of item_ref_source
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        item_ref_source(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "item_ref_source")
        {}

    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of item_ref_source_documented
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class item_ref_source_documented : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of item_ref_source_documented
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        item_ref_source_documented(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "item_ref_source_documented")
        {}

                /// <summary>
                /// Create new instace of item_ref_source_documented and returns object of this C++ class to interact with
                /// </summary>
        static item_ref_source_documented Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "item_ref_source_documented"); assert(inst); return inst; }

        item_ref_source get_documented_item_source();
        void put_documented_item_source(item_ref_source inst);

        document_usage_constraint get_document_reference();
        void put_document_reference(document_usage_constraint inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of item_ref_source_library
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class item_ref_source_library : public virtual item_ref_source
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of item_ref_source_library
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        item_ref_source_library(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "item_ref_source_library")
        {}

                /// <summary>
                /// Create new instace of item_ref_source_library and returns object of this C++ class to interact with
                /// </summary>
        static item_ref_source_library Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "item_ref_source_library"); assert(inst); return inst; }

        person_and_organization get_library_owner();
        void put_library_owner(person_and_organization inst);

        label get_library_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "library_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_library_name(label value) { sdaiPutAttrBN(m_instance, "library_name", sdaiSTRING, value); }

        calendar_date get_date_of_library();
        void put_date_of_library(calendar_date inst);

        label get_version_of_library() { label val = NULL; if (sdaiGetAttrBN(m_instance, "version_of_library", sdaiSTRING, &val)) return val; else return NULL; }
        void put_version_of_library(label value) { sdaiPutAttrBN(m_instance, "version_of_library", sdaiSTRING, value); }

        //TList may be set_of_item_reference_library or list of converible elements
        template <typename TList> void get_library_items(TList& lst) { set_of_item_reference_librarySerializer<TList> sr; sr.FromAttr(lst, m_instance, "library_items"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of item_ref_source_proprietary
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class item_ref_source_proprietary : public virtual item_ref_source
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of item_ref_source_proprietary
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        item_ref_source_proprietary(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "item_ref_source_proprietary")
        {}

                /// <summary>
                /// Create new instace of item_ref_source_proprietary and returns object of this C++ class to interact with
                /// </summary>
        static item_ref_source_proprietary Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "item_ref_source_proprietary"); assert(inst); return inst; }

        organization get_manufacturers_name();
        void put_manufacturers_name(organization inst);

        label get_manufacturers_range() { label val = NULL; if (sdaiGetAttrBN(m_instance, "manufacturers_range", sdaiSTRING, &val)) return val; else return NULL; }
        void put_manufacturers_range(label value) { sdaiPutAttrBN(m_instance, "manufacturers_range", sdaiSTRING, value); }

        Nullable<year_number> get_year_of_range() { year_number val = (year_number) 0; if (sdaiGetAttrBN(m_instance, "year_of_range", sdaiINTEGER, &val)) return val; else return Nullable<year_number>(); }
        void put_year_of_range(year_number value) { sdaiPutAttrBN(m_instance, "year_of_range", sdaiINTEGER, &value); }

        label get_version_of_range() { label val = NULL; if (sdaiGetAttrBN(m_instance, "version_of_range", sdaiSTRING, &val)) return val; else return NULL; }
        void put_version_of_range(label value) { sdaiPutAttrBN(m_instance, "version_of_range", sdaiSTRING, value); }

        //TList may be set_of_item_reference_proprietary or list of converible elements
        template <typename TList> void get_proprietary_items(TList& lst) { set_of_item_reference_proprietarySerializer<TList> sr; sr.FromAttr(lst, m_instance, "proprietary_items"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of item_ref_source_standard
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class item_ref_source_standard : public virtual item_ref_source
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of item_ref_source_standard
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        item_ref_source_standard(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "item_ref_source_standard")
        {}

                /// <summary>
                /// Create new instace of item_ref_source_standard and returns object of this C++ class to interact with
                /// </summary>
        static item_ref_source_standard Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "item_ref_source_standard"); assert(inst); return inst; }

        label get_standardization_organization() { label val = NULL; if (sdaiGetAttrBN(m_instance, "standardization_organization", sdaiSTRING, &val)) return val; else return NULL; }
        void put_standardization_organization(label value) { sdaiPutAttrBN(m_instance, "standardization_organization", sdaiSTRING, value); }

        label get_name_of_standard() { label val = NULL; if (sdaiGetAttrBN(m_instance, "name_of_standard", sdaiSTRING, &val)) return val; else return NULL; }
        void put_name_of_standard(label value) { sdaiPutAttrBN(m_instance, "name_of_standard", sdaiSTRING, value); }

        Nullable<year_number> get_year_of_standard() { year_number val = (year_number) 0; if (sdaiGetAttrBN(m_instance, "year_of_standard", sdaiINTEGER, &val)) return val; else return Nullable<year_number>(); }
        void put_year_of_standard(year_number value) { sdaiPutAttrBN(m_instance, "year_of_standard", sdaiINTEGER, &value); }

        label get_version_of_standard() { label val = NULL; if (sdaiGetAttrBN(m_instance, "version_of_standard", sdaiSTRING, &val)) return val; else return NULL; }
        void put_version_of_standard(label value) { sdaiPutAttrBN(m_instance, "version_of_standard", sdaiSTRING, value); }

        //TList may be set_of_item_reference_standard or list of converible elements
        template <typename TList> void get_standard_items(TList& lst) { set_of_item_reference_standardSerializer<TList> sr; sr.FromAttr(lst, m_instance, "standard_items"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of item_reference
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class item_reference : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of item_reference
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        item_reference(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "item_reference")
        {}

                /// <summary>
                /// Create new instace of item_reference and returns object of this C++ class to interact with
                /// </summary>
        static item_reference Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "item_reference"); assert(inst); return inst; }

        identifier get_ref_() { identifier val = NULL; if (sdaiGetAttrBN(m_instance, "ref_", sdaiSTRING, &val)) return val; else return NULL; }
        void put_ref_(identifier value) { sdaiPutAttrBN(m_instance, "ref_", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of item_reference_assigned
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class item_reference_assigned : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of item_reference_assigned
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        item_reference_assigned(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "item_reference_assigned")
        {}

                /// <summary>
                /// Create new instace of item_reference_assigned and returns object of this C++ class to interact with
                /// </summary>
        static item_reference_assigned Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "item_reference_assigned"); assert(inst); return inst; }

        item_reference get_assigned_reference();
        void put_assigned_reference(item_reference inst);

        structural_frame_item get_assigned_to_item();
        void put_assigned_to_item(structural_frame_item inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of item_reference_library
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class item_reference_library : public virtual item_reference
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of item_reference_library
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        item_reference_library(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "item_reference_library")
        {}

                /// <summary>
                /// Create new instace of item_reference_library and returns object of this C++ class to interact with
                /// </summary>
        static item_reference_library Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "item_reference_library"); assert(inst); return inst; }

        item_ref_source_library get_source();
        void put_source(item_ref_source_library inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of item_reference_proprietary
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class item_reference_proprietary : public virtual item_reference
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of item_reference_proprietary
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        item_reference_proprietary(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "item_reference_proprietary")
        {}

                /// <summary>
                /// Create new instace of item_reference_proprietary and returns object of this C++ class to interact with
                /// </summary>
        static item_reference_proprietary Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "item_reference_proprietary"); assert(inst); return inst; }

        item_ref_source_proprietary get_source();
        void put_source(item_ref_source_proprietary inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of item_reference_standard
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class item_reference_standard : public virtual item_reference
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of item_reference_standard
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        item_reference_standard(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "item_reference_standard")
        {}

                /// <summary>
                /// Create new instace of item_reference_standard and returns object of this C++ class to interact with
                /// </summary>
        static item_reference_standard Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "item_reference_standard"); assert(inst); return inst; }

        item_ref_source_standard get_source();
        void put_source(item_ref_source_standard inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of joint_system
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class joint_system : public virtual structural_frame_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of joint_system
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        joint_system(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "joint_system")
        {}

                /// <summary>
                /// Create new instace of joint_system and returns object of this C++ class to interact with
                /// </summary>
        static joint_system Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "joint_system"); assert(inst); return inst; }

        Nullable<shop_or_site> get_place_of_assembly() { int v = getENUM("place_of_assembly", shop_or_site_); if (v >= 0) return (shop_or_site) v; else return Nullable<shop_or_site>(); }
        void put_place_of_assembly(shop_or_site value) { TextValue val = shop_or_site_[(int) value]; sdaiPutAttrBN(m_instance, "place_of_assembly", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of joint_system_amorphous
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class joint_system_amorphous : public virtual joint_system
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of joint_system_amorphous
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        joint_system_amorphous(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "joint_system_amorphous")
        {}

                /// <summary>
                /// Create new instace of joint_system_amorphous and returns object of this C++ class to interact with
                /// </summary>
        static joint_system_amorphous Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "joint_system_amorphous"); assert(inst); return inst; }

        chemical_mechanism get_specification();
        void put_specification(chemical_mechanism inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of joint_system_chemical
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class joint_system_chemical : public virtual joint_system
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of joint_system_chemical
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        joint_system_chemical(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "joint_system_chemical")
        {}

                /// <summary>
                /// Create new instace of joint_system_chemical and returns object of this C++ class to interact with
                /// </summary>
        static joint_system_chemical Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "joint_system_chemical"); assert(inst); return inst; }

        surface get_joining_surface();
        void put_joining_surface(surface inst);

        surface get_joined_surface();
        void put_joined_surface(surface inst);

        //TList may be list_of_chemical_mechanism or list of converible elements
        template <typename TList> void get_specification(TList& lst) { list_of_chemical_mechanismSerializer<TList> sr; sr.FromAttr(lst, m_instance, "specification"); }

        //TList may be list_of_chemical_mechanism or list of converible elements
        template <typename TList> void put_specification(TList& lst) { list_of_chemical_mechanismSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "specification"); }

        //TArrayElem[] may be chemical_mechanism[] or array of convertible elements
        template <typename TArrayElem> void put_specification(TArrayElem arr[], size_t n) { list_of_chemical_mechanism lst; ArrayToList(arr, n, lst); put_specification(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of joint_system_complex
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class joint_system_complex : public virtual joint_system
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of joint_system_complex
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        joint_system_complex(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "joint_system_complex")
        {}

                /// <summary>
                /// Create new instace of joint_system_complex and returns object of this C++ class to interact with
                /// </summary>
        static joint_system_complex Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "joint_system_complex"); assert(inst); return inst; }

        //TList may be list_of_joint_system or list of converible elements
        template <typename TList> void get_systems(TList& lst) { list_of_joint_systemSerializer<TList> sr; sr.FromAttr(lst, m_instance, "systems"); }

        //TList may be list_of_joint_system or list of converible elements
        template <typename TList> void put_systems(TList& lst) { list_of_joint_systemSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "systems"); }

        //TArrayElem[] may be joint_system[] or array of convertible elements
        template <typename TArrayElem> void put_systems(TArrayElem arr[], size_t n) { list_of_joint_system lst; ArrayToList(arr, n, lst); put_systems(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of joint_system_mechanical
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class joint_system_mechanical : public virtual joint_system
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of joint_system_mechanical
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        joint_system_mechanical(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "joint_system_mechanical")
        {}

                /// <summary>
                /// Create new instace of joint_system_mechanical and returns object of this C++ class to interact with
                /// </summary>
        static joint_system_mechanical Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "joint_system_mechanical"); assert(inst); return inst; }

        //TList may be list_of_point or list of converible elements
        template <typename TList> void get_layout_points(TList& lst) { list_of_pointSerializer<TList> sr; sr.FromAttr(lst, m_instance, "layout_points"); }

        //TList may be list_of_point or list of converible elements
        template <typename TList> void put_layout_points(TList& lst) { list_of_pointSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "layout_points"); }

        //TArrayElem[] may be point[] or array of convertible elements
        template <typename TArrayElem> void put_layout_points(TArrayElem arr[], size_t n) { list_of_point lst; ArrayToList(arr, n, lst); put_layout_points(lst); }

        fastener_mechanism get_mechanism();
        void put_mechanism(fastener_mechanism inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of joint_system_welded
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class joint_system_welded : public virtual joint_system
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of joint_system_welded
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        joint_system_welded(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "joint_system_welded")
        {}

                /// <summary>
                /// Create new instace of joint_system_welded and returns object of this C++ class to interact with
                /// </summary>
        static joint_system_welded Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "joint_system_welded"); assert(inst); return inst; }

        weld_mechanism get_weld_specification();
        void put_weld_specification(weld_mechanism inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of joint_system_welded_linear
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class joint_system_welded_linear : public virtual joint_system_welded
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of joint_system_welded_linear
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        joint_system_welded_linear(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "joint_system_welded_linear")
        {}

                /// <summary>
                /// Create new instace of joint_system_welded_linear and returns object of this C++ class to interact with
                /// </summary>
        static joint_system_welded_linear Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "joint_system_welded_linear"); assert(inst); return inst; }

        composite_curve get_weld_path();
        void put_weld_path(composite_curve inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of joint_system_welded_point
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class joint_system_welded_point : public virtual joint_system_welded
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of joint_system_welded_point
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        joint_system_welded_point(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "joint_system_welded_point")
        {}

                /// <summary>
                /// Create new instace of joint_system_welded_point and returns object of this C++ class to interact with
                /// </summary>
        static joint_system_welded_point Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "joint_system_welded_point"); assert(inst); return inst; }

        point get_weld_position();
        void put_weld_position(point inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of joint_system_welded_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class joint_system_welded_surface : public virtual joint_system_welded
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of joint_system_welded_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        joint_system_welded_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "joint_system_welded_surface")
        {}

                /// <summary>
                /// Create new instace of joint_system_welded_surface and returns object of this C++ class to interact with
                /// </summary>
        static joint_system_welded_surface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "joint_system_welded_surface"); assert(inst); return inst; }

        bounded_surface get_weld_surface();
        void put_weld_surface(bounded_surface inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of joint_system_welded_with_shape
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class joint_system_welded_with_shape : public virtual joint_system_welded
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of joint_system_welded_with_shape
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        joint_system_welded_with_shape(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "joint_system_welded_with_shape")
        {}

                /// <summary>
                /// Create new instace of joint_system_welded_with_shape and returns object of this C++ class to interact with
                /// </summary>
        static joint_system_welded_with_shape Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "joint_system_welded_with_shape"); assert(inst); return inst; }

        shape_representation_with_units get_weld_shape();
        void put_weld_shape(shape_representation_with_units inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of length_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class length_measure_with_unit : public virtual measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of length_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        length_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "length_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of length_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static length_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "length_measure_with_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of length_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class length_unit : public virtual named_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of length_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        length_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "length_unit")
        {}

                /// <summary>
                /// Create new instace of length_unit and returns object of this C++ class to interact with
                /// </summary>
        static length_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "length_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of line
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class line : public virtual curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of line
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        line(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "line")
        {}

                /// <summary>
                /// Create new instace of line and returns object of this C++ class to interact with
                /// </summary>
        static line Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "line"); assert(inst); return inst; }

        cartesian_point get_pnt();
        void put_pnt(cartesian_point inst);

        vector get_dir();
        void put_dir(vector inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of linear_acceleration_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class linear_acceleration_measure_with_unit : public virtual derived_measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of linear_acceleration_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        linear_acceleration_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "linear_acceleration_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of linear_acceleration_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static linear_acceleration_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "linear_acceleration_measure_with_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of linear_acceleration_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class linear_acceleration_unit : public virtual derived_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of linear_acceleration_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        linear_acceleration_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "linear_acceleration_unit")
        {}

                /// <summary>
                /// Create new instace of linear_acceleration_unit and returns object of this C++ class to interact with
                /// </summary>
        static linear_acceleration_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "linear_acceleration_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of linear_stiffness_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class linear_stiffness_measure_with_unit : public virtual derived_measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of linear_stiffness_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        linear_stiffness_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "linear_stiffness_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of linear_stiffness_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static linear_stiffness_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "linear_stiffness_measure_with_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of linear_stiffness_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class linear_stiffness_unit : public virtual derived_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of linear_stiffness_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        linear_stiffness_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "linear_stiffness_unit")
        {}

                /// <summary>
                /// Create new instace of linear_stiffness_unit and returns object of this C++ class to interact with
                /// </summary>
        static linear_stiffness_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "linear_stiffness_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of linear_velocity_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class linear_velocity_measure_with_unit : public virtual derived_measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of linear_velocity_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        linear_velocity_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "linear_velocity_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of linear_velocity_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static linear_velocity_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "linear_velocity_measure_with_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of linear_velocity_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class linear_velocity_unit : public virtual derived_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of linear_velocity_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        linear_velocity_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "linear_velocity_unit")
        {}

                /// <summary>
                /// Create new instace of linear_velocity_unit and returns object of this C++ class to interact with
                /// </summary>
        static linear_velocity_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "linear_velocity_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of load
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class load : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of load
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        load(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "load")
        {}


        load_case get_parent_load_case();
        void put_parent_load_case(load_case inst);

        label get_load_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "load_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_load_name(label value) { sdaiPutAttrBN(m_instance, "load_name", sdaiSTRING, value); }

        text get_load_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "load_description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_load_description(text value) { sdaiPutAttrBN(m_instance, "load_description", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of load_case
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class load_case : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of load_case
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        load_case(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "load_case")
        {}

                /// <summary>
                /// Create new instace of load_case and returns object of this C++ class to interact with
                /// </summary>
        static load_case Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "load_case"); assert(inst); return inst; }

        label get_load_case_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "load_case_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_load_case_name(label value) { sdaiPutAttrBN(m_instance, "load_case_name", sdaiSTRING, value); }

        Nullable<double> get_load_case_factor() { double val = (double) 0; if (sdaiGetAttrBN(m_instance, "load_case_factor", sdaiREAL, &val)) return val; else return Nullable<double>(); }
        void put_load_case_factor(double value) { sdaiPutAttrBN(m_instance, "load_case_factor", sdaiREAL, &value); }

        //TList may be set_of_analysis_method or list of converible elements
        template <typename TList> void get_governing_analyses(TList& lst) { set_of_analysis_methodSerializer<TList> sr; sr.FromAttr(lst, m_instance, "governing_analyses"); }

        //TList may be set_of_analysis_method or list of converible elements
        template <typename TList> void put_governing_analyses(TList& lst) { set_of_analysis_methodSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "governing_analyses"); }

        //TArrayElem[] may be analysis_method[] or array of convertible elements
        template <typename TArrayElem> void put_governing_analyses(TArrayElem arr[], size_t n) { set_of_analysis_method lst; ArrayToList(arr, n, lst); put_governing_analyses(lst); }

        physical_action get_time_variation();
        void put_time_variation(physical_action inst);

        //TList may be set_of_load or list of converible elements
        template <typename TList> void get_loads(TList& lst) { set_of_loadSerializer<TList> sr; sr.FromAttr(lst, m_instance, "loads"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of load_case_documented
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class load_case_documented : public virtual load_case
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of load_case_documented
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        load_case_documented(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "load_case_documented")
        {}

                /// <summary>
                /// Create new instace of load_case_documented and returns object of this C++ class to interact with
                /// </summary>
        static load_case_documented Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "load_case_documented"); assert(inst); return inst; }

        document_usage_constraint get_code_ref();
        void put_code_ref(document_usage_constraint inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of load_combination_occurrence
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class load_combination_occurrence : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of load_combination_occurrence
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        load_combination_occurrence(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "load_combination_occurrence")
        {}

                /// <summary>
                /// Create new instace of load_combination_occurrence and returns object of this C++ class to interact with
                /// </summary>
        static load_combination_occurrence Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "load_combination_occurrence"); assert(inst); return inst; }

        Nullable<double> get_load_combination_factor() { double val = (double) 0; if (sdaiGetAttrBN(m_instance, "load_combination_factor", sdaiREAL, &val)) return val; else return Nullable<double>(); }
        void put_load_combination_factor(double value) { sdaiPutAttrBN(m_instance, "load_combination_factor", sdaiREAL, &value); }

        loading_combination get_parent_load_combination();
        void put_parent_load_combination(loading_combination inst);

        load_case get_component_load_case();
        void put_component_load_case(load_case inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of load_connection
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class load_connection : public virtual load
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of load_connection
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        load_connection(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "load_connection")
        {}

                /// <summary>
                /// Create new instace of load_connection and returns object of this C++ class to interact with
                /// </summary>
        static load_connection Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "load_connection"); assert(inst); return inst; }

        assembly_design_structural_connection get_supporting_connection();
        void put_supporting_connection(assembly_design_structural_connection inst);

        applied_load get_load_values();
        void put_load_values(applied_load inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of load_element
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class load_element : public virtual load
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of load_element
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        load_element(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "load_element")
        {}


        element get_supporting_element();
        void put_supporting_element(element inst);

        label get_load_position_label() { label val = NULL; if (sdaiGetAttrBN(m_instance, "load_position_label", sdaiSTRING, &val)) return val; else return NULL; }
        void put_load_position_label(label value) { sdaiPutAttrBN(m_instance, "load_position_label", sdaiSTRING, value); }

        text get_reference_system() { text val = NULL; if (sdaiGetAttrBN(m_instance, "reference_system", sdaiSTRING, &val)) return val; else return NULL; }
        void put_reference_system(text value) { sdaiPutAttrBN(m_instance, "reference_system", sdaiSTRING, value); }

        Nullable<bool> get_destablizing_load() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "destablizing_load", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_destablizing_load(bool value) { sdaiPutAttrBN(m_instance, "destablizing_load", sdaiBOOLEAN, &value); }

        Nullable<global_or_local_load> get_global_or_local() { int v = getENUM("global_or_local", global_or_local_load_); if (v >= 0) return (global_or_local_load) v; else return Nullable<global_or_local_load>(); }
        void put_global_or_local(global_or_local_load value) { TextValue val = global_or_local_load_[(int) value]; sdaiPutAttrBN(m_instance, "global_or_local", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of load_element_concentrated
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class load_element_concentrated : public virtual load_element
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of load_element_concentrated
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        load_element_concentrated(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "load_element_concentrated")
        {}

                /// <summary>
                /// Create new instace of load_element_concentrated and returns object of this C++ class to interact with
                /// </summary>
        static load_element_concentrated Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "load_element_concentrated"); assert(inst); return inst; }

        point get_load_position();
        void put_load_position(point inst);

        applied_load get_load_value();
        void put_load_value(applied_load inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of load_element_distributed
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class load_element_distributed : public virtual load_element
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of load_element_distributed
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        load_element_distributed(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "load_element_distributed")
        {}


        Nullable<projected_or_true_length> get_projected_or_true() { int v = getENUM("projected_or_true", projected_or_true_length_); if (v >= 0) return (projected_or_true_length) v; else return Nullable<projected_or_true_length>(); }
        void put_projected_or_true(projected_or_true_length value) { TextValue val = projected_or_true_length_[(int) value]; sdaiPutAttrBN(m_instance, "projected_or_true", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of load_element_distributed_curve
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class load_element_distributed_curve : public virtual load_element_distributed
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of load_element_distributed_curve
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        load_element_distributed_curve(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "load_element_distributed_curve")
        {}

                /// <summary>
                /// Create new instace of load_element_distributed_curve and returns object of this C++ class to interact with
                /// </summary>
        static load_element_distributed_curve Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "load_element_distributed_curve"); assert(inst); return inst; }

        applied_load get_start_load_value();
        void put_start_load_value(applied_load inst);

        applied_load get_end_load_value();
        void put_end_load_value(applied_load inst);

        curve get_curve_definition();
        void put_curve_definition(curve inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of load_element_distributed_curve_line
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class load_element_distributed_curve_line : public virtual load_element_distributed_curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of load_element_distributed_curve_line
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        load_element_distributed_curve_line(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "load_element_distributed_curve_line")
        {}

                /// <summary>
                /// Create new instace of load_element_distributed_curve_line and returns object of this C++ class to interact with
                /// </summary>
        static load_element_distributed_curve_line Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "load_element_distributed_curve_line"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of load_element_distributed_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class load_element_distributed_surface : public virtual load_element_distributed
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of load_element_distributed_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        load_element_distributed_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "load_element_distributed_surface")
        {}


        bounded_surface get_surface_definition();
        void put_surface_definition(bounded_surface inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of load_element_distributed_surface_uniform
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class load_element_distributed_surface_uniform : public virtual load_element_distributed_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of load_element_distributed_surface_uniform
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        load_element_distributed_surface_uniform(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "load_element_distributed_surface_uniform")
        {}

                /// <summary>
                /// Create new instace of load_element_distributed_surface_uniform and returns object of this C++ class to interact with
                /// </summary>
        static load_element_distributed_surface_uniform Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "load_element_distributed_surface_uniform"); assert(inst); return inst; }

        applied_load_static_pressure get_load_value();
        void put_load_value(applied_load_static_pressure inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of load_element_distributed_surface_varying
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class load_element_distributed_surface_varying : public virtual load_element_distributed_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of load_element_distributed_surface_varying
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        load_element_distributed_surface_varying(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "load_element_distributed_surface_varying")
        {}

                /// <summary>
                /// Create new instace of load_element_distributed_surface_varying and returns object of this C++ class to interact with
                /// </summary>
        static load_element_distributed_surface_varying Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "load_element_distributed_surface_varying"); assert(inst); return inst; }

        //TList may be set_of_applied_load_static_pressure or list of converible elements
        template <typename TList> void get_load_values(TList& lst) { set_of_applied_load_static_pressureSerializer<TList> sr; sr.FromAttr(lst, m_instance, "load_values"); }

        //TList may be set_of_applied_load_static_pressure or list of converible elements
        template <typename TList> void put_load_values(TList& lst) { set_of_applied_load_static_pressureSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "load_values"); }

        //TArrayElem[] may be applied_load_static_pressure[] or array of convertible elements
        template <typename TArrayElem> void put_load_values(TArrayElem arr[], size_t n) { set_of_applied_load_static_pressure lst; ArrayToList(arr, n, lst); put_load_values(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of load_element_thermal
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class load_element_thermal : public virtual load_element
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of load_element_thermal
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        load_element_thermal(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "load_element_thermal")
        {}

                /// <summary>
                /// Create new instace of load_element_thermal and returns object of this C++ class to interact with
                /// </summary>
        static load_element_thermal Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "load_element_thermal"); assert(inst); return inst; }

        //TList may be list_of_measure_with_unit or list of converible elements
        template <typename TList> void get_temperature_gradients(TList& lst) { list_of_measure_with_unitSerializer<TList> sr; sr.FromAttr(lst, m_instance, "temperature_gradients"); }

        //TList may be list_of_measure_with_unit or list of converible elements
        template <typename TList> void put_temperature_gradients(TList& lst) { list_of_measure_with_unitSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "temperature_gradients"); }

        //TArrayElem[] may be measure_with_unit[] or array of convertible elements
        template <typename TArrayElem> void put_temperature_gradients(TArrayElem arr[], size_t n) { list_of_measure_with_unit lst; ArrayToList(arr, n, lst); put_temperature_gradients(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of load_member
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class load_member : public virtual load
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of load_member
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        load_member(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "load_member")
        {}


        assembly_design_structural_member get_supporting_member();
        void put_supporting_member(assembly_design_structural_member inst);

        label get_load_position_label() { label val = NULL; if (sdaiGetAttrBN(m_instance, "load_position_label", sdaiSTRING, &val)) return val; else return NULL; }
        void put_load_position_label(label value) { sdaiPutAttrBN(m_instance, "load_position_label", sdaiSTRING, value); }

        text get_reference_system() { text val = NULL; if (sdaiGetAttrBN(m_instance, "reference_system", sdaiSTRING, &val)) return val; else return NULL; }
        void put_reference_system(text value) { sdaiPutAttrBN(m_instance, "reference_system", sdaiSTRING, value); }

        Nullable<bool> get_destablizing_load() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "destablizing_load", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_destablizing_load(bool value) { sdaiPutAttrBN(m_instance, "destablizing_load", sdaiBOOLEAN, &value); }

        Nullable<global_or_local_load> get_global_or_local() { int v = getENUM("global_or_local", global_or_local_load_); if (v >= 0) return (global_or_local_load) v; else return Nullable<global_or_local_load>(); }
        void put_global_or_local(global_or_local_load value) { TextValue val = global_or_local_load_[(int) value]; sdaiPutAttrBN(m_instance, "global_or_local", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of load_member_concentrated
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class load_member_concentrated : public virtual load_member
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of load_member_concentrated
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        load_member_concentrated(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "load_member_concentrated")
        {}

                /// <summary>
                /// Create new instace of load_member_concentrated and returns object of this C++ class to interact with
                /// </summary>
        static load_member_concentrated Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "load_member_concentrated"); assert(inst); return inst; }

        point get_load_position();
        void put_load_position(point inst);

        applied_load get_load_value();
        void put_load_value(applied_load inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of load_member_distributed
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class load_member_distributed : public virtual load_member
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of load_member_distributed
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        load_member_distributed(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "load_member_distributed")
        {}


        Nullable<projected_or_true_length> get_projected_or_true() { int v = getENUM("projected_or_true", projected_or_true_length_); if (v >= 0) return (projected_or_true_length) v; else return Nullable<projected_or_true_length>(); }
        void put_projected_or_true(projected_or_true_length value) { TextValue val = projected_or_true_length_[(int) value]; sdaiPutAttrBN(m_instance, "projected_or_true", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of load_member_distributed_curve
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class load_member_distributed_curve : public virtual load_member_distributed
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of load_member_distributed_curve
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        load_member_distributed_curve(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "load_member_distributed_curve")
        {}

                /// <summary>
                /// Create new instace of load_member_distributed_curve and returns object of this C++ class to interact with
                /// </summary>
        static load_member_distributed_curve Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "load_member_distributed_curve"); assert(inst); return inst; }

        applied_load get_start_load_value();
        void put_start_load_value(applied_load inst);

        applied_load get_end_load_value();
        void put_end_load_value(applied_load inst);

        curve get_curve_definition();
        void put_curve_definition(curve inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of load_member_distributed_curve_line
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class load_member_distributed_curve_line : public virtual load_member_distributed_curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of load_member_distributed_curve_line
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        load_member_distributed_curve_line(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "load_member_distributed_curve_line")
        {}

                /// <summary>
                /// Create new instace of load_member_distributed_curve_line and returns object of this C++ class to interact with
                /// </summary>
        static load_member_distributed_curve_line Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "load_member_distributed_curve_line"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of load_member_distributed_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class load_member_distributed_surface : public virtual load_member_distributed
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of load_member_distributed_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        load_member_distributed_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "load_member_distributed_surface")
        {}


        bounded_surface get_surface_definition();
        void put_surface_definition(bounded_surface inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of load_member_distributed_surface_uniform
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class load_member_distributed_surface_uniform : public virtual load_member_distributed_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of load_member_distributed_surface_uniform
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        load_member_distributed_surface_uniform(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "load_member_distributed_surface_uniform")
        {}

                /// <summary>
                /// Create new instace of load_member_distributed_surface_uniform and returns object of this C++ class to interact with
                /// </summary>
        static load_member_distributed_surface_uniform Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "load_member_distributed_surface_uniform"); assert(inst); return inst; }

        applied_load_static_pressure get_load_value();
        void put_load_value(applied_load_static_pressure inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of load_member_distributed_surface_varying
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class load_member_distributed_surface_varying : public virtual load_member_distributed_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of load_member_distributed_surface_varying
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        load_member_distributed_surface_varying(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "load_member_distributed_surface_varying")
        {}

                /// <summary>
                /// Create new instace of load_member_distributed_surface_varying and returns object of this C++ class to interact with
                /// </summary>
        static load_member_distributed_surface_varying Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "load_member_distributed_surface_varying"); assert(inst); return inst; }

        //TList may be set_of_applied_load_static_pressure or list of converible elements
        template <typename TList> void get_load_values(TList& lst) { set_of_applied_load_static_pressureSerializer<TList> sr; sr.FromAttr(lst, m_instance, "load_values"); }

        //TList may be set_of_applied_load_static_pressure or list of converible elements
        template <typename TList> void put_load_values(TList& lst) { set_of_applied_load_static_pressureSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "load_values"); }

        //TArrayElem[] may be applied_load_static_pressure[] or array of convertible elements
        template <typename TArrayElem> void put_load_values(TArrayElem arr[], size_t n) { set_of_applied_load_static_pressure lst; ArrayToList(arr, n, lst); put_load_values(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of load_node
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class load_node : public virtual load
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of load_node
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        load_node(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "load_node")
        {}

                /// <summary>
                /// Create new instace of load_node and returns object of this C++ class to interact with
                /// </summary>
        static load_node Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "load_node"); assert(inst); return inst; }

        node get_supporting_node();
        void put_supporting_node(node inst);

        applied_load get_load_values();
        void put_load_values(applied_load inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of loaded_product
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class loaded_product : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of loaded_product
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        loaded_product(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "loaded_product")
        {}

                /// <summary>
                /// Create new instace of loaded_product and returns object of this C++ class to interact with
                /// </summary>
        static loaded_product Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "loaded_product"); assert(inst); return inst; }

        structural_frame_product get_product();
        void put_product(structural_frame_product inst);

        applied_load get_load_definition();
        void put_load_definition(applied_load inst);

        physical_action get_time_variation();
        void put_time_variation(physical_action inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of loading_combination
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class loading_combination : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of loading_combination
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        loading_combination(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "loading_combination")
        {}

                /// <summary>
                /// Create new instace of loading_combination and returns object of this C++ class to interact with
                /// </summary>
        static loading_combination Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "loading_combination"); assert(inst); return inst; }

        label get_loading_combination_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "loading_combination_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_loading_combination_name(label value) { sdaiPutAttrBN(m_instance, "loading_combination_name", sdaiSTRING, value); }

        text get_loading_combination_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "loading_combination_description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_loading_combination_description(text value) { sdaiPutAttrBN(m_instance, "loading_combination_description", sdaiSTRING, value); }

        analysis_model get_loaded_model();
        void put_loaded_model(analysis_model inst);

        //TList may be set_of_load_combination_occurrence or list of converible elements
        template <typename TList> void get_load_cases(TList& lst) { set_of_load_combination_occurrenceSerializer<TList> sr; sr.FromAttr(lst, m_instance, "load_cases"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of local_time
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class local_time : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of local_time
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        local_time(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "local_time")
        {}

                /// <summary>
                /// Create new instace of local_time and returns object of this C++ class to interact with
                /// </summary>
        static local_time Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "local_time"); assert(inst); return inst; }

        Nullable<hour_in_day> get_hour_component() { hour_in_day val = (hour_in_day) 0; if (sdaiGetAttrBN(m_instance, "hour_component", sdaiINTEGER, &val)) return val; else return Nullable<hour_in_day>(); }
        void put_hour_component(hour_in_day value) { sdaiPutAttrBN(m_instance, "hour_component", sdaiINTEGER, &value); }

        Nullable<minute_in_hour> get_minute_component() { minute_in_hour val = (minute_in_hour) 0; if (sdaiGetAttrBN(m_instance, "minute_component", sdaiINTEGER, &val)) return val; else return Nullable<minute_in_hour>(); }
        void put_minute_component(minute_in_hour value) { sdaiPutAttrBN(m_instance, "minute_component", sdaiINTEGER, &value); }

        Nullable<second_in_minute> get_second_component() { second_in_minute val = (second_in_minute) 0; if (sdaiGetAttrBN(m_instance, "second_component", sdaiREAL, &val)) return val; else return Nullable<second_in_minute>(); }
        void put_second_component(second_in_minute value) { sdaiPutAttrBN(m_instance, "second_component", sdaiREAL, &value); }

        coordinated_universal_time_offset get_zone();
        void put_zone(coordinated_universal_time_offset inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of located_item
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class located_item : public virtual structural_frame_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of located_item
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        located_item(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "located_item")
        {}


        coord_system get_location();
        void put_location(coord_system inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of located_assembly
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class located_assembly : public virtual located_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of located_assembly
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        located_assembly(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "located_assembly")
        {}

                /// <summary>
                /// Create new instace of located_assembly and returns object of this C++ class to interact with
                /// </summary>
        static located_assembly Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "located_assembly"); assert(inst); return inst; }

        //TList may be set_of_grid_offset or list of converible elements
        template <typename TList> void get_location_on_grid(TList& lst) { set_of_grid_offsetSerializer<TList> sr; sr.FromAttr(lst, m_instance, "location_on_grid"); }

        //TList may be set_of_grid_offset or list of converible elements
        template <typename TList> void put_location_on_grid(TList& lst) { set_of_grid_offsetSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "location_on_grid"); }

        //TArrayElem[] may be grid_offset[] or array of convertible elements
        template <typename TArrayElem> void put_location_on_grid(TArrayElem arr[], size_t n) { set_of_grid_offset lst; ArrayToList(arr, n, lst); put_location_on_grid(lst); }

        assembly get_descriptive_assembly();
        void put_descriptive_assembly(assembly inst);

        structure_select_get get_parent_structure() { return structure_select_get(m_instance, "parent_structure", NULL); }
        structure_select_put put_parent_structure() { return structure_select_put(m_instance, "parent_structure", NULL); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of located_assembly_child
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class located_assembly_child : public virtual located_assembly
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of located_assembly_child
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        located_assembly_child(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "located_assembly_child")
        {}

                /// <summary>
                /// Create new instace of located_assembly_child and returns object of this C++ class to interact with
                /// </summary>
        static located_assembly_child Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "located_assembly_child"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of located_assembly_marked
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class located_assembly_marked : public virtual located_assembly
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of located_assembly_marked
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        located_assembly_marked(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "located_assembly_marked")
        {}

                /// <summary>
                /// Create new instace of located_assembly_marked and returns object of this C++ class to interact with
                /// </summary>
        static located_assembly_marked Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "located_assembly_marked"); assert(inst); return inst; }

        label get_assembly_mark() { label val = NULL; if (sdaiGetAttrBN(m_instance, "assembly_mark", sdaiSTRING, &val)) return val; else return NULL; }
        void put_assembly_mark(label value) { sdaiPutAttrBN(m_instance, "assembly_mark", sdaiSTRING, value); }

        label get_client_mark() { label val = NULL; if (sdaiGetAttrBN(m_instance, "client_mark", sdaiSTRING, &val)) return val; else return NULL; }
        void put_client_mark(label value) { sdaiPutAttrBN(m_instance, "client_mark", sdaiSTRING, value); }

        label get_prelim_mark() { label val = NULL; if (sdaiGetAttrBN(m_instance, "prelim_mark", sdaiSTRING, &val)) return val; else return NULL; }
        void put_prelim_mark(label value) { sdaiPutAttrBN(m_instance, "prelim_mark", sdaiSTRING, value); }

        label get_shipping_mark() { label val = NULL; if (sdaiGetAttrBN(m_instance, "shipping_mark", sdaiSTRING, &val)) return val; else return NULL; }
        void put_shipping_mark(label value) { sdaiPutAttrBN(m_instance, "shipping_mark", sdaiSTRING, value); }

        label get_bar_code() { label val = NULL; if (sdaiGetAttrBN(m_instance, "bar_code", sdaiSTRING, &val)) return val; else return NULL; }
        void put_bar_code(label value) { sdaiPutAttrBN(m_instance, "bar_code", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of located_feature
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class located_feature : public virtual located_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of located_feature
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        located_feature(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "located_feature")
        {}


        feature get_descriptive_feature();
        void put_descriptive_feature(feature inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of located_feature_for_assembly
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class located_feature_for_assembly : public virtual located_feature
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of located_feature_for_assembly
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        located_feature_for_assembly(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "located_feature_for_assembly")
        {}

                /// <summary>
                /// Create new instace of located_feature_for_assembly and returns object of this C++ class to interact with
                /// </summary>
        static located_feature_for_assembly Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "located_feature_for_assembly"); assert(inst); return inst; }

        assembly get_modified_assembly();
        void put_modified_assembly(assembly inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of located_feature_for_design_part
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class located_feature_for_design_part : public virtual located_feature
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of located_feature_for_design_part
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        located_feature_for_design_part(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "located_feature_for_design_part")
        {}

                /// <summary>
                /// Create new instace of located_feature_for_design_part and returns object of this C++ class to interact with
                /// </summary>
        static located_feature_for_design_part Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "located_feature_for_design_part"); assert(inst); return inst; }

        design_part get_modified_part();
        void put_modified_part(design_part inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of located_feature_for_located_assembly
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class located_feature_for_located_assembly : public virtual located_feature
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of located_feature_for_located_assembly
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        located_feature_for_located_assembly(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "located_feature_for_located_assembly")
        {}

                /// <summary>
                /// Create new instace of located_feature_for_located_assembly and returns object of this C++ class to interact with
                /// </summary>
        static located_feature_for_located_assembly Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "located_feature_for_located_assembly"); assert(inst); return inst; }

        located_assembly get_modified_assembly();
        void put_modified_assembly(located_assembly inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of located_feature_for_located_part
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class located_feature_for_located_part : public virtual located_feature
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of located_feature_for_located_part
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        located_feature_for_located_part(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "located_feature_for_located_part")
        {}

                /// <summary>
                /// Create new instace of located_feature_for_located_part and returns object of this C++ class to interact with
                /// </summary>
        static located_feature_for_located_part Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "located_feature_for_located_part"); assert(inst); return inst; }

        located_part get_modified_part();
        void put_modified_part(located_part inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of located_feature_for_part
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class located_feature_for_part : public virtual located_feature
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of located_feature_for_part
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        located_feature_for_part(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "located_feature_for_part")
        {}

                /// <summary>
                /// Create new instace of located_feature_for_part and returns object of this C++ class to interact with
                /// </summary>
        static located_feature_for_part Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "located_feature_for_part"); assert(inst); return inst; }

        part get_modified_part();
        void put_modified_part(part inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of located_feature_joint_dependent
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class located_feature_joint_dependent : public virtual located_feature_for_located_part
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of located_feature_joint_dependent
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        located_feature_joint_dependent(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "located_feature_joint_dependent")
        {}

                /// <summary>
                /// Create new instace of located_feature_joint_dependent and returns object of this C++ class to interact with
                /// </summary>
        static located_feature_joint_dependent Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "located_feature_joint_dependent"); assert(inst); return inst; }

        located_joint_system get_feature_for_joint();
        void put_feature_for_joint(located_joint_system inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of located_joint_system
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class located_joint_system : public virtual located_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of located_joint_system
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        located_joint_system(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "located_joint_system")
        {}

                /// <summary>
                /// Create new instace of located_joint_system and returns object of this C++ class to interact with
                /// </summary>
        static located_joint_system Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "located_joint_system"); assert(inst); return inst; }

        joint_system get_descriptive_joint_system();
        void put_descriptive_joint_system(joint_system inst);

        located_assembly get_parent_assembly();
        void put_parent_assembly(located_assembly inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of located_part
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class located_part : public virtual located_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of located_part
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        located_part(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "located_part")
        {}

                /// <summary>
                /// Create new instace of located_part and returns object of this C++ class to interact with
                /// </summary>
        static located_part Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "located_part"); assert(inst); return inst; }

        part get_descriptive_part();
        void put_descriptive_part(part inst);

        located_assembly get_parent_assembly();
        void put_parent_assembly(located_assembly inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of located_part_joint
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class located_part_joint : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of located_part_joint
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        located_part_joint(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "located_part_joint")
        {}

                /// <summary>
                /// Create new instace of located_part_joint and returns object of this C++ class to interact with
                /// </summary>
        static located_part_joint Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "located_part_joint"); assert(inst); return inst; }

        label get_part_joint_label() { label val = NULL; if (sdaiGetAttrBN(m_instance, "part_joint_label", sdaiSTRING, &val)) return val; else return NULL; }
        void put_part_joint_label(label value) { sdaiPutAttrBN(m_instance, "part_joint_label", sdaiSTRING, value); }

        text get_part_joint_nature() { text val = NULL; if (sdaiGetAttrBN(m_instance, "part_joint_nature", sdaiSTRING, &val)) return val; else return NULL; }
        void put_part_joint_nature(text value) { sdaiPutAttrBN(m_instance, "part_joint_nature", sdaiSTRING, value); }

        //TList may be set_of_located_part or list of converible elements
        template <typename TList> void get_logically_joined_parts(TList& lst) { set_of_located_partSerializer<TList> sr; sr.FromAttr(lst, m_instance, "logically_joined_parts"); }

        //TList may be set_of_located_part or list of converible elements
        template <typename TList> void put_logically_joined_parts(TList& lst) { set_of_located_partSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "logically_joined_parts"); }

        //TArrayElem[] may be located_part[] or array of convertible elements
        template <typename TArrayElem> void put_logically_joined_parts(TArrayElem arr[], size_t n) { set_of_located_part lst; ArrayToList(arr, n, lst); put_logically_joined_parts(lst); }

        //TList may be set_of_located_joint_system or list of converible elements
        template <typename TList> void get_required_joints(TList& lst) { set_of_located_joint_systemSerializer<TList> sr; sr.FromAttr(lst, m_instance, "required_joints"); }

        //TList may be set_of_located_joint_system or list of converible elements
        template <typename TList> void put_required_joints(TList& lst) { set_of_located_joint_systemSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "required_joints"); }

        //TArrayElem[] may be located_joint_system[] or array of convertible elements
        template <typename TArrayElem> void put_required_joints(TArrayElem arr[], size_t n) { set_of_located_joint_system lst; ArrayToList(arr, n, lst); put_required_joints(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of located_part_marked
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class located_part_marked : public virtual located_part
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of located_part_marked
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        located_part_marked(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "located_part_marked")
        {}

                /// <summary>
                /// Create new instace of located_part_marked and returns object of this C++ class to interact with
                /// </summary>
        static located_part_marked Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "located_part_marked"); assert(inst); return inst; }

        label get_piece_mark() { label val = NULL; if (sdaiGetAttrBN(m_instance, "piece_mark", sdaiSTRING, &val)) return val; else return NULL; }
        void put_piece_mark(label value) { sdaiPutAttrBN(m_instance, "piece_mark", sdaiSTRING, value); }

        label get_prelim_mark() { label val = NULL; if (sdaiGetAttrBN(m_instance, "prelim_mark", sdaiSTRING, &val)) return val; else return NULL; }
        void put_prelim_mark(label value) { sdaiPutAttrBN(m_instance, "prelim_mark", sdaiSTRING, value); }

        label get_bar_code() { label val = NULL; if (sdaiGetAttrBN(m_instance, "bar_code", sdaiSTRING, &val)) return val; else return NULL; }
        void put_bar_code(label value) { sdaiPutAttrBN(m_instance, "bar_code", sdaiSTRING, value); }

        Nullable<IntValue> get_quantity() { IntValue val = (IntValue) 0; if (sdaiGetAttrBN(m_instance, "quantity", sdaiINTEGER, &val)) return val; else return Nullable<IntValue>(); }
        void put_quantity(IntValue value) { sdaiPutAttrBN(m_instance, "quantity", sdaiINTEGER, &value); }

        Nullable<LOGICAL_VALUE> get_main_piece() { int v = getENUM("main_piece", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_main_piece(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "main_piece", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of located_site
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class located_site : public virtual located_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of located_site
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        located_site(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "located_site")
        {}

                /// <summary>
                /// Create new instace of located_site and returns object of this C++ class to interact with
                /// </summary>
        static located_site Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "located_site"); assert(inst); return inst; }

        site get_descriptive_site();
        void put_descriptive_site(site inst);

        project_select_get get_parent_project() { return project_select_get(m_instance, "parent_project", NULL); }
        project_select_put put_parent_project() { return project_select_put(m_instance, "parent_project", NULL); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of located_structure
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class located_structure : public virtual located_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of located_structure
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        located_structure(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "located_structure")
        {}

                /// <summary>
                /// Create new instace of located_structure and returns object of this C++ class to interact with
                /// </summary>
        static located_structure Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "located_structure"); assert(inst); return inst; }

        structure get_descriptive_structure();
        void put_descriptive_structure(structure inst);

        site_select_get get_parent_site() { return site_select_get(m_instance, "parent_site", NULL); }
        site_select_put put_parent_site() { return site_select_put(m_instance, "parent_site", NULL); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of managed_application_installation
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class managed_application_installation : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of managed_application_installation
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        managed_application_installation(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "managed_application_installation")
        {}

                /// <summary>
                /// Create new instace of managed_application_installation and returns object of this C++ class to interact with
                /// </summary>
        static managed_application_installation Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "managed_application_installation"); assert(inst); return inst; }

        Nullable<IntValue> get_application_id() { IntValue val = (IntValue) 0; if (sdaiGetAttrBN(m_instance, "application_id", sdaiINTEGER, &val)) return val; else return Nullable<IntValue>(); }
        void put_application_id(IntValue value) { sdaiPutAttrBN(m_instance, "application_id", sdaiINTEGER, &value); }

        label get_application_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "application_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_application_name(label value) { sdaiPutAttrBN(m_instance, "application_name", sdaiSTRING, value); }

        label get_application_version() { label val = NULL; if (sdaiGetAttrBN(m_instance, "application_version", sdaiSTRING, &val)) return val; else return NULL; }
        void put_application_version(label value) { sdaiPutAttrBN(m_instance, "application_version", sdaiSTRING, value); }

        text get_application_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "application_description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_application_description(text value) { sdaiPutAttrBN(m_instance, "application_description", sdaiSTRING, value); }

        organization get_application_vendor();
        void put_application_vendor(organization inst);

        Nullable<IntValue> get_installation_id() { IntValue val = (IntValue) 0; if (sdaiGetAttrBN(m_instance, "installation_id", sdaiINTEGER, &val)) return val; else return Nullable<IntValue>(); }
        void put_installation_id(IntValue value) { sdaiPutAttrBN(m_instance, "installation_id", sdaiINTEGER, &value); }

        label get_installation_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "installation_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_installation_name(label value) { sdaiPutAttrBN(m_instance, "installation_name", sdaiSTRING, value); }

        organization get_installation_owner();
        void put_installation_owner(organization inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of managed_data_transaction
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class managed_data_transaction : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of managed_data_transaction
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        managed_data_transaction(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "managed_data_transaction")
        {}

                /// <summary>
                /// Create new instace of managed_data_transaction and returns object of this C++ class to interact with
                /// </summary>
        static managed_data_transaction Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "managed_data_transaction"); assert(inst); return inst; }

        managed_application_installation get_application();
        void put_application(managed_application_installation inst);

        person_and_organization get_user();
        void put_user(person_and_organization inst);

        date_and_time get_processing_date();
        void put_processing_date(date_and_time inst);

        Nullable<bool> get_new_ids_assigned() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "new_ids_assigned", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_new_ids_assigned(bool value) { sdaiPutAttrBN(m_instance, "new_ids_assigned", sdaiBOOLEAN, &value); }

        label get_life_cycle_stage() { label val = NULL; if (sdaiGetAttrBN(m_instance, "life_cycle_stage", sdaiSTRING, &val)) return val; else return NULL; }
        void put_life_cycle_stage(label value) { sdaiPutAttrBN(m_instance, "life_cycle_stage", sdaiSTRING, value); }

        text get_transaction_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "transaction_description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_transaction_description(text value) { sdaiPutAttrBN(m_instance, "transaction_description", sdaiSTRING, value); }

        //TList may be set_of_managed_data_item or list of converible elements
        template <typename TList> void get_processed_items(TList& lst) { set_of_managed_data_itemSerializer<TList> sr; sr.FromAttr(lst, m_instance, "processed_items"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of managed_data_creation
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class managed_data_creation : public virtual managed_data_transaction
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of managed_data_creation
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        managed_data_creation(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "managed_data_creation")
        {}

                /// <summary>
                /// Create new instace of managed_data_creation and returns object of this C++ class to interact with
                /// </summary>
        static managed_data_creation Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "managed_data_creation"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of managed_data_deleted
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class managed_data_deleted : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of managed_data_deleted
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        managed_data_deleted(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "managed_data_deleted")
        {}

                /// <summary>
                /// Create new instace of managed_data_deleted and returns object of this C++ class to interact with
                /// </summary>
        static managed_data_deleted Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "managed_data_deleted"); assert(inst); return inst; }

        Nullable<data_status_type> get_data_status() { int v = getENUM("data_status", data_status_type_); if (v >= 0) return (data_status_type) v; else return Nullable<data_status_type>(); }
        void put_data_status(data_status_type value) { TextValue val = data_status_type_[(int) value]; sdaiPutAttrBN(m_instance, "data_status", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of managed_data_export
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class managed_data_export : public virtual managed_data_transaction
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of managed_data_export
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        managed_data_export(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "managed_data_export")
        {}

                /// <summary>
                /// Create new instace of managed_data_export and returns object of this C++ class to interact with
                /// </summary>
        static managed_data_export Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "managed_data_export"); assert(inst); return inst; }

        select_data_source_get get_data_destination() { return select_data_source_get(m_instance, "data_destination", NULL); }
        select_data_source_put put_data_destination() { return select_data_source_put(m_instance, "data_destination", NULL); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of managed_data_group
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class managed_data_group : public virtual group_assignment
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of managed_data_group
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        managed_data_group(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "managed_data_group")
        {}

                /// <summary>
                /// Create new instace of managed_data_group and returns object of this C++ class to interact with
                /// </summary>
        static managed_data_group Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "managed_data_group"); assert(inst); return inst; }

        //TList may be set_of_managed_data_transaction or list of converible elements
        template <typename TList> void get_items(TList& lst) { set_of_managed_data_transactionSerializer<TList> sr; sr.FromAttr(lst, m_instance, "items"); }

        //TList may be set_of_managed_data_transaction or list of converible elements
        template <typename TList> void put_items(TList& lst) { set_of_managed_data_transactionSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "items"); }

        //TArrayElem[] may be managed_data_transaction[] or array of convertible elements
        template <typename TArrayElem> void put_items(TArrayElem arr[], size_t n) { set_of_managed_data_transaction lst; ArrayToList(arr, n, lst); put_items(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of managed_data_import
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class managed_data_import : public virtual managed_data_transaction
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of managed_data_import
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        managed_data_import(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "managed_data_import")
        {}

                /// <summary>
                /// Create new instace of managed_data_import and returns object of this C++ class to interact with
                /// </summary>
        static managed_data_import Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "managed_data_import"); assert(inst); return inst; }

        select_data_source_get get_data_source() { return select_data_source_get(m_instance, "data_source", NULL); }
        select_data_source_put put_data_source() { return select_data_source_put(m_instance, "data_source", NULL); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of managed_data_item
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class managed_data_item : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of managed_data_item
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        managed_data_item(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "managed_data_item")
        {}

                /// <summary>
                /// Create new instace of managed_data_item and returns object of this C++ class to interact with
                /// </summary>
        static managed_data_item Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "managed_data_item"); assert(inst); return inst; }

        globally_unique_id get_instance_id() { globally_unique_id val = NULL; if (sdaiGetAttrBN(m_instance, "instance_id", sdaiSTRING, &val)) return val; else return NULL; }
        void put_instance_id(globally_unique_id value) { sdaiPutAttrBN(m_instance, "instance_id", sdaiSTRING, value); }

        managed_application_installation get_originating_application();
        void put_originating_application(managed_application_installation inst);

        select_data_item_get get_data_item() { return select_data_item_get(m_instance, "data_item", NULL); }
        select_data_item_put put_data_item() { return select_data_item_put(m_instance, "data_item", NULL); }

        //TList may be list_of_managed_data_transaction or list of converible elements
        template <typename TList> void get_history(TList& lst) { list_of_managed_data_transactionSerializer<TList> sr; sr.FromAttr(lst, m_instance, "history"); }

        //TList may be list_of_managed_data_transaction or list of converible elements
        template <typename TList> void put_history(TList& lst) { list_of_managed_data_transactionSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "history"); }

        //TArrayElem[] may be managed_data_transaction[] or array of convertible elements
        template <typename TArrayElem> void put_history(TArrayElem arr[], size_t n) { list_of_managed_data_transaction lst; ArrayToList(arr, n, lst); put_history(lst); }

        Nullable<LOGICAL_VALUE> get_original_data() { int v = getENUM("original_data", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_original_data(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "original_data", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of managed_data_item_with_history
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class managed_data_item_with_history : public virtual managed_data_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of managed_data_item_with_history
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        managed_data_item_with_history(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "managed_data_item_with_history")
        {}

                /// <summary>
                /// Create new instace of managed_data_item_with_history and returns object of this C++ class to interact with
                /// </summary>
        static managed_data_item_with_history Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "managed_data_item_with_history"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of managed_data_modification
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class managed_data_modification : public virtual managed_data_transaction
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of managed_data_modification
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        managed_data_modification(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "managed_data_modification")
        {}

                /// <summary>
                /// Create new instace of managed_data_modification and returns object of this C++ class to interact with
                /// </summary>
        static managed_data_modification Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "managed_data_modification"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of map_location
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class map_location : public virtual geographical_location
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of map_location
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        map_location(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "map_location")
        {}

                /// <summary>
                /// Create new instace of map_location and returns object of this C++ class to interact with
                /// </summary>
        static map_location Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "map_location"); assert(inst); return inst; }

        label get_map_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "map_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_map_name(label value) { sdaiPutAttrBN(m_instance, "map_name", sdaiSTRING, value); }

        identifier get_map_code() { identifier val = NULL; if (sdaiGetAttrBN(m_instance, "map_code", sdaiSTRING, &val)) return val; else return NULL; }
        void put_map_code(identifier value) { sdaiPutAttrBN(m_instance, "map_code", sdaiSTRING, value); }

        length_measure_with_unit get_eastings();
        void put_eastings(length_measure_with_unit inst);

        length_measure_with_unit get_northings();
        void put_northings(length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of mapped_item
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class mapped_item : public virtual representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of mapped_item
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        mapped_item(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "mapped_item")
        {}

                /// <summary>
                /// Create new instace of mapped_item and returns object of this C++ class to interact with
                /// </summary>
        static mapped_item Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "mapped_item"); assert(inst); return inst; }

        representation_map get_mapping_source();
        void put_mapping_source(representation_map inst);

        representation_item get_mapping_target();
        void put_mapping_target(representation_item inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of mass_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class mass_measure_with_unit : public virtual measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of mass_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        mass_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "mass_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of mass_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static mass_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "mass_measure_with_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of mass_per_length_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class mass_per_length_measure_with_unit : public virtual derived_measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of mass_per_length_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        mass_per_length_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "mass_per_length_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of mass_per_length_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static mass_per_length_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "mass_per_length_measure_with_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of mass_per_length_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class mass_per_length_unit : public virtual derived_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of mass_per_length_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        mass_per_length_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "mass_per_length_unit")
        {}

                /// <summary>
                /// Create new instace of mass_per_length_unit and returns object of this C++ class to interact with
                /// </summary>
        static mass_per_length_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "mass_per_length_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of mass_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class mass_unit : public virtual named_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of mass_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        mass_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "mass_unit")
        {}

                /// <summary>
                /// Create new instace of mass_unit and returns object of this C++ class to interact with
                /// </summary>
        static mass_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "mass_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of material
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class material : public virtual structural_frame_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of material
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        material(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "material")
        {}

                /// <summary>
                /// Create new instace of material and returns object of this C++ class to interact with
                /// </summary>
        static material Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "material"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of material_anisotropic
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class material_anisotropic : public virtual material
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of material_anisotropic
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        material_anisotropic(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "material_anisotropic")
        {}

                /// <summary>
                /// Create new instace of material_anisotropic and returns object of this C++ class to interact with
                /// </summary>
        static material_anisotropic Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "material_anisotropic"); assert(inst); return inst; }

        //TList may be list_of_material_representation or list of converible elements
        template <typename TList> void get_properties(TList& lst) { list_of_material_representationSerializer<TList> sr; sr.FromAttr(lst, m_instance, "properties"); }

        //TList may be list_of_material_representation or list of converible elements
        template <typename TList> void put_properties(TList& lst) { list_of_material_representationSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "properties"); }

        //TArrayElem[] may be material_representation[] or array of convertible elements
        template <typename TArrayElem> void put_properties(TArrayElem arr[], size_t n) { list_of_material_representation lst; ArrayToList(arr, n, lst); put_properties(lst); }

        //TList may be list_of_placement or list of converible elements
        template <typename TList> void get_material_location(TList& lst) { list_of_placementSerializer<TList> sr; sr.FromAttr(lst, m_instance, "material_location"); }

        //TList may be list_of_placement or list of converible elements
        template <typename TList> void put_material_location(TList& lst) { list_of_placementSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "material_location"); }

        //TArrayElem[] may be placement[] or array of convertible elements
        template <typename TArrayElem> void put_material_location(TArrayElem arr[], size_t n) { list_of_placement lst; ArrayToList(arr, n, lst); put_material_location(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of material_constituent
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class material_constituent : public virtual material
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of material_constituent
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        material_constituent(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "material_constituent")
        {}

                /// <summary>
                /// Create new instace of material_constituent and returns object of this C++ class to interact with
                /// </summary>
        static material_constituent Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "material_constituent"); assert(inst); return inst; }

        material get_parent_material();
        void put_parent_material(material inst);

        ratio_measure_with_unit get_constituent_amount();
        void put_constituent_amount(ratio_measure_with_unit inst);

        label get_composition_basis() { label val = NULL; if (sdaiGetAttrBN(m_instance, "composition_basis", sdaiSTRING, &val)) return val; else return NULL; }
        void put_composition_basis(label value) { sdaiPutAttrBN(m_instance, "composition_basis", sdaiSTRING, value); }

        label get_class_() { label val = NULL; if (sdaiGetAttrBN(m_instance, "class_", sdaiSTRING, &val)) return val; else return NULL; }
        void put_class_(label value) { sdaiPutAttrBN(m_instance, "class_", sdaiSTRING, value); }

        text get_determination_method() { text val = NULL; if (sdaiGetAttrBN(m_instance, "determination_method", sdaiSTRING, &val)) return val; else return NULL; }
        void put_determination_method(text value) { sdaiPutAttrBN(m_instance, "determination_method", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of material_representation_item
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class material_representation_item : public virtual representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of material_representation_item
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        material_representation_item(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "material_representation_item")
        {}

                /// <summary>
                /// Create new instace of material_representation_item and returns object of this C++ class to interact with
                /// </summary>
        static material_representation_item Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "material_representation_item"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of material_elasticity
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class material_elasticity : public virtual material_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of material_elasticity
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        material_elasticity(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "material_elasticity")
        {}

                /// <summary>
                /// Create new instace of material_elasticity and returns object of this C++ class to interact with
                /// </summary>
        static material_elasticity Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "material_elasticity"); assert(inst); return inst; }

        Nullable<double> get_poisson_ratio() { double val = (double) 0; if (sdaiGetAttrBN(m_instance, "poisson_ratio", sdaiREAL, &val)) return val; else return Nullable<double>(); }
        void put_poisson_ratio(double value) { sdaiPutAttrBN(m_instance, "poisson_ratio", sdaiREAL, &value); }

        Nullable<pressure_measure> get_young_modulus() { pressure_measure val = (pressure_measure) 0; if (sdaiGetAttrBN(m_instance, "young_modulus", sdaiREAL, &val)) return val; else return Nullable<pressure_measure>(); }
        void put_young_modulus(pressure_measure value) { sdaiPutAttrBN(m_instance, "young_modulus", sdaiREAL, &value); }

        Nullable<pressure_measure> get_shear_modulus() { pressure_measure val = (pressure_measure) 0; if (sdaiGetAttrBN(m_instance, "shear_modulus", sdaiREAL, &val)) return val; else return Nullable<pressure_measure>(); }
        void put_shear_modulus(pressure_measure value) { sdaiPutAttrBN(m_instance, "shear_modulus", sdaiREAL, &value); }

        Nullable<pressure_measure> get_secant_modulus() { pressure_measure val = (pressure_measure) 0; if (sdaiGetAttrBN(m_instance, "secant_modulus", sdaiREAL, &val)) return val; else return Nullable<pressure_measure>(); }
        void put_secant_modulus(pressure_measure value) { sdaiPutAttrBN(m_instance, "secant_modulus", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of material_hardness
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class material_hardness : public virtual material_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of material_hardness
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        material_hardness(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "material_hardness")
        {}

                /// <summary>
                /// Create new instace of material_hardness and returns object of this C++ class to interact with
                /// </summary>
        static material_hardness Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "material_hardness"); assert(inst); return inst; }

        Nullable<context_dependent_measure> get_hardness_values() { context_dependent_measure val = (context_dependent_measure) 0; if (sdaiGetAttrBN(m_instance, "hardness_values", sdaiREAL, &val)) return val; else return Nullable<context_dependent_measure>(); }
        void put_hardness_values(context_dependent_measure value) { sdaiPutAttrBN(m_instance, "hardness_values", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of material_isotropic
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class material_isotropic : public virtual material
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of material_isotropic
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        material_isotropic(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "material_isotropic")
        {}

                /// <summary>
                /// Create new instace of material_isotropic and returns object of this C++ class to interact with
                /// </summary>
        static material_isotropic Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "material_isotropic"); assert(inst); return inst; }

        material_representation get_definition();
        void put_definition(material_representation inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of material_mass_density
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class material_mass_density : public virtual material_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of material_mass_density
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        material_mass_density(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "material_mass_density")
        {}

                /// <summary>
                /// Create new instace of material_mass_density and returns object of this C++ class to interact with
                /// </summary>
        static material_mass_density Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "material_mass_density"); assert(inst); return inst; }

        Nullable<context_dependent_measure> get_mass_density() { context_dependent_measure val = (context_dependent_measure) 0; if (sdaiGetAttrBN(m_instance, "mass_density", sdaiREAL, &val)) return val; else return Nullable<context_dependent_measure>(); }
        void put_mass_density(context_dependent_measure value) { sdaiPutAttrBN(m_instance, "mass_density", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of material_orthotropic
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class material_orthotropic : public virtual material
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of material_orthotropic
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        material_orthotropic(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "material_orthotropic")
        {}

                /// <summary>
                /// Create new instace of material_orthotropic and returns object of this C++ class to interact with
                /// </summary>
        static material_orthotropic Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "material_orthotropic"); assert(inst); return inst; }

        material_representation get_in_plane_properties();
        void put_in_plane_properties(material_representation inst);

        material_representation get_out_of_plane_properties();
        void put_out_of_plane_properties(material_representation inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of material_property_context
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class material_property_context : public virtual representation_context
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of material_property_context
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        material_property_context(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "material_property_context")
        {}

    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of material_property_context_dimensional
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class material_property_context_dimensional : public virtual material_property_context
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of material_property_context_dimensional
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        material_property_context_dimensional(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "material_property_context_dimensional")
        {}

                /// <summary>
                /// Create new instace of material_property_context_dimensional and returns object of this C++ class to interact with
                /// </summary>
        static material_property_context_dimensional Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "material_property_context_dimensional"); assert(inst); return inst; }

        Nullable<length_measure> get_lower_value_for_dimension() { length_measure val = (length_measure) 0; if (sdaiGetAttrBN(m_instance, "lower_value_for_dimension", sdaiREAL, &val)) return val; else return Nullable<length_measure>(); }
        void put_lower_value_for_dimension(length_measure value) { sdaiPutAttrBN(m_instance, "lower_value_for_dimension", sdaiREAL, &value); }

        Nullable<length_measure> get_upper_value_for_dimension() { length_measure val = (length_measure) 0; if (sdaiGetAttrBN(m_instance, "upper_value_for_dimension", sdaiREAL, &val)) return val; else return Nullable<length_measure>(); }
        void put_upper_value_for_dimension(length_measure value) { sdaiPutAttrBN(m_instance, "upper_value_for_dimension", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of material_property_context_loading
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class material_property_context_loading : public virtual material_property_context
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of material_property_context_loading
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        material_property_context_loading(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "material_property_context_loading")
        {}

                /// <summary>
                /// Create new instace of material_property_context_loading and returns object of this C++ class to interact with
                /// </summary>
        static material_property_context_loading Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "material_property_context_loading"); assert(inst); return inst; }

        Nullable<loading_status> get_loading() { int v = getENUM("loading", loading_status_); if (v >= 0) return (loading_status) v; else return Nullable<loading_status>(); }
        void put_loading(loading_status value) { TextValue val = loading_status_[(int) value]; sdaiPutAttrBN(m_instance, "loading", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of material_property_context_strain
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class material_property_context_strain : public virtual material_property_context
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of material_property_context_strain
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        material_property_context_strain(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "material_property_context_strain")
        {}

                /// <summary>
                /// Create new instace of material_property_context_strain and returns object of this C++ class to interact with
                /// </summary>
        static material_property_context_strain Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "material_property_context_strain"); assert(inst); return inst; }

        Nullable<ratio_measure> get_lower_value_for_strain() { ratio_measure val = (ratio_measure) 0; if (sdaiGetAttrBN(m_instance, "lower_value_for_strain", sdaiREAL, &val)) return val; else return Nullable<ratio_measure>(); }
        void put_lower_value_for_strain(ratio_measure value) { sdaiPutAttrBN(m_instance, "lower_value_for_strain", sdaiREAL, &value); }

        Nullable<ratio_measure> get_upper_value_for_strain() { ratio_measure val = (ratio_measure) 0; if (sdaiGetAttrBN(m_instance, "upper_value_for_strain", sdaiREAL, &val)) return val; else return Nullable<ratio_measure>(); }
        void put_upper_value_for_strain(ratio_measure value) { sdaiPutAttrBN(m_instance, "upper_value_for_strain", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of material_property_context_stress
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class material_property_context_stress : public virtual material_property_context
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of material_property_context_stress
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        material_property_context_stress(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "material_property_context_stress")
        {}

                /// <summary>
                /// Create new instace of material_property_context_stress and returns object of this C++ class to interact with
                /// </summary>
        static material_property_context_stress Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "material_property_context_stress"); assert(inst); return inst; }

        Nullable<pressure_measure> get_lower_value_for_stress() { pressure_measure val = (pressure_measure) 0; if (sdaiGetAttrBN(m_instance, "lower_value_for_stress", sdaiREAL, &val)) return val; else return Nullable<pressure_measure>(); }
        void put_lower_value_for_stress(pressure_measure value) { sdaiPutAttrBN(m_instance, "lower_value_for_stress", sdaiREAL, &value); }

        Nullable<pressure_measure> get_upper_value_for_stress() { pressure_measure val = (pressure_measure) 0; if (sdaiGetAttrBN(m_instance, "upper_value_for_stress", sdaiREAL, &val)) return val; else return Nullable<pressure_measure>(); }
        void put_upper_value_for_stress(pressure_measure value) { sdaiPutAttrBN(m_instance, "upper_value_for_stress", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of material_property_context_temperature
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class material_property_context_temperature : public virtual material_property_context
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of material_property_context_temperature
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        material_property_context_temperature(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "material_property_context_temperature")
        {}

                /// <summary>
                /// Create new instace of material_property_context_temperature and returns object of this C++ class to interact with
                /// </summary>
        static material_property_context_temperature Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "material_property_context_temperature"); assert(inst); return inst; }

        Nullable<thermodynamic_temperature_measure> get_temperature_lower_bound() { thermodynamic_temperature_measure val = (thermodynamic_temperature_measure) 0; if (sdaiGetAttrBN(m_instance, "temperature_lower_bound", sdaiREAL, &val)) return val; else return Nullable<thermodynamic_temperature_measure>(); }
        void put_temperature_lower_bound(thermodynamic_temperature_measure value) { sdaiPutAttrBN(m_instance, "temperature_lower_bound", sdaiREAL, &value); }

        Nullable<thermodynamic_temperature_measure> get_temperature_upper_bound() { thermodynamic_temperature_measure val = (thermodynamic_temperature_measure) 0; if (sdaiGetAttrBN(m_instance, "temperature_upper_bound", sdaiREAL, &val)) return val; else return Nullable<thermodynamic_temperature_measure>(); }
        void put_temperature_upper_bound(thermodynamic_temperature_measure value) { sdaiPutAttrBN(m_instance, "temperature_upper_bound", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of material_representation
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class material_representation : public virtual representation
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of material_representation
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        material_representation(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "material_representation")
        {}

                /// <summary>
                /// Create new instace of material_representation and returns object of this C++ class to interact with
                /// </summary>
        static material_representation Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "material_representation"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of material_strength
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class material_strength : public virtual material_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of material_strength
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        material_strength(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "material_strength")
        {}

                /// <summary>
                /// Create new instace of material_strength and returns object of this C++ class to interact with
                /// </summary>
        static material_strength Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "material_strength"); assert(inst); return inst; }

        Nullable<pressure_measure> get_material_strength_value() { pressure_measure val = (pressure_measure) 0; if (sdaiGetAttrBN(m_instance, "material_strength_value", sdaiREAL, &val)) return val; else return Nullable<pressure_measure>(); }
        void put_material_strength_value(pressure_measure value) { sdaiPutAttrBN(m_instance, "material_strength_value", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of material_thermal_expansion
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class material_thermal_expansion : public virtual material_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of material_thermal_expansion
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        material_thermal_expansion(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "material_thermal_expansion")
        {}

                /// <summary>
                /// Create new instace of material_thermal_expansion and returns object of this C++ class to interact with
                /// </summary>
        static material_thermal_expansion Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "material_thermal_expansion"); assert(inst); return inst; }

        Nullable<context_dependent_measure> get_thermal_expansion_coeff() { context_dependent_measure val = (context_dependent_measure) 0; if (sdaiGetAttrBN(m_instance, "thermal_expansion_coeff", sdaiREAL, &val)) return val; else return Nullable<context_dependent_measure>(); }
        void put_thermal_expansion_coeff(context_dependent_measure value) { sdaiPutAttrBN(m_instance, "thermal_expansion_coeff", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of material_toughness
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class material_toughness : public virtual material_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of material_toughness
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        material_toughness(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "material_toughness")
        {}

                /// <summary>
                /// Create new instace of material_toughness and returns object of this C++ class to interact with
                /// </summary>
        static material_toughness Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "material_toughness"); assert(inst); return inst; }

        Nullable<context_dependent_measure> get_toughness_values() { context_dependent_measure val = (context_dependent_measure) 0; if (sdaiGetAttrBN(m_instance, "toughness_values", sdaiREAL, &val)) return val; else return Nullable<context_dependent_measure>(); }
        void put_toughness_values(context_dependent_measure value) { sdaiPutAttrBN(m_instance, "toughness_values", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of measure_qualification
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class measure_qualification : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of measure_qualification
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        measure_qualification(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "measure_qualification")
        {}

                /// <summary>
                /// Create new instace of measure_qualification and returns object of this C++ class to interact with
                /// </summary>
        static measure_qualification Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "measure_qualification"); assert(inst); return inst; }

        label get_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_name(label value) { sdaiPutAttrBN(m_instance, "name", sdaiSTRING, value); }

        text get_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_description(text value) { sdaiPutAttrBN(m_instance, "description", sdaiSTRING, value); }

        measure_with_unit get_qualified_measure();
        void put_qualified_measure(measure_with_unit inst);

        //TList may be set_of_value_qualifier or list of converible elements
        template <typename TList> void get_qualifiers(TList& lst) { set_of_value_qualifierSerializer<TList> sr; sr.FromAttr(lst, m_instance, "qualifiers"); }

        //TList may be set_of_value_qualifier or list of converible elements
        template <typename TList> void put_qualifiers(TList& lst) { set_of_value_qualifierSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "qualifiers"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of media_content
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class media_content : public virtual group_assignment
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of media_content
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        media_content(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "media_content")
        {}

                /// <summary>
                /// Create new instace of media_content and returns object of this C++ class to interact with
                /// </summary>
        static media_content Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "media_content"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of media_content_drawing
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class media_content_drawing : public virtual media_content
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of media_content_drawing
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        media_content_drawing(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "media_content_drawing")
        {}

                /// <summary>
                /// Create new instace of media_content_drawing and returns object of this C++ class to interact with
                /// </summary>
        static media_content_drawing Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "media_content_drawing"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of media_file
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class media_file : public virtual group
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of media_file
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        media_file(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "media_file")
        {}

                /// <summary>
                /// Create new instace of media_file and returns object of this C++ class to interact with
                /// </summary>
        static media_file Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "media_file"); assert(inst); return inst; }

        label get_file_source() { label val = NULL; if (sdaiGetAttrBN(m_instance, "file_source", sdaiSTRING, &val)) return val; else return NULL; }
        void put_file_source(label value) { sdaiPutAttrBN(m_instance, "file_source", sdaiSTRING, value); }

        label get_file_format() { label val = NULL; if (sdaiGetAttrBN(m_instance, "file_format", sdaiSTRING, &val)) return val; else return NULL; }
        void put_file_format(label value) { sdaiPutAttrBN(m_instance, "file_format", sdaiSTRING, value); }

        date_and_time get_file_date();
        void put_file_date(date_and_time inst);

        label get_media_type() { label val = NULL; if (sdaiGetAttrBN(m_instance, "media_type", sdaiSTRING, &val)) return val; else return NULL; }
        void put_media_type(label value) { sdaiPutAttrBN(m_instance, "media_type", sdaiSTRING, value); }

        //TList may be list_of_person_and_organization or list of converible elements
        template <typename TList> void get_author(TList& lst) { list_of_person_and_organizationSerializer<TList> sr; sr.FromAttr(lst, m_instance, "author"); }

        //TList may be list_of_person_and_organization or list of converible elements
        template <typename TList> void put_author(TList& lst) { list_of_person_and_organizationSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "author"); }

        //TArrayElem[] may be person_and_organization[] or array of convertible elements
        template <typename TArrayElem> void put_author(TArrayElem arr[], size_t n) { list_of_person_and_organization lst; ArrayToList(arr, n, lst); put_author(lst); }

        //TList may be list_of_person_and_organization or list of converible elements
        template <typename TList> void get_owner(TList& lst) { list_of_person_and_organizationSerializer<TList> sr; sr.FromAttr(lst, m_instance, "owner"); }

        //TList may be list_of_person_and_organization or list of converible elements
        template <typename TList> void put_owner(TList& lst) { list_of_person_and_organizationSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "owner"); }

        //TArrayElem[] may be person_and_organization[] or array of convertible elements
        template <typename TArrayElem> void put_owner(TArrayElem arr[], size_t n) { list_of_person_and_organization lst; ArrayToList(arr, n, lst); put_owner(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of media_file_cnc
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class media_file_cnc : public virtual media_file
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of media_file_cnc
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        media_file_cnc(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "media_file_cnc")
        {}

                /// <summary>
                /// Create new instace of media_file_cnc and returns object of this C++ class to interact with
                /// </summary>
        static media_file_cnc Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "media_file_cnc"); assert(inst); return inst; }

        label get_cnc_data_format() { label val = NULL; if (sdaiGetAttrBN(m_instance, "cnc_data_format", sdaiSTRING, &val)) return val; else return NULL; }
        void put_cnc_data_format(label value) { sdaiPutAttrBN(m_instance, "cnc_data_format", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of media_file_drawing
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class media_file_drawing : public virtual media_file
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of media_file_drawing
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        media_file_drawing(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "media_file_drawing")
        {}

                /// <summary>
                /// Create new instace of media_file_drawing and returns object of this C++ class to interact with
                /// </summary>
        static media_file_drawing Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "media_file_drawing"); assert(inst); return inst; }

        label get_drawing_number() { label val = NULL; if (sdaiGetAttrBN(m_instance, "drawing_number", sdaiSTRING, &val)) return val; else return NULL; }
        void put_drawing_number(label value) { sdaiPutAttrBN(m_instance, "drawing_number", sdaiSTRING, value); }

        Nullable<drawing_class> get_drawing_type() { int v = getENUM("drawing_type", drawing_class_); if (v >= 0) return (drawing_class) v; else return Nullable<drawing_class>(); }
        void put_drawing_type(drawing_class value) { TextValue val = drawing_class_[(int) value]; sdaiPutAttrBN(m_instance, "drawing_type", sdaiENUM, val); }

        label get_drawing_size() { label val = NULL; if (sdaiGetAttrBN(m_instance, "drawing_size", sdaiSTRING, &val)) return val; else return NULL; }
        void put_drawing_size(label value) { sdaiPutAttrBN(m_instance, "drawing_size", sdaiSTRING, value); }

        label get_current_revision_mark() { label val = NULL; if (sdaiGetAttrBN(m_instance, "current_revision_mark", sdaiSTRING, &val)) return val; else return NULL; }
        void put_current_revision_mark(label value) { sdaiPutAttrBN(m_instance, "current_revision_mark", sdaiSTRING, value); }

        person_and_organization get_current_revision_by();
        void put_current_revision_by(person_and_organization inst);

        date_and_time get_current_revision_date();
        void put_current_revision_date(date_and_time inst);

        text get_current_revision_note() { text val = NULL; if (sdaiGetAttrBN(m_instance, "current_revision_note", sdaiSTRING, &val)) return val; else return NULL; }
        void put_current_revision_note(text value) { sdaiPutAttrBN(m_instance, "current_revision_note", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of modulus_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class modulus_measure_with_unit : public virtual derived_measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of modulus_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        modulus_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "modulus_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of modulus_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static modulus_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "modulus_measure_with_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of modulus_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class modulus_unit : public virtual derived_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of modulus_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        modulus_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "modulus_unit")
        {}

                /// <summary>
                /// Create new instace of modulus_unit and returns object of this C++ class to interact with
                /// </summary>
        static modulus_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "modulus_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of moment_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class moment_measure_with_unit : public virtual derived_measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of moment_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        moment_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "moment_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of moment_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static moment_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "moment_measure_with_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of moment_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class moment_unit : public virtual derived_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of moment_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        moment_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "moment_unit")
        {}

                /// <summary>
                /// Create new instace of moment_unit and returns object of this C++ class to interact with
                /// </summary>
        static moment_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "moment_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of move
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class move : public virtual structural_frame_process
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of move
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        move(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "move")
        {}

                /// <summary>
                /// Create new instace of move and returns object of this C++ class to interact with
                /// </summary>
        static move Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "move"); assert(inst); return inst; }

        placement get_initial_location();
        void put_initial_location(placement inst);

        placement get_final_location();
        void put_final_location(placement inst);

        curve get_path();
        void put_path(curve inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of name_attribute
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class name_attribute : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of name_attribute
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        name_attribute(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "name_attribute")
        {}

                /// <summary>
                /// Create new instace of name_attribute and returns object of this C++ class to interact with
                /// </summary>
        static name_attribute Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "name_attribute"); assert(inst); return inst; }

        label get_attribute_value() { label val = NULL; if (sdaiGetAttrBN(m_instance, "attribute_value", sdaiSTRING, &val)) return val; else return NULL; }
        void put_attribute_value(label value) { sdaiPutAttrBN(m_instance, "attribute_value", sdaiSTRING, value); }

        name_attribute_select_get get_named_item() { return name_attribute_select_get(m_instance, "named_item", NULL); }
        name_attribute_select_put put_named_item() { return name_attribute_select_put(m_instance, "named_item", NULL); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of node
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class node : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of node
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        node(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "node")
        {}

                /// <summary>
                /// Create new instace of node and returns object of this C++ class to interact with
                /// </summary>
        static node Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "node"); assert(inst); return inst; }

        label get_node_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "node_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_node_name(label value) { sdaiPutAttrBN(m_instance, "node_name", sdaiSTRING, value); }

        point get_node_coords();
        void put_node_coords(point inst);

        boundary_condition get_restraints();
        void put_restraints(boundary_condition inst);

        analysis_model get_parent_model();
        void put_parent_model(analysis_model inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of node_dependency
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class node_dependency : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of node_dependency
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        node_dependency(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "node_dependency")
        {}

                /// <summary>
                /// Create new instace of node_dependency and returns object of this C++ class to interact with
                /// </summary>
        static node_dependency Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "node_dependency"); assert(inst); return inst; }

        node get_master_node();
        void put_master_node(node inst);

        node get_slave_node();
        void put_slave_node(node inst);

        text get_dependency_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "dependency_description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_dependency_description(text value) { sdaiPutAttrBN(m_instance, "dependency_description", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of object_role
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class object_role : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of object_role
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        object_role(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "object_role")
        {}

                /// <summary>
                /// Create new instace of object_role and returns object of this C++ class to interact with
                /// </summary>
        static object_role Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "object_role"); assert(inst); return inst; }

        label get_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_name(label value) { sdaiPutAttrBN(m_instance, "name", sdaiSTRING, value); }

        text get_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_description(text value) { sdaiPutAttrBN(m_instance, "description", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of offset_curve_2d
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class offset_curve_2d : public virtual curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of offset_curve_2d
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        offset_curve_2d(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "offset_curve_2d")
        {}

                /// <summary>
                /// Create new instace of offset_curve_2d and returns object of this C++ class to interact with
                /// </summary>
        static offset_curve_2d Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "offset_curve_2d"); assert(inst); return inst; }

        curve get_basis_curve();
        void put_basis_curve(curve inst);

        Nullable<length_measure> get_distance() { length_measure val = (length_measure) 0; if (sdaiGetAttrBN(m_instance, "distance", sdaiREAL, &val)) return val; else return Nullable<length_measure>(); }
        void put_distance(length_measure value) { sdaiPutAttrBN(m_instance, "distance", sdaiREAL, &value); }

        Nullable<LOGICAL_VALUE> get_self_intersect() { int v = getENUM("self_intersect", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_self_intersect(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "self_intersect", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of offset_curve_3d
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class offset_curve_3d : public virtual curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of offset_curve_3d
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        offset_curve_3d(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "offset_curve_3d")
        {}

                /// <summary>
                /// Create new instace of offset_curve_3d and returns object of this C++ class to interact with
                /// </summary>
        static offset_curve_3d Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "offset_curve_3d"); assert(inst); return inst; }

        curve get_basis_curve();
        void put_basis_curve(curve inst);

        Nullable<length_measure> get_distance() { length_measure val = (length_measure) 0; if (sdaiGetAttrBN(m_instance, "distance", sdaiREAL, &val)) return val; else return Nullable<length_measure>(); }
        void put_distance(length_measure value) { sdaiPutAttrBN(m_instance, "distance", sdaiREAL, &value); }

        Nullable<LOGICAL_VALUE> get_self_intersect() { int v = getENUM("self_intersect", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_self_intersect(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "self_intersect", sdaiENUM, val); }

        direction get_ref_direction();
        void put_ref_direction(direction inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of offset_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class offset_surface : public virtual surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of offset_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        offset_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "offset_surface")
        {}

                /// <summary>
                /// Create new instace of offset_surface and returns object of this C++ class to interact with
                /// </summary>
        static offset_surface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "offset_surface"); assert(inst); return inst; }

        surface get_basis_surface();
        void put_basis_surface(surface inst);

        Nullable<length_measure> get_distance() { length_measure val = (length_measure) 0; if (sdaiGetAttrBN(m_instance, "distance", sdaiREAL, &val)) return val; else return Nullable<length_measure>(); }
        void put_distance(length_measure value) { sdaiPutAttrBN(m_instance, "distance", sdaiREAL, &value); }

        Nullable<LOGICAL_VALUE> get_self_intersect() { int v = getENUM("self_intersect", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_self_intersect(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "self_intersect", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of open_path
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class open_path : public virtual path
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of open_path
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        open_path(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "open_path")
        {}

                /// <summary>
                /// Create new instace of open_path and returns object of this C++ class to interact with
                /// </summary>
        static open_path Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "open_path"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of open_shell
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class open_shell : public virtual connected_face_set
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of open_shell
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        open_shell(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "open_shell")
        {}

                /// <summary>
                /// Create new instace of open_shell and returns object of this C++ class to interact with
                /// </summary>
        static open_shell Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "open_shell"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of organization
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class organization : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of organization
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        organization(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "organization")
        {}

                /// <summary>
                /// Create new instace of organization and returns object of this C++ class to interact with
                /// </summary>
        static organization Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "organization"); assert(inst); return inst; }

        identifier get_id() { identifier val = NULL; if (sdaiGetAttrBN(m_instance, "id", sdaiSTRING, &val)) return val; else return NULL; }
        void put_id(identifier value) { sdaiPutAttrBN(m_instance, "id", sdaiSTRING, value); }

        label get_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_name(label value) { sdaiPutAttrBN(m_instance, "name", sdaiSTRING, value); }

        text get_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_description(text value) { sdaiPutAttrBN(m_instance, "description", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of organization_relationship
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class organization_relationship : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of organization_relationship
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        organization_relationship(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "organization_relationship")
        {}

                /// <summary>
                /// Create new instace of organization_relationship and returns object of this C++ class to interact with
                /// </summary>
        static organization_relationship Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "organization_relationship"); assert(inst); return inst; }

        label get_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_name(label value) { sdaiPutAttrBN(m_instance, "name", sdaiSTRING, value); }

        text get_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_description(text value) { sdaiPutAttrBN(m_instance, "description", sdaiSTRING, value); }

        organization get_relating_organization();
        void put_relating_organization(organization inst);

        organization get_related_organization();
        void put_related_organization(organization inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of organization_relationship_contractual
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class organization_relationship_contractual : public virtual organization_relationship
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of organization_relationship_contractual
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        organization_relationship_contractual(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "organization_relationship_contractual")
        {}

                /// <summary>
                /// Create new instace of organization_relationship_contractual and returns object of this C++ class to interact with
                /// </summary>
        static organization_relationship_contractual Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "organization_relationship_contractual"); assert(inst); return inst; }

        contract get_assigned_contract();
        void put_assigned_contract(contract inst);

        date_and_time get_effective_start_date();
        void put_effective_start_date(date_and_time inst);

        date_and_time get_effective_end_date();
        void put_effective_end_date(date_and_time inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of organizational_address
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class organizational_address : public virtual address
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of organizational_address
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        organizational_address(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "organizational_address")
        {}

                /// <summary>
                /// Create new instace of organizational_address and returns object of this C++ class to interact with
                /// </summary>
        static organizational_address Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "organizational_address"); assert(inst); return inst; }

        //TList may be set_of_organization or list of converible elements
        template <typename TList> void get_organizations(TList& lst) { set_of_organizationSerializer<TList> sr; sr.FromAttr(lst, m_instance, "organizations"); }

        //TList may be set_of_organization or list of converible elements
        template <typename TList> void put_organizations(TList& lst) { set_of_organizationSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "organizations"); }

        //TArrayElem[] may be organization[] or array of convertible elements
        template <typename TArrayElem> void put_organizations(TArrayElem arr[], size_t n) { set_of_organization lst; ArrayToList(arr, n, lst); put_organizations(lst); }

        text get_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_description(text value) { sdaiPutAttrBN(m_instance, "description", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of oriented_closed_shell
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class oriented_closed_shell : public virtual closed_shell
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of oriented_closed_shell
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        oriented_closed_shell(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "oriented_closed_shell")
        {}

                /// <summary>
                /// Create new instace of oriented_closed_shell and returns object of this C++ class to interact with
                /// </summary>
        static oriented_closed_shell Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "oriented_closed_shell"); assert(inst); return inst; }

        closed_shell get_closed_shell_element();
        void put_closed_shell_element(closed_shell inst);

        Nullable<bool> get_orientation() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "orientation", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_orientation(bool value) { sdaiPutAttrBN(m_instance, "orientation", sdaiBOOLEAN, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of oriented_edge
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class oriented_edge : public virtual edge
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of oriented_edge
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        oriented_edge(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "oriented_edge")
        {}

                /// <summary>
                /// Create new instace of oriented_edge and returns object of this C++ class to interact with
                /// </summary>
        static oriented_edge Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "oriented_edge"); assert(inst); return inst; }

        edge get_edge_element();
        void put_edge_element(edge inst);

        Nullable<bool> get_orientation() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "orientation", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_orientation(bool value) { sdaiPutAttrBN(m_instance, "orientation", sdaiBOOLEAN, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of oriented_face
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class oriented_face : public virtual face
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of oriented_face
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        oriented_face(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "oriented_face")
        {}

                /// <summary>
                /// Create new instace of oriented_face and returns object of this C++ class to interact with
                /// </summary>
        static oriented_face Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "oriented_face"); assert(inst); return inst; }

        face get_face_element();
        void put_face_element(face inst);

        Nullable<bool> get_orientation() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "orientation", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_orientation(bool value) { sdaiPutAttrBN(m_instance, "orientation", sdaiBOOLEAN, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of oriented_open_shell
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class oriented_open_shell : public virtual open_shell
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of oriented_open_shell
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        oriented_open_shell(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "oriented_open_shell")
        {}

                /// <summary>
                /// Create new instace of oriented_open_shell and returns object of this C++ class to interact with
                /// </summary>
        static oriented_open_shell Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "oriented_open_shell"); assert(inst); return inst; }

        open_shell get_open_shell_element();
        void put_open_shell_element(open_shell inst);

        Nullable<bool> get_orientation() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "orientation", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_orientation(bool value) { sdaiPutAttrBN(m_instance, "orientation", sdaiBOOLEAN, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of oriented_path
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class oriented_path : public virtual path
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of oriented_path
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        oriented_path(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "oriented_path")
        {}

                /// <summary>
                /// Create new instace of oriented_path and returns object of this C++ class to interact with
                /// </summary>
        static oriented_path Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "oriented_path"); assert(inst); return inst; }

        path get_path_element();
        void put_path_element(path inst);

        Nullable<bool> get_orientation() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "orientation", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_orientation(bool value) { sdaiPutAttrBN(m_instance, "orientation", sdaiBOOLEAN, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of oriented_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class oriented_surface : public virtual surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of oriented_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        oriented_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "oriented_surface")
        {}

                /// <summary>
                /// Create new instace of oriented_surface and returns object of this C++ class to interact with
                /// </summary>
        static oriented_surface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "oriented_surface"); assert(inst); return inst; }

        Nullable<bool> get_orientation() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "orientation", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_orientation(bool value) { sdaiPutAttrBN(m_instance, "orientation", sdaiBOOLEAN, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of outer_boundary_curve
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class outer_boundary_curve : public virtual boundary_curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of outer_boundary_curve
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        outer_boundary_curve(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "outer_boundary_curve")
        {}

                /// <summary>
                /// Create new instace of outer_boundary_curve and returns object of this C++ class to interact with
                /// </summary>
        static outer_boundary_curve Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "outer_boundary_curve"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of parabola
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class parabola : public virtual conic
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of parabola
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        parabola(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "parabola")
        {}

                /// <summary>
                /// Create new instace of parabola and returns object of this C++ class to interact with
                /// </summary>
        static parabola Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "parabola"); assert(inst); return inst; }

        Nullable<length_measure> get_focal_dist() { length_measure val = (length_measure) 0; if (sdaiGetAttrBN(m_instance, "focal_dist", sdaiREAL, &val)) return val; else return Nullable<length_measure>(); }
        void put_focal_dist(length_measure value) { sdaiPutAttrBN(m_instance, "focal_dist", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of parametric_representation_context
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class parametric_representation_context : public virtual representation_context
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of parametric_representation_context
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        parametric_representation_context(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "parametric_representation_context")
        {}

                /// <summary>
                /// Create new instace of parametric_representation_context and returns object of this C++ class to interact with
                /// </summary>
        static parametric_representation_context Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "parametric_representation_context"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of part
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class part : public virtual structural_frame_product
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of part
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        part(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "part")
        {}

                /// <summary>
                /// Create new instace of part and returns object of this C++ class to interact with
                /// </summary>
        static part Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "part"); assert(inst); return inst; }

        Nullable<fabrication_type> get_fabrication_method() { int v = getENUM("fabrication_method", fabrication_type_); if (v >= 0) return (fabrication_type) v; else return Nullable<fabrication_type>(); }
        void put_fabrication_method(fabrication_type value) { TextValue val = fabrication_type_[(int) value]; sdaiPutAttrBN(m_instance, "fabrication_method", sdaiENUM, val); }

        text get_manufacturers_ref() { text val = NULL; if (sdaiGetAttrBN(m_instance, "manufacturers_ref", sdaiSTRING, &val)) return val; else return NULL; }
        void put_manufacturers_ref(text value) { sdaiPutAttrBN(m_instance, "manufacturers_ref", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of part_complex
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class part_complex : public virtual part
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of part_complex
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        part_complex(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "part_complex")
        {}

                /// <summary>
                /// Create new instace of part_complex and returns object of this C++ class to interact with
                /// </summary>
        static part_complex Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "part_complex"); assert(inst); return inst; }

        shape_representation_with_units get_part_shape();
        void put_part_shape(shape_representation_with_units inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of part_derived
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class part_derived : public virtual part
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of part_derived
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        part_derived(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "part_derived")
        {}

                /// <summary>
                /// Create new instace of part_derived and returns object of this C++ class to interact with
                /// </summary>
        static part_derived Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "part_derived"); assert(inst); return inst; }

        part get_made_from();
        void put_made_from(part inst);

        //TList may be set_of_structural_frame_process or list of converible elements
        template <typename TList> void get_involved_processes(TList& lst) { set_of_structural_frame_processSerializer<TList> sr; sr.FromAttr(lst, m_instance, "involved_processes"); }

        //TList may be set_of_structural_frame_process or list of converible elements
        template <typename TList> void put_involved_processes(TList& lst) { set_of_structural_frame_processSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "involved_processes"); }

        //TArrayElem[] may be structural_frame_process[] or array of convertible elements
        template <typename TArrayElem> void put_involved_processes(TArrayElem arr[], size_t n) { set_of_structural_frame_process lst; ArrayToList(arr, n, lst); put_involved_processes(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of part_map
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class part_map : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of part_map
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        part_map(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "part_map")
        {}

                /// <summary>
                /// Create new instace of part_map and returns object of this C++ class to interact with
                /// </summary>
        static part_map Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "part_map"); assert(inst); return inst; }

        part get_represented_part();
        void put_represented_part(part inst);

        //TList may be set_of_element or list of converible elements
        template <typename TList> void get_representing_elements(TList& lst) { set_of_elementSerializer<TList> sr; sr.FromAttr(lst, m_instance, "representing_elements"); }

        //TList may be set_of_element or list of converible elements
        template <typename TList> void put_representing_elements(TList& lst) { set_of_elementSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "representing_elements"); }

        //TArrayElem[] may be element[] or array of convertible elements
        template <typename TArrayElem> void put_representing_elements(TArrayElem arr[], size_t n) { set_of_element lst; ArrayToList(arr, n, lst); put_representing_elements(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of part_prismatic
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class part_prismatic : public virtual part
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of part_prismatic
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        part_prismatic(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "part_prismatic")
        {}

    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of part_prismatic_complex
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class part_prismatic_complex : public virtual part_prismatic
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of part_prismatic_complex
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        part_prismatic_complex(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "part_prismatic_complex")
        {}

                /// <summary>
                /// Create new instace of part_prismatic_complex and returns object of this C++ class to interact with
                /// </summary>
        static part_prismatic_complex Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "part_prismatic_complex"); assert(inst); return inst; }

        //TList may be list_of_section_profile or list of converible elements
        template <typename TList> void get_cross_sections(TList& lst) { list_of_section_profileSerializer<TList> sr; sr.FromAttr(lst, m_instance, "cross_sections"); }

        //TList may be list_of_section_profile or list of converible elements
        template <typename TList> void put_cross_sections(TList& lst) { list_of_section_profileSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "cross_sections"); }

        //TArrayElem[] may be section_profile[] or array of convertible elements
        template <typename TArrayElem> void put_cross_sections(TArrayElem arr[], size_t n) { list_of_section_profile lst; ArrayToList(arr, n, lst); put_cross_sections(lst); }

        //TList may be list_of_point_on_curve or list of converible elements
        template <typename TList> void get_points_defining_part_axis(TList& lst) { list_of_point_on_curveSerializer<TList> sr; sr.FromAttr(lst, m_instance, "points_defining_part_axis"); }

        //TList may be list_of_point_on_curve or list of converible elements
        template <typename TList> void put_points_defining_part_axis(TList& lst) { list_of_point_on_curveSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "points_defining_part_axis"); }

        //TArrayElem[] may be point_on_curve[] or array of convertible elements
        template <typename TArrayElem> void put_points_defining_part_axis(TArrayElem arr[], size_t n) { list_of_point_on_curve lst; ArrayToList(arr, n, lst); put_points_defining_part_axis(lst); }

        //TList may be list_of_orientation_select or list of converible elements
        template <typename TList> void get_section_orientations(TList& lst) { list_of_orientation_selectSerializer<TList> sr; sr.FromAttr(lst, m_instance, "section_orientations"); }

        //TList may be list_of_orientation_select or list of converible elements
        template <typename TList> void put_section_orientations(TList& lst) { list_of_orientation_selectSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "section_orientations"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of part_prismatic_complex_tapered
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class part_prismatic_complex_tapered : public virtual part_prismatic_complex
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of part_prismatic_complex_tapered
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        part_prismatic_complex_tapered(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "part_prismatic_complex_tapered")
        {}

                /// <summary>
                /// Create new instace of part_prismatic_complex_tapered and returns object of this C++ class to interact with
                /// </summary>
        static part_prismatic_complex_tapered Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "part_prismatic_complex_tapered"); assert(inst); return inst; }

        text get_taper_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "taper_description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_taper_description(text value) { sdaiPutAttrBN(m_instance, "taper_description", sdaiSTRING, value); }

        length_measure_with_unit get_absolute_taper_1();
        void put_absolute_taper_1(length_measure_with_unit inst);

        length_measure_with_unit get_absolute_taper_2();
        void put_absolute_taper_2(length_measure_with_unit inst);

        ratio_measure_with_unit get_relative_taper_1();
        void put_relative_taper_1(ratio_measure_with_unit inst);

        ratio_measure_with_unit get_relative_taper_2();
        void put_relative_taper_2(ratio_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of part_prismatic_simple
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class part_prismatic_simple : public virtual part_prismatic
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of part_prismatic_simple
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        part_prismatic_simple(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "part_prismatic_simple")
        {}

                /// <summary>
                /// Create new instace of part_prismatic_simple and returns object of this C++ class to interact with
                /// </summary>
        static part_prismatic_simple Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "part_prismatic_simple"); assert(inst); return inst; }

        section_profile get_profile();
        void put_profile(section_profile inst);

        positive_length_measure_with_unit get_cut_length();
        void put_cut_length(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_stock_length();
        void put_stock_length(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_x_offset();
        void put_x_offset(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of part_prismatic_simple_cambered
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class part_prismatic_simple_cambered : public virtual part_prismatic_simple
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of part_prismatic_simple_cambered
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        part_prismatic_simple_cambered(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "part_prismatic_simple_cambered")
        {}

                /// <summary>
                /// Create new instace of part_prismatic_simple_cambered and returns object of this C++ class to interact with
                /// </summary>
        static part_prismatic_simple_cambered Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "part_prismatic_simple_cambered"); assert(inst); return inst; }

        text get_camber_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "camber_description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_camber_description(text value) { sdaiPutAttrBN(m_instance, "camber_description", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of part_prismatic_simple_cambered_absolute
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class part_prismatic_simple_cambered_absolute : public virtual part_prismatic_simple_cambered
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of part_prismatic_simple_cambered_absolute
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        part_prismatic_simple_cambered_absolute(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "part_prismatic_simple_cambered_absolute")
        {}

                /// <summary>
                /// Create new instace of part_prismatic_simple_cambered_absolute and returns object of this C++ class to interact with
                /// </summary>
        static part_prismatic_simple_cambered_absolute Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "part_prismatic_simple_cambered_absolute"); assert(inst); return inst; }

        positive_length_measure_with_unit get_absolute_offset_position();
        void put_absolute_offset_position(positive_length_measure_with_unit inst);

        length_measure_with_unit get_absolute_offset_y();
        void put_absolute_offset_y(length_measure_with_unit inst);

        length_measure_with_unit get_absolute_offset_z();
        void put_absolute_offset_z(length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of part_prismatic_simple_cambered_relative
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class part_prismatic_simple_cambered_relative : public virtual part_prismatic_simple_cambered
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of part_prismatic_simple_cambered_relative
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        part_prismatic_simple_cambered_relative(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "part_prismatic_simple_cambered_relative")
        {}

                /// <summary>
                /// Create new instace of part_prismatic_simple_cambered_relative and returns object of this C++ class to interact with
                /// </summary>
        static part_prismatic_simple_cambered_relative Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "part_prismatic_simple_cambered_relative"); assert(inst); return inst; }

        ratio_measure_with_unit get_relative_offset_position();
        void put_relative_offset_position(ratio_measure_with_unit inst);

        ratio_measure_with_unit get_relative_offset_y();
        void put_relative_offset_y(ratio_measure_with_unit inst);

        ratio_measure_with_unit get_relative_offset_z();
        void put_relative_offset_z(ratio_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of part_prismatic_simple_castellated
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class part_prismatic_simple_castellated : public virtual part_prismatic_simple
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of part_prismatic_simple_castellated
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        part_prismatic_simple_castellated(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "part_prismatic_simple_castellated")
        {}

                /// <summary>
                /// Create new instace of part_prismatic_simple_castellated and returns object of this C++ class to interact with
                /// </summary>
        static part_prismatic_simple_castellated Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "part_prismatic_simple_castellated"); assert(inst); return inst; }

        Nullable<castellation_type> get_part_castellation_type() { int v = getENUM("part_castellation_type", castellation_type_); if (v >= 0) return (castellation_type) v; else return Nullable<castellation_type>(); }
        void put_part_castellation_type(castellation_type value) { TextValue val = castellation_type_[(int) value]; sdaiPutAttrBN(m_instance, "part_castellation_type", sdaiENUM, val); }

        positive_length_measure_with_unit get_end_post_width_1();
        void put_end_post_width_1(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_end_post_width_2();
        void put_end_post_width_2(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_castellation_spacing();
        void put_castellation_spacing(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_castellation_height();
        void put_castellation_height(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_castellation_width();
        void put_castellation_width(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_castellation_depth();
        void put_castellation_depth(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of part_prismatic_simple_curved
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class part_prismatic_simple_curved : public virtual part_prismatic_simple
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of part_prismatic_simple_curved
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        part_prismatic_simple_curved(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "part_prismatic_simple_curved")
        {}

                /// <summary>
                /// Create new instace of part_prismatic_simple_curved and returns object of this C++ class to interact with
                /// </summary>
        static part_prismatic_simple_curved Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "part_prismatic_simple_curved"); assert(inst); return inst; }

        curve get_axis_definition();
        void put_axis_definition(curve inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of part_sheet
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class part_sheet : public virtual part
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of part_sheet
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        part_sheet(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "part_sheet")
        {}

                /// <summary>
                /// Create new instace of part_sheet and returns object of this C++ class to interact with
                /// </summary>
        static part_sheet Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "part_sheet"); assert(inst); return inst; }

        positive_length_measure_with_unit get_sheet_thickness();
        void put_sheet_thickness(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of part_sheet_bounded
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class part_sheet_bounded : public virtual part_sheet
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of part_sheet_bounded
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        part_sheet_bounded(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "part_sheet_bounded")
        {}

    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of part_sheet_bounded_complex
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class part_sheet_bounded_complex : public virtual part_sheet_bounded
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of part_sheet_bounded_complex
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        part_sheet_bounded_complex(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "part_sheet_bounded_complex")
        {}

                /// <summary>
                /// Create new instace of part_sheet_bounded_complex and returns object of this C++ class to interact with
                /// </summary>
        static part_sheet_bounded_complex Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "part_sheet_bounded_complex"); assert(inst); return inst; }

        bounded_surface get_sheet_boundary();
        void put_sheet_boundary(bounded_surface inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of part_sheet_bounded_simple
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class part_sheet_bounded_simple : public virtual part_sheet_bounded
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of part_sheet_bounded_simple
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        part_sheet_bounded_simple(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "part_sheet_bounded_simple")
        {}

                /// <summary>
                /// Create new instace of part_sheet_bounded_simple and returns object of this C++ class to interact with
                /// </summary>
        static part_sheet_bounded_simple Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "part_sheet_bounded_simple"); assert(inst); return inst; }

        positive_length_measure_with_unit get_cut_y_dimension();
        void put_cut_y_dimension(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_cut_z_dimension();
        void put_cut_z_dimension(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_stock_y_dimension();
        void put_stock_y_dimension(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_stock_z_dimension();
        void put_stock_z_dimension(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_y_offset();
        void put_y_offset(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_z_offset();
        void put_z_offset(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of part_sheet_profiled
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class part_sheet_profiled : public virtual part_sheet
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of part_sheet_profiled
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        part_sheet_profiled(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "part_sheet_profiled")
        {}

                /// <summary>
                /// Create new instace of part_sheet_profiled and returns object of this C++ class to interact with
                /// </summary>
        static part_sheet_profiled Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "part_sheet_profiled"); assert(inst); return inst; }

        curve get_sheet_profile();
        void put_sheet_profile(curve inst);

        section_properties get_profile_properties();
        void put_profile_properties(section_properties inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of person
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class person : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of person
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        person(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "person")
        {}

                /// <summary>
                /// Create new instace of person and returns object of this C++ class to interact with
                /// </summary>
        static person Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "person"); assert(inst); return inst; }

        identifier get_id() { identifier val = NULL; if (sdaiGetAttrBN(m_instance, "id", sdaiSTRING, &val)) return val; else return NULL; }
        void put_id(identifier value) { sdaiPutAttrBN(m_instance, "id", sdaiSTRING, value); }

        label get_last_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "last_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_last_name(label value) { sdaiPutAttrBN(m_instance, "last_name", sdaiSTRING, value); }

        label get_first_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "first_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_first_name(label value) { sdaiPutAttrBN(m_instance, "first_name", sdaiSTRING, value); }

        //TList may be list_of_label or list of converible elements
        template <typename TList> void get_middle_names(TList& lst) { list_of_labelSerializer<TList> sr; sr.FromAttr(lst, m_instance, "middle_names"); }

        //TList may be list_of_label or list of converible elements
        template <typename TList> void put_middle_names(TList& lst) { list_of_labelSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "middle_names"); }

        //TArrayElem[] may be label[] or array of convertible elements
        template <typename TArrayElem> void put_middle_names(TArrayElem arr[], size_t n) { list_of_label lst; ArrayToList(arr, n, lst); put_middle_names(lst); }

        //TList may be list_of_label or list of converible elements
        template <typename TList> void get_prefix_titles(TList& lst) { list_of_labelSerializer<TList> sr; sr.FromAttr(lst, m_instance, "prefix_titles"); }

        //TList may be list_of_label or list of converible elements
        template <typename TList> void put_prefix_titles(TList& lst) { list_of_labelSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "prefix_titles"); }

        //TArrayElem[] may be label[] or array of convertible elements
        template <typename TArrayElem> void put_prefix_titles(TArrayElem arr[], size_t n) { list_of_label lst; ArrayToList(arr, n, lst); put_prefix_titles(lst); }

        //TList may be list_of_label or list of converible elements
        template <typename TList> void get_suffix_titles(TList& lst) { list_of_labelSerializer<TList> sr; sr.FromAttr(lst, m_instance, "suffix_titles"); }

        //TList may be list_of_label or list of converible elements
        template <typename TList> void put_suffix_titles(TList& lst) { list_of_labelSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "suffix_titles"); }

        //TArrayElem[] may be label[] or array of convertible elements
        template <typename TArrayElem> void put_suffix_titles(TArrayElem arr[], size_t n) { list_of_label lst; ArrayToList(arr, n, lst); put_suffix_titles(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of person_and_organization
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class person_and_organization : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of person_and_organization
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        person_and_organization(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "person_and_organization")
        {}

                /// <summary>
                /// Create new instace of person_and_organization and returns object of this C++ class to interact with
                /// </summary>
        static person_and_organization Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "person_and_organization"); assert(inst); return inst; }

        person get_the_person();
        void put_the_person(person inst);

        organization get_the_organization();
        void put_the_organization(organization inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of person_and_organization_role
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class person_and_organization_role : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of person_and_organization_role
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        person_and_organization_role(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "person_and_organization_role")
        {}

                /// <summary>
                /// Create new instace of person_and_organization_role and returns object of this C++ class to interact with
                /// </summary>
        static person_and_organization_role Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "person_and_organization_role"); assert(inst); return inst; }

        label get_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_name(label value) { sdaiPutAttrBN(m_instance, "name", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of personal_address
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class personal_address : public virtual address
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of personal_address
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        personal_address(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "personal_address")
        {}

                /// <summary>
                /// Create new instace of personal_address and returns object of this C++ class to interact with
                /// </summary>
        static personal_address Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "personal_address"); assert(inst); return inst; }

        //TList may be set_of_person or list of converible elements
        template <typename TList> void get_people(TList& lst) { set_of_personSerializer<TList> sr; sr.FromAttr(lst, m_instance, "people"); }

        //TList may be set_of_person or list of converible elements
        template <typename TList> void put_people(TList& lst) { set_of_personSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "people"); }

        //TArrayElem[] may be person[] or array of convertible elements
        template <typename TArrayElem> void put_people(TArrayElem arr[], size_t n) { set_of_person lst; ArrayToList(arr, n, lst); put_people(lst); }

        text get_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_description(text value) { sdaiPutAttrBN(m_instance, "description", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of physical_action
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class physical_action : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of physical_action
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        physical_action(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "physical_action")
        {}

                /// <summary>
                /// Create new instace of physical_action and returns object of this C++ class to interact with
                /// </summary>
        static physical_action Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "physical_action"); assert(inst); return inst; }

        Nullable<static_or_dynamic> get_action_nature() { int v = getENUM("action_nature", static_or_dynamic_); if (v >= 0) return (static_or_dynamic) v; else return Nullable<static_or_dynamic>(); }
        void put_action_nature(static_or_dynamic value) { TextValue val = static_or_dynamic_[(int) value]; sdaiPutAttrBN(m_instance, "action_nature", sdaiENUM, val); }

        Nullable<spatial_variation> get_action_spatial_variation() { int v = getENUM("action_spatial_variation", spatial_variation_); if (v >= 0) return (spatial_variation) v; else return Nullable<spatial_variation>(); }
        void put_action_spatial_variation(spatial_variation value) { TextValue val = spatial_variation_[(int) value]; sdaiPutAttrBN(m_instance, "action_spatial_variation", sdaiENUM, val); }

        Nullable<direct_or_indirect_action> get_action_type() { int v = getENUM("action_type", direct_or_indirect_action_); if (v >= 0) return (direct_or_indirect_action) v; else return Nullable<direct_or_indirect_action>(); }
        void put_action_type(direct_or_indirect_action value) { TextValue val = direct_or_indirect_action_[(int) value]; sdaiPutAttrBN(m_instance, "action_type", sdaiENUM, val); }

        measure_with_unit get_basic_magnitude();
        void put_basic_magnitude(measure_with_unit inst);

        measure_with_unit get_derived_magnitude();
        void put_derived_magnitude(measure_with_unit inst);

        //TList may be list_of_double or list of converible elements
        template <typename TList> void get_derivation_factors(TList& lst) { list_of_doubleSerializer<TList> sr; sr.FromAttr(lst, m_instance, "derivation_factors"); }

        //TList may be list_of_double or list of converible elements
        template <typename TList> void put_derivation_factors(TList& lst) { list_of_doubleSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "derivation_factors"); }

        //TArrayElem[] may be double[] or array of convertible elements
        template <typename TArrayElem> void put_derivation_factors(TArrayElem arr[], size_t n) { list_of_double lst; ArrayToList(arr, n, lst); put_derivation_factors(lst); }

        //TList may be list_of_label or list of converible elements
        template <typename TList> void get_derivation_factor_labels(TList& lst) { list_of_labelSerializer<TList> sr; sr.FromAttr(lst, m_instance, "derivation_factor_labels"); }

        //TList may be list_of_label or list of converible elements
        template <typename TList> void put_derivation_factor_labels(TList& lst) { list_of_labelSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "derivation_factor_labels"); }

        //TArrayElem[] may be label[] or array of convertible elements
        template <typename TArrayElem> void put_derivation_factor_labels(TArrayElem arr[], size_t n) { list_of_label lst; ArrayToList(arr, n, lst); put_derivation_factor_labels(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of physical_action_accidental
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class physical_action_accidental : public virtual physical_action
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of physical_action_accidental
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        physical_action_accidental(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "physical_action_accidental")
        {}

                /// <summary>
                /// Create new instace of physical_action_accidental and returns object of this C++ class to interact with
                /// </summary>
        static physical_action_accidental Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "physical_action_accidental"); assert(inst); return inst; }

        Nullable<action_source_accidential> get_action_source() { int v = getENUM("action_source", action_source_accidential_); if (v >= 0) return (action_source_accidential) v; else return Nullable<action_source_accidential>(); }
        void put_action_source(action_source_accidential value) { TextValue val = action_source_accidential_[(int) value]; sdaiPutAttrBN(m_instance, "action_source", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of physical_action_permanent
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class physical_action_permanent : public virtual physical_action
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of physical_action_permanent
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        physical_action_permanent(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "physical_action_permanent")
        {}

                /// <summary>
                /// Create new instace of physical_action_permanent and returns object of this C++ class to interact with
                /// </summary>
        static physical_action_permanent Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "physical_action_permanent"); assert(inst); return inst; }

        Nullable<action_source_permanent> get_action_source() { int v = getENUM("action_source", action_source_permanent_); if (v >= 0) return (action_source_permanent) v; else return Nullable<action_source_permanent>(); }
        void put_action_source(action_source_permanent value) { TextValue val = action_source_permanent_[(int) value]; sdaiPutAttrBN(m_instance, "action_source", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of physical_action_seismic
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class physical_action_seismic : public virtual physical_action
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of physical_action_seismic
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        physical_action_seismic(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "physical_action_seismic")
        {}

                /// <summary>
                /// Create new instace of physical_action_seismic and returns object of this C++ class to interact with
                /// </summary>
        static physical_action_seismic Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "physical_action_seismic"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of physical_action_variable
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class physical_action_variable : public virtual physical_action
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of physical_action_variable
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        physical_action_variable(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "physical_action_variable")
        {}

    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of physical_action_variable_long_term
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class physical_action_variable_long_term : public virtual physical_action_variable
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of physical_action_variable_long_term
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        physical_action_variable_long_term(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "physical_action_variable_long_term")
        {}

                /// <summary>
                /// Create new instace of physical_action_variable_long_term and returns object of this C++ class to interact with
                /// </summary>
        static physical_action_variable_long_term Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "physical_action_variable_long_term"); assert(inst); return inst; }

        Nullable<action_source_variable_long_term> get_action_source() { int v = getENUM("action_source", action_source_variable_long_term_); if (v >= 0) return (action_source_variable_long_term) v; else return Nullable<action_source_variable_long_term>(); }
        void put_action_source(action_source_variable_long_term value) { TextValue val = action_source_variable_long_term_[(int) value]; sdaiPutAttrBN(m_instance, "action_source", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of physical_action_variable_short_term
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class physical_action_variable_short_term : public virtual physical_action_variable
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of physical_action_variable_short_term
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        physical_action_variable_short_term(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "physical_action_variable_short_term")
        {}

                /// <summary>
                /// Create new instace of physical_action_variable_short_term and returns object of this C++ class to interact with
                /// </summary>
        static physical_action_variable_short_term Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "physical_action_variable_short_term"); assert(inst); return inst; }

        Nullable<action_source_variable_short_term> get_action_source() { int v = getENUM("action_source", action_source_variable_short_term_); if (v >= 0) return (action_source_variable_short_term) v; else return Nullable<action_source_variable_short_term>(); }
        void put_action_source(action_source_variable_short_term value) { TextValue val = action_source_variable_short_term_[(int) value]; sdaiPutAttrBN(m_instance, "action_source", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of physical_action_variable_transient
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class physical_action_variable_transient : public virtual physical_action_variable
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of physical_action_variable_transient
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        physical_action_variable_transient(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "physical_action_variable_transient")
        {}

                /// <summary>
                /// Create new instace of physical_action_variable_transient and returns object of this C++ class to interact with
                /// </summary>
        static physical_action_variable_transient Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "physical_action_variable_transient"); assert(inst); return inst; }

        Nullable<action_source_variable_transient> get_action_source() { int v = getENUM("action_source", action_source_variable_transient_); if (v >= 0) return (action_source_variable_transient) v; else return Nullable<action_source_variable_transient>(); }
        void put_action_source(action_source_variable_transient value) { TextValue val = action_source_variable_transient_[(int) value]; sdaiPutAttrBN(m_instance, "action_source", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of plane_angle_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class plane_angle_measure_with_unit : public virtual measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of plane_angle_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        plane_angle_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "plane_angle_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of plane_angle_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static plane_angle_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "plane_angle_measure_with_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of plane_angle_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class plane_angle_unit : public virtual named_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of plane_angle_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        plane_angle_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "plane_angle_unit")
        {}

                /// <summary>
                /// Create new instace of plane_angle_unit and returns object of this C++ class to interact with
                /// </summary>
        static plane_angle_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "plane_angle_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of point_in_volume
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class point_in_volume : public virtual point
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of point_in_volume
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        point_in_volume(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "point_in_volume")
        {}

                /// <summary>
                /// Create new instace of point_in_volume and returns object of this C++ class to interact with
                /// </summary>
        static point_in_volume Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "point_in_volume"); assert(inst); return inst; }

        volume get_basis_volume();
        void put_basis_volume(volume inst);

        Nullable<parameter_value> get_point_parameter_u() { parameter_value val = (parameter_value) 0; if (sdaiGetAttrBN(m_instance, "point_parameter_u", sdaiREAL, &val)) return val; else return Nullable<parameter_value>(); }
        void put_point_parameter_u(parameter_value value) { sdaiPutAttrBN(m_instance, "point_parameter_u", sdaiREAL, &value); }

        Nullable<parameter_value> get_point_parameter_v() { parameter_value val = (parameter_value) 0; if (sdaiGetAttrBN(m_instance, "point_parameter_v", sdaiREAL, &val)) return val; else return Nullable<parameter_value>(); }
        void put_point_parameter_v(parameter_value value) { sdaiPutAttrBN(m_instance, "point_parameter_v", sdaiREAL, &value); }

        Nullable<parameter_value> get_point_parameter_w() { parameter_value val = (parameter_value) 0; if (sdaiGetAttrBN(m_instance, "point_parameter_w", sdaiREAL, &val)) return val; else return Nullable<parameter_value>(); }
        void put_point_parameter_w(parameter_value value) { sdaiPutAttrBN(m_instance, "point_parameter_w", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of point_on_curve
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class point_on_curve : public virtual point
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of point_on_curve
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        point_on_curve(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "point_on_curve")
        {}

                /// <summary>
                /// Create new instace of point_on_curve and returns object of this C++ class to interact with
                /// </summary>
        static point_on_curve Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "point_on_curve"); assert(inst); return inst; }

        curve get_basis_curve();
        void put_basis_curve(curve inst);

        Nullable<parameter_value> get_point_parameter() { parameter_value val = (parameter_value) 0; if (sdaiGetAttrBN(m_instance, "point_parameter", sdaiREAL, &val)) return val; else return Nullable<parameter_value>(); }
        void put_point_parameter(parameter_value value) { sdaiPutAttrBN(m_instance, "point_parameter", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of point_on_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class point_on_surface : public virtual point
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of point_on_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        point_on_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "point_on_surface")
        {}

                /// <summary>
                /// Create new instace of point_on_surface and returns object of this C++ class to interact with
                /// </summary>
        static point_on_surface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "point_on_surface"); assert(inst); return inst; }

        surface get_basis_surface();
        void put_basis_surface(surface inst);

        Nullable<parameter_value> get_point_parameter_u() { parameter_value val = (parameter_value) 0; if (sdaiGetAttrBN(m_instance, "point_parameter_u", sdaiREAL, &val)) return val; else return Nullable<parameter_value>(); }
        void put_point_parameter_u(parameter_value value) { sdaiPutAttrBN(m_instance, "point_parameter_u", sdaiREAL, &value); }

        Nullable<parameter_value> get_point_parameter_v() { parameter_value val = (parameter_value) 0; if (sdaiGetAttrBN(m_instance, "point_parameter_v", sdaiREAL, &val)) return val; else return Nullable<parameter_value>(); }
        void put_point_parameter_v(parameter_value value) { sdaiPutAttrBN(m_instance, "point_parameter_v", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of point_replica
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class point_replica : public virtual point
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of point_replica
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        point_replica(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "point_replica")
        {}

                /// <summary>
                /// Create new instace of point_replica and returns object of this C++ class to interact with
                /// </summary>
        static point_replica Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "point_replica"); assert(inst); return inst; }

        point get_parent_pt();
        void put_parent_pt(point inst);

        cartesian_transformation_operator get_transformation();
        void put_transformation(cartesian_transformation_operator inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of polar_point
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class polar_point : public virtual cartesian_point
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of polar_point
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        polar_point(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "polar_point")
        {}

                /// <summary>
                /// Create new instace of polar_point and returns object of this C++ class to interact with
                /// </summary>
        static polar_point Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "polar_point"); assert(inst); return inst; }

        Nullable<length_measure> get_r() { length_measure val = (length_measure) 0; if (sdaiGetAttrBN(m_instance, "r", sdaiREAL, &val)) return val; else return Nullable<length_measure>(); }
        void put_r(length_measure value) { sdaiPutAttrBN(m_instance, "r", sdaiREAL, &value); }

        Nullable<plane_angle_measure> get_theta() { plane_angle_measure val = (plane_angle_measure) 0; if (sdaiGetAttrBN(m_instance, "theta", sdaiREAL, &val)) return val; else return Nullable<plane_angle_measure>(); }
        void put_theta(plane_angle_measure value) { sdaiPutAttrBN(m_instance, "theta", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of poly_loop
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class poly_loop : public virtual loop, public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of poly_loop
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        poly_loop(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "poly_loop")
        {}

                /// <summary>
                /// Create new instace of poly_loop and returns object of this C++ class to interact with
                /// </summary>
        static poly_loop Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "poly_loop"); assert(inst); return inst; }

        //TList may be list_of_cartesian_point or list of converible elements
        template <typename TList> void get_polygon(TList& lst) { list_of_cartesian_pointSerializer<TList> sr; sr.FromAttr(lst, m_instance, "polygon"); }

        //TList may be list_of_cartesian_point or list of converible elements
        template <typename TList> void put_polygon(TList& lst) { list_of_cartesian_pointSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "polygon"); }

        //TArrayElem[] may be cartesian_point[] or array of convertible elements
        template <typename TArrayElem> void put_polygon(TArrayElem arr[], size_t n) { list_of_cartesian_point lst; ArrayToList(arr, n, lst); put_polygon(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of polygonal_area
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class polygonal_area : public virtual primitive_2d
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of polygonal_area
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        polygonal_area(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "polygonal_area")
        {}

                /// <summary>
                /// Create new instace of polygonal_area and returns object of this C++ class to interact with
                /// </summary>
        static polygonal_area Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "polygonal_area"); assert(inst); return inst; }

        //TList may be list_of_cartesian_point or list of converible elements
        template <typename TList> void get_bounds(TList& lst) { list_of_cartesian_pointSerializer<TList> sr; sr.FromAttr(lst, m_instance, "bounds"); }

        //TList may be list_of_cartesian_point or list of converible elements
        template <typename TList> void put_bounds(TList& lst) { list_of_cartesian_pointSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "bounds"); }

        //TArrayElem[] may be cartesian_point[] or array of convertible elements
        template <typename TArrayElem> void put_bounds(TArrayElem arr[], size_t n) { list_of_cartesian_point lst; ArrayToList(arr, n, lst); put_bounds(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of polyline
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class polyline : public virtual bounded_curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of polyline
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        polyline(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "polyline")
        {}

                /// <summary>
                /// Create new instace of polyline and returns object of this C++ class to interact with
                /// </summary>
        static polyline Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "polyline"); assert(inst); return inst; }

        //TList may be list_of_cartesian_point or list of converible elements
        template <typename TList> void get_points(TList& lst) { list_of_cartesian_pointSerializer<TList> sr; sr.FromAttr(lst, m_instance, "points"); }

        //TList may be list_of_cartesian_point or list of converible elements
        template <typename TList> void put_points(TList& lst) { list_of_cartesian_pointSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "points"); }

        //TArrayElem[] may be cartesian_point[] or array of convertible elements
        template <typename TArrayElem> void put_points(TArrayElem arr[], size_t n) { list_of_cartesian_point lst; ArrayToList(arr, n, lst); put_points(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of positive_length_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class positive_length_measure_with_unit : public virtual measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of positive_length_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        positive_length_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "positive_length_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of positive_length_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static positive_length_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "positive_length_measure_with_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of precision_qualifier
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class precision_qualifier : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of precision_qualifier
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        precision_qualifier(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "precision_qualifier")
        {}

                /// <summary>
                /// Create new instace of precision_qualifier and returns object of this C++ class to interact with
                /// </summary>
        static precision_qualifier Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "precision_qualifier"); assert(inst); return inst; }

        Nullable<IntValue> get_precision_value() { IntValue val = (IntValue) 0; if (sdaiGetAttrBN(m_instance, "precision_value", sdaiINTEGER, &val)) return val; else return Nullable<IntValue>(); }
        void put_precision_value(IntValue value) { sdaiPutAttrBN(m_instance, "precision_value", sdaiINTEGER, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of pressure_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class pressure_measure_with_unit : public virtual measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of pressure_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        pressure_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "pressure_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of pressure_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static pressure_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "pressure_measure_with_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of pressure_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class pressure_unit : public virtual named_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of pressure_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        pressure_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "pressure_unit")
        {}

                /// <summary>
                /// Create new instace of pressure_unit and returns object of this C++ class to interact with
                /// </summary>
        static pressure_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "pressure_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of procure
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class procure : public virtual structural_frame_process
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of procure
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        procure(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "procure")
        {}

                /// <summary>
                /// Create new instace of procure and returns object of this C++ class to interact with
                /// </summary>
        static procure Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "procure"); assert(inst); return inst; }

        person_and_organization get_vendors();
        void put_vendors(person_and_organization inst);

        person_and_organization get_purchaser();
        void put_purchaser(person_and_organization inst);

        //TList may be list_of_product_item_select or list of converible elements
        template <typename TList> void get_purchased_products(TList& lst) { list_of_product_item_selectSerializer<TList> sr; sr.FromAttr(lst, m_instance, "purchased_products"); }

        //TList may be list_of_product_item_select or list of converible elements
        template <typename TList> void put_purchased_products(TList& lst) { list_of_product_item_selectSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "purchased_products"); }

        contract get_sales_contract();
        void put_sales_contract(contract inst);

        //TList may be list_of_calendar_date or list of converible elements
        template <typename TList> void get_delivery_dates(TList& lst) { list_of_calendar_dateSerializer<TList> sr; sr.FromAttr(lst, m_instance, "delivery_dates"); }

        //TList may be list_of_calendar_date or list of converible elements
        template <typename TList> void put_delivery_dates(TList& lst) { list_of_calendar_dateSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "delivery_dates"); }

        //TArrayElem[] may be calendar_date[] or array of convertible elements
        template <typename TArrayElem> void put_delivery_dates(TArrayElem arr[], size_t n) { list_of_calendar_date lst; ArrayToList(arr, n, lst); put_delivery_dates(lst); }

        //TList may be set_of_structural_frame_item_priced or list of converible elements
        template <typename TList> void get_prices(TList& lst) { set_of_structural_frame_item_pricedSerializer<TList> sr; sr.FromAttr(lst, m_instance, "prices"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of project
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class project : public virtual structural_frame_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of project
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        project(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "project")
        {}

                /// <summary>
                /// Create new instace of project and returns object of this C++ class to interact with
                /// </summary>
        static project Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "project"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of project_data_group
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class project_data_group : public virtual group_assignment
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of project_data_group
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        project_data_group(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "project_data_group")
        {}

                /// <summary>
                /// Create new instace of project_data_group and returns object of this C++ class to interact with
                /// </summary>
        static project_data_group Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "project_data_group"); assert(inst); return inst; }

        project get_parent_project();
        void put_parent_project(project inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of project_organization
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class project_organization : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of project_organization
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        project_organization(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "project_organization")
        {}

                /// <summary>
                /// Create new instace of project_organization and returns object of this C++ class to interact with
                /// </summary>
        static project_organization Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "project_organization"); assert(inst); return inst; }

        person_and_organization get_project_participant();
        void put_project_participant(person_and_organization inst);

        project get_related_project();
        void put_related_project(project inst);

        person_and_organization_role get_role();
        void put_role(person_and_organization_role inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of project_plan
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class project_plan : public virtual structural_frame_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of project_plan
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        project_plan(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "project_plan")
        {}

                /// <summary>
                /// Create new instace of project_plan and returns object of this C++ class to interact with
                /// </summary>
        static project_plan Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "project_plan"); assert(inst); return inst; }

        project_organization get_project_plan_author();
        void put_project_plan_author(project_organization inst);

        date_and_time get_project_plan_date();
        void put_project_plan_date(date_and_time inst);

        project get_related_project();
        void put_related_project(project inst);

        //TList may be set_of_project_plan_item or list of converible elements
        template <typename TList> void get_items(TList& lst) { set_of_project_plan_itemSerializer<TList> sr; sr.FromAttr(lst, m_instance, "items"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of project_plan_item
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class project_plan_item : public virtual structural_frame_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of project_plan_item
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        project_plan_item(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "project_plan_item")
        {}

                /// <summary>
                /// Create new instace of project_plan_item and returns object of this C++ class to interact with
                /// </summary>
        static project_plan_item Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "project_plan_item"); assert(inst); return inst; }

        project_plan get_item_for_plan();
        void put_item_for_plan(project_plan inst);

        date_and_time get_start_date();
        void put_start_date(date_and_time inst);

        date_and_time get_end_date();
        void put_end_date(date_and_time inst);

        time_measure_with_unit get_item_duration();
        void put_item_duration(time_measure_with_unit inst);

        //TList may be set_of_project_organization or list of converible elements
        template <typename TList> void get_actors(TList& lst) { set_of_project_organizationSerializer<TList> sr; sr.FromAttr(lst, m_instance, "actors"); }

        //TList may be set_of_project_organization or list of converible elements
        template <typename TList> void put_actors(TList& lst) { set_of_project_organizationSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "actors"); }

        //TArrayElem[] may be project_organization[] or array of convertible elements
        template <typename TArrayElem> void put_actors(TArrayElem arr[], size_t n) { set_of_project_organization lst; ArrayToList(arr, n, lst); put_actors(lst); }

        Nullable<IntValue> get_sequence_number() { IntValue val = (IntValue) 0; if (sdaiGetAttrBN(m_instance, "sequence_number", sdaiINTEGER, &val)) return val; else return Nullable<IntValue>(); }
        void put_sequence_number(IntValue value) { sdaiPutAttrBN(m_instance, "sequence_number", sdaiINTEGER, &value); }

        label get_item_status() { label val = NULL; if (sdaiGetAttrBN(m_instance, "item_status", sdaiSTRING, &val)) return val; else return NULL; }
        void put_item_status(label value) { sdaiPutAttrBN(m_instance, "item_status", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of project_plan_item_relationship
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class project_plan_item_relationship : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of project_plan_item_relationship
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        project_plan_item_relationship(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "project_plan_item_relationship")
        {}

                /// <summary>
                /// Create new instace of project_plan_item_relationship and returns object of this C++ class to interact with
                /// </summary>
        static project_plan_item_relationship Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "project_plan_item_relationship"); assert(inst); return inst; }

        label get_relationship_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "relationship_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_relationship_name(label value) { sdaiPutAttrBN(m_instance, "relationship_name", sdaiSTRING, value); }

        text get_relationship_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "relationship_description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_relationship_description(text value) { sdaiPutAttrBN(m_instance, "relationship_description", sdaiSTRING, value); }

        project_plan_item get_related_plan_item();
        void put_related_plan_item(project_plan_item inst);

        project_plan_item get_relating_plan_item();
        void put_relating_plan_item(project_plan_item inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of project_process_item
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class project_process_item : public virtual project_plan_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of project_process_item
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        project_process_item(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "project_process_item")
        {}

                /// <summary>
                /// Create new instace of project_process_item and returns object of this C++ class to interact with
                /// </summary>
        static project_process_item Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "project_process_item"); assert(inst); return inst; }

        structural_frame_process get_scheduled_process();
        void put_scheduled_process(structural_frame_process inst);

        //TList may be set_of_product_item_select or list of converible elements
        template <typename TList> void get_resulting_product(TList& lst) { set_of_product_item_selectSerializer<TList> sr; sr.FromAttr(lst, m_instance, "resulting_product"); }

        //TList may be set_of_product_item_select or list of converible elements
        template <typename TList> void put_resulting_product(TList& lst) { set_of_product_item_selectSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "resulting_product"); }

        //TList may be set_of_product_item_select or list of converible elements
        template <typename TList> void get_processed_products(TList& lst) { set_of_product_item_selectSerializer<TList> sr; sr.FromAttr(lst, m_instance, "processed_products"); }

        //TList may be set_of_product_item_select or list of converible elements
        template <typename TList> void put_processed_products(TList& lst) { set_of_product_item_selectSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "processed_products"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of pyramid_volume
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class pyramid_volume : public virtual volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of pyramid_volume
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        pyramid_volume(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "pyramid_volume")
        {}

                /// <summary>
                /// Create new instace of pyramid_volume and returns object of this C++ class to interact with
                /// </summary>
        static pyramid_volume Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "pyramid_volume"); assert(inst); return inst; }

        axis2_placement_3d get_position();
        void put_position(axis2_placement_3d inst);

        Nullable<positive_length_measure> get_xlength() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "xlength", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_xlength(positive_length_measure value) { sdaiPutAttrBN(m_instance, "xlength", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_ylength() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "ylength", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_ylength(positive_length_measure value) { sdaiPutAttrBN(m_instance, "ylength", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_height() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "height", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_height(positive_length_measure value) { sdaiPutAttrBN(m_instance, "height", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of uncertainty_qualifier
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class uncertainty_qualifier : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of uncertainty_qualifier
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        uncertainty_qualifier(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "uncertainty_qualifier")
        {}

                /// <summary>
                /// Create new instace of uncertainty_qualifier and returns object of this C++ class to interact with
                /// </summary>
        static uncertainty_qualifier Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "uncertainty_qualifier"); assert(inst); return inst; }

        label get_measure_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "measure_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_measure_name(label value) { sdaiPutAttrBN(m_instance, "measure_name", sdaiSTRING, value); }

        text get_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_description(text value) { sdaiPutAttrBN(m_instance, "description", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of qualitative_uncertainty
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class qualitative_uncertainty : public virtual uncertainty_qualifier
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of qualitative_uncertainty
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        qualitative_uncertainty(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "qualitative_uncertainty")
        {}

                /// <summary>
                /// Create new instace of qualitative_uncertainty and returns object of this C++ class to interact with
                /// </summary>
        static qualitative_uncertainty Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "qualitative_uncertainty"); assert(inst); return inst; }

        text get_uncertainty_value() { text val = NULL; if (sdaiGetAttrBN(m_instance, "uncertainty_value", sdaiSTRING, &val)) return val; else return NULL; }
        void put_uncertainty_value(text value) { sdaiPutAttrBN(m_instance, "uncertainty_value", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of quasi_uniform_curve
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class quasi_uniform_curve : public virtual b_spline_curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of quasi_uniform_curve
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        quasi_uniform_curve(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "quasi_uniform_curve")
        {}

                /// <summary>
                /// Create new instace of quasi_uniform_curve and returns object of this C++ class to interact with
                /// </summary>
        static quasi_uniform_curve Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "quasi_uniform_curve"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of quasi_uniform_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class quasi_uniform_surface : public virtual b_spline_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of quasi_uniform_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        quasi_uniform_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "quasi_uniform_surface")
        {}

                /// <summary>
                /// Create new instace of quasi_uniform_surface and returns object of this C++ class to interact with
                /// </summary>
        static quasi_uniform_surface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "quasi_uniform_surface"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of quasi_uniform_volume
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class quasi_uniform_volume : public virtual b_spline_volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of quasi_uniform_volume
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        quasi_uniform_volume(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "quasi_uniform_volume")
        {}

                /// <summary>
                /// Create new instace of quasi_uniform_volume and returns object of this C++ class to interact with
                /// </summary>
        static quasi_uniform_volume Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "quasi_uniform_volume"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of ratio_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class ratio_measure_with_unit : public virtual measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of ratio_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        ratio_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "ratio_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of ratio_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static ratio_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "ratio_measure_with_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of ratio_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class ratio_unit : public virtual named_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of ratio_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        ratio_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "ratio_unit")
        {}

                /// <summary>
                /// Create new instace of ratio_unit and returns object of this C++ class to interact with
                /// </summary>
        static ratio_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "ratio_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of rational_b_spline_curve
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class rational_b_spline_curve : public virtual b_spline_curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of rational_b_spline_curve
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        rational_b_spline_curve(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "rational_b_spline_curve")
        {}

                /// <summary>
                /// Create new instace of rational_b_spline_curve and returns object of this C++ class to interact with
                /// </summary>
        static rational_b_spline_curve Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "rational_b_spline_curve"); assert(inst); return inst; }

        //TList may be list_of_double or list of converible elements
        template <typename TList> void get_weights_data(TList& lst) { list_of_doubleSerializer<TList> sr; sr.FromAttr(lst, m_instance, "weights_data"); }

        //TList may be list_of_double or list of converible elements
        template <typename TList> void put_weights_data(TList& lst) { list_of_doubleSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "weights_data"); }

        //TArrayElem[] may be double[] or array of convertible elements
        template <typename TArrayElem> void put_weights_data(TArrayElem arr[], size_t n) { list_of_double lst; ArrayToList(arr, n, lst); put_weights_data(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of rational_b_spline_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class rational_b_spline_surface : public virtual b_spline_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of rational_b_spline_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        rational_b_spline_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "rational_b_spline_surface")
        {}

                /// <summary>
                /// Create new instace of rational_b_spline_surface and returns object of this C++ class to interact with
                /// </summary>
        static rational_b_spline_surface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "rational_b_spline_surface"); assert(inst); return inst; }

        //TList may be list_of_list_of_double or list of converible elements
        template <typename TList> void get_weights_data(TList& lst) { list_of_list_of_doubleSerializer<TList> sr; sr.FromAttr(lst, m_instance, "weights_data"); }

        //TList may be list_of_list_of_double or list of converible elements
        template <typename TList> void put_weights_data(TList& lst) { list_of_list_of_doubleSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "weights_data"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of rational_b_spline_volume
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class rational_b_spline_volume : public virtual b_spline_volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of rational_b_spline_volume
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        rational_b_spline_volume(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "rational_b_spline_volume")
        {}

                /// <summary>
                /// Create new instace of rational_b_spline_volume and returns object of this C++ class to interact with
                /// </summary>
        static rational_b_spline_volume Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "rational_b_spline_volume"); assert(inst); return inst; }

        //TList may be list_of_list_of_list_of_double or list of converible elements
        template <typename TList> void get_weights_data(TList& lst) { list_of_list_of_list_of_doubleSerializer<TList> sr; sr.FromAttr(lst, m_instance, "weights_data"); }

        //TList may be list_of_list_of_list_of_double or list of converible elements
        template <typename TList> void put_weights_data(TList& lst) { list_of_list_of_list_of_doubleSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "weights_data"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of reaction
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class reaction : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of reaction
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        reaction(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "reaction")
        {}

    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of reaction_acceleration
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class reaction_acceleration : public virtual reaction
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of reaction_acceleration
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        reaction_acceleration(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "reaction_acceleration")
        {}

                /// <summary>
                /// Create new instace of reaction_acceleration and returns object of this C++ class to interact with
                /// </summary>
        static reaction_acceleration Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "reaction_acceleration"); assert(inst); return inst; }

        linear_acceleration_measure_with_unit get_reaction_acceleration_ax();
        void put_reaction_acceleration_ax(linear_acceleration_measure_with_unit inst);

        linear_acceleration_measure_with_unit get_reaction_acceleration_ay();
        void put_reaction_acceleration_ay(linear_acceleration_measure_with_unit inst);

        linear_acceleration_measure_with_unit get_reaction_acceleration_az();
        void put_reaction_acceleration_az(linear_acceleration_measure_with_unit inst);

        rotational_acceleration_measure_with_unit get_reaction_acceleration_arx();
        void put_reaction_acceleration_arx(rotational_acceleration_measure_with_unit inst);

        rotational_acceleration_measure_with_unit get_reaction_acceleration_ary();
        void put_reaction_acceleration_ary(rotational_acceleration_measure_with_unit inst);

        rotational_acceleration_measure_with_unit get_reaction_acceleration_arz();
        void put_reaction_acceleration_arz(rotational_acceleration_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of reaction_displacement
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class reaction_displacement : public virtual reaction
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of reaction_displacement
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        reaction_displacement(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "reaction_displacement")
        {}

                /// <summary>
                /// Create new instace of reaction_displacement and returns object of this C++ class to interact with
                /// </summary>
        static reaction_displacement Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "reaction_displacement"); assert(inst); return inst; }

        length_measure_with_unit get_reaction_displacement_dx();
        void put_reaction_displacement_dx(length_measure_with_unit inst);

        length_measure_with_unit get_reaction_displacement_dy();
        void put_reaction_displacement_dy(length_measure_with_unit inst);

        length_measure_with_unit get_reaction_displacement_dz();
        void put_reaction_displacement_dz(length_measure_with_unit inst);

        plane_angle_measure_with_unit get_reaction_displacement_rx();
        void put_reaction_displacement_rx(plane_angle_measure_with_unit inst);

        plane_angle_measure_with_unit get_reaction_displacement_ry();
        void put_reaction_displacement_ry(plane_angle_measure_with_unit inst);

        plane_angle_measure_with_unit get_reaction_displacement_rz();
        void put_reaction_displacement_rz(plane_angle_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of reaction_dynamic
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class reaction_dynamic : public virtual reaction
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of reaction_dynamic
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        reaction_dynamic(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "reaction_dynamic")
        {}

                /// <summary>
                /// Create new instace of reaction_dynamic and returns object of this C++ class to interact with
                /// </summary>
        static reaction_dynamic Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "reaction_dynamic"); assert(inst); return inst; }

        plane_angle_measure_with_unit get_phase_angle();
        void put_phase_angle(plane_angle_measure_with_unit inst);

        length_measure_with_unit get_response_amplitude();
        void put_response_amplitude(length_measure_with_unit inst);

        frequency_measure_with_unit get_natural_frequency();
        void put_natural_frequency(frequency_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of reaction_equilibrium
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class reaction_equilibrium : public virtual reaction
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of reaction_equilibrium
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        reaction_equilibrium(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "reaction_equilibrium")
        {}

                /// <summary>
                /// Create new instace of reaction_equilibrium and returns object of this C++ class to interact with
                /// </summary>
        static reaction_equilibrium Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "reaction_equilibrium"); assert(inst); return inst; }

        ratio_measure_with_unit get_equilibrium_dx();
        void put_equilibrium_dx(ratio_measure_with_unit inst);

        ratio_measure_with_unit get_equilibrium_dy();
        void put_equilibrium_dy(ratio_measure_with_unit inst);

        ratio_measure_with_unit get_equilibrium_dz();
        void put_equilibrium_dz(ratio_measure_with_unit inst);

        ratio_measure_with_unit get_equilibrium_mx();
        void put_equilibrium_mx(ratio_measure_with_unit inst);

        ratio_measure_with_unit get_equilibrium_my();
        void put_equilibrium_my(ratio_measure_with_unit inst);

        ratio_measure_with_unit get_equilibrium_mz();
        void put_equilibrium_mz(ratio_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of reaction_force
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class reaction_force : public virtual reaction
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of reaction_force
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        reaction_force(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "reaction_force")
        {}

                /// <summary>
                /// Create new instace of reaction_force and returns object of this C++ class to interact with
                /// </summary>
        static reaction_force Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "reaction_force"); assert(inst); return inst; }

        force_measure_with_unit get_reaction_force_fx();
        void put_reaction_force_fx(force_measure_with_unit inst);

        force_measure_with_unit get_reaction_force_fy();
        void put_reaction_force_fy(force_measure_with_unit inst);

        force_measure_with_unit get_reaction_force_fz();
        void put_reaction_force_fz(force_measure_with_unit inst);

        moment_measure_with_unit get_reaction_force_mx();
        void put_reaction_force_mx(moment_measure_with_unit inst);

        moment_measure_with_unit get_reaction_force_my();
        void put_reaction_force_my(moment_measure_with_unit inst);

        moment_measure_with_unit get_reaction_force_mz();
        void put_reaction_force_mz(moment_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of reaction_velocity
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class reaction_velocity : public virtual reaction
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of reaction_velocity
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        reaction_velocity(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "reaction_velocity")
        {}

                /// <summary>
                /// Create new instace of reaction_velocity and returns object of this C++ class to interact with
                /// </summary>
        static reaction_velocity Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "reaction_velocity"); assert(inst); return inst; }

        linear_velocity_measure_with_unit get_reaction_velocity_vx();
        void put_reaction_velocity_vx(linear_velocity_measure_with_unit inst);

        linear_velocity_measure_with_unit get_reaction_velocity_vy();
        void put_reaction_velocity_vy(linear_velocity_measure_with_unit inst);

        linear_velocity_measure_with_unit get_reaction_velocity_vz();
        void put_reaction_velocity_vz(linear_velocity_measure_with_unit inst);

        rotational_velocity_measure_with_unit get_reaction_velocity_vrx();
        void put_reaction_velocity_vrx(rotational_velocity_measure_with_unit inst);

        rotational_velocity_measure_with_unit get_reaction_velocity_vry();
        void put_reaction_velocity_vry(rotational_velocity_measure_with_unit inst);

        rotational_velocity_measure_with_unit get_reaction_velocity_vrz();
        void put_reaction_velocity_vrz(rotational_velocity_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of rectangular_area
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class rectangular_area : public virtual primitive_2d
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of rectangular_area
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        rectangular_area(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "rectangular_area")
        {}

                /// <summary>
                /// Create new instace of rectangular_area and returns object of this C++ class to interact with
                /// </summary>
        static rectangular_area Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "rectangular_area"); assert(inst); return inst; }

        axis2_placement_2d get_position();
        void put_position(axis2_placement_2d inst);

        Nullable<positive_length_measure> get_x() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "x", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_x(positive_length_measure value) { sdaiPutAttrBN(m_instance, "x", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_y() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "y", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_y(positive_length_measure value) { sdaiPutAttrBN(m_instance, "y", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of rectangular_composite_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class rectangular_composite_surface : public virtual bounded_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of rectangular_composite_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        rectangular_composite_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "rectangular_composite_surface")
        {}

                /// <summary>
                /// Create new instace of rectangular_composite_surface and returns object of this C++ class to interact with
                /// </summary>
        static rectangular_composite_surface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "rectangular_composite_surface"); assert(inst); return inst; }

        //TList may be list_of_list_of_surface_patch or list of converible elements
        template <typename TList> void get_segments(TList& lst) { list_of_list_of_surface_patchSerializer<TList> sr; sr.FromAttr(lst, m_instance, "segments"); }

        //TList may be list_of_list_of_surface_patch or list of converible elements
        template <typename TList> void put_segments(TList& lst) { list_of_list_of_surface_patchSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "segments"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of rectangular_pyramid
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class rectangular_pyramid : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of rectangular_pyramid
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        rectangular_pyramid(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "rectangular_pyramid")
        {}

                /// <summary>
                /// Create new instace of rectangular_pyramid and returns object of this C++ class to interact with
                /// </summary>
        static rectangular_pyramid Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "rectangular_pyramid"); assert(inst); return inst; }

        axis2_placement_3d get_position();
        void put_position(axis2_placement_3d inst);

        Nullable<positive_length_measure> get_xlength() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "xlength", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_xlength(positive_length_measure value) { sdaiPutAttrBN(m_instance, "xlength", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_ylength() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "ylength", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_ylength(positive_length_measure value) { sdaiPutAttrBN(m_instance, "ylength", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_height() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "height", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_height(positive_length_measure value) { sdaiPutAttrBN(m_instance, "height", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of rectangular_trimmed_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class rectangular_trimmed_surface : public virtual bounded_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of rectangular_trimmed_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        rectangular_trimmed_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "rectangular_trimmed_surface")
        {}

                /// <summary>
                /// Create new instace of rectangular_trimmed_surface and returns object of this C++ class to interact with
                /// </summary>
        static rectangular_trimmed_surface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "rectangular_trimmed_surface"); assert(inst); return inst; }

        surface get_basis_surface();
        void put_basis_surface(surface inst);

        Nullable<parameter_value> get_u1() { parameter_value val = (parameter_value) 0; if (sdaiGetAttrBN(m_instance, "u1", sdaiREAL, &val)) return val; else return Nullable<parameter_value>(); }
        void put_u1(parameter_value value) { sdaiPutAttrBN(m_instance, "u1", sdaiREAL, &value); }

        Nullable<parameter_value> get_u2() { parameter_value val = (parameter_value) 0; if (sdaiGetAttrBN(m_instance, "u2", sdaiREAL, &val)) return val; else return Nullable<parameter_value>(); }
        void put_u2(parameter_value value) { sdaiPutAttrBN(m_instance, "u2", sdaiREAL, &value); }

        Nullable<parameter_value> get_v1() { parameter_value val = (parameter_value) 0; if (sdaiGetAttrBN(m_instance, "v1", sdaiREAL, &val)) return val; else return Nullable<parameter_value>(); }
        void put_v1(parameter_value value) { sdaiPutAttrBN(m_instance, "v1", sdaiREAL, &value); }

        Nullable<parameter_value> get_v2() { parameter_value val = (parameter_value) 0; if (sdaiGetAttrBN(m_instance, "v2", sdaiREAL, &val)) return val; else return Nullable<parameter_value>(); }
        void put_v2(parameter_value value) { sdaiPutAttrBN(m_instance, "v2", sdaiREAL, &value); }

        Nullable<bool> get_usense() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "usense", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_usense(bool value) { sdaiPutAttrBN(m_instance, "usense", sdaiBOOLEAN, &value); }

        Nullable<bool> get_vsense() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "vsense", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_vsense(bool value) { sdaiPutAttrBN(m_instance, "vsense", sdaiBOOLEAN, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of release
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class release : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of release
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        release(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "release")
        {}


        label get_release_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "release_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_release_name(label value) { sdaiPutAttrBN(m_instance, "release_name", sdaiSTRING, value); }

        text get_release_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "release_description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_release_description(text value) { sdaiPutAttrBN(m_instance, "release_description", sdaiSTRING, value); }

        //TList may be set_of_element_node_connectivity or list of converible elements
        template <typename TList> void get_release_for_element_nodes(TList& lst) { set_of_element_node_connectivitySerializer<TList> sr; sr.FromAttr(lst, m_instance, "release_for_element_nodes"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of release_logical
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class release_logical : public virtual release
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of release_logical
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        release_logical(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "release_logical")
        {}

                /// <summary>
                /// Create new instace of release_logical and returns object of this C++ class to interact with
                /// </summary>
        static release_logical Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "release_logical"); assert(inst); return inst; }

        Nullable<LOGICAL_VALUE> get_release_axial_force() { int v = getENUM("release_axial_force", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_release_axial_force(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "release_axial_force", sdaiENUM, val); }

        Nullable<LOGICAL_VALUE> get_release_y_force() { int v = getENUM("release_y_force", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_release_y_force(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "release_y_force", sdaiENUM, val); }

        Nullable<LOGICAL_VALUE> get_release_z_force() { int v = getENUM("release_z_force", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_release_z_force(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "release_z_force", sdaiENUM, val); }

        Nullable<LOGICAL_VALUE> get_release_torsional_moment() { int v = getENUM("release_torsional_moment", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_release_torsional_moment(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "release_torsional_moment", sdaiENUM, val); }

        Nullable<LOGICAL_VALUE> get_release_y_bending_moment() { int v = getENUM("release_y_bending_moment", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_release_y_bending_moment(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "release_y_bending_moment", sdaiENUM, val); }

        Nullable<LOGICAL_VALUE> get_release_z_bending_moment() { int v = getENUM("release_z_bending_moment", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_release_z_bending_moment(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "release_z_bending_moment", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of release_spring_linear
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class release_spring_linear : public virtual release
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of release_spring_linear
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        release_spring_linear(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "release_spring_linear")
        {}

                /// <summary>
                /// Create new instace of release_spring_linear and returns object of this C++ class to interact with
                /// </summary>
        static release_spring_linear Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "release_spring_linear"); assert(inst); return inst; }

        linear_stiffness_measure_with_unit get_release_axial_force();
        void put_release_axial_force(linear_stiffness_measure_with_unit inst);

        linear_stiffness_measure_with_unit get_release_y_force();
        void put_release_y_force(linear_stiffness_measure_with_unit inst);

        linear_stiffness_measure_with_unit get_release_z_force();
        void put_release_z_force(linear_stiffness_measure_with_unit inst);

        rotational_stiffness_measure_with_unit get_release_torsional_moment();
        void put_release_torsional_moment(rotational_stiffness_measure_with_unit inst);

        rotational_stiffness_measure_with_unit get_release_y_bending_moment();
        void put_release_y_bending_moment(rotational_stiffness_measure_with_unit inst);

        rotational_stiffness_measure_with_unit get_release_z_bending_moment();
        void put_release_z_bending_moment(rotational_stiffness_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of release_spring_non_linear
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class release_spring_non_linear : public virtual release
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of release_spring_non_linear
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        release_spring_non_linear(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "release_spring_non_linear")
        {}

                /// <summary>
                /// Create new instace of release_spring_non_linear and returns object of this C++ class to interact with
                /// </summary>
        static release_spring_non_linear Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "release_spring_non_linear"); assert(inst); return inst; }

        //TList may be list_of_measure_with_unit or list of converible elements
        template <typename TList> void get_change_values(TList& lst) { list_of_measure_with_unitSerializer<TList> sr; sr.FromAttr(lst, m_instance, "change_values"); }

        //TList may be list_of_measure_with_unit or list of converible elements
        template <typename TList> void put_change_values(TList& lst) { list_of_measure_with_unitSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "change_values"); }

        //TArrayElem[] may be measure_with_unit[] or array of convertible elements
        template <typename TArrayElem> void put_change_values(TArrayElem arr[], size_t n) { list_of_measure_with_unit lst; ArrayToList(arr, n, lst); put_change_values(lst); }

        //TList may be list_of_release_spring_linear or list of converible elements
        template <typename TList> void get_values(TList& lst) { list_of_release_spring_linearSerializer<TList> sr; sr.FromAttr(lst, m_instance, "values"); }

        //TList may be list_of_release_spring_linear or list of converible elements
        template <typename TList> void put_values(TList& lst) { list_of_release_spring_linearSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "values"); }

        //TArrayElem[] may be release_spring_linear[] or array of convertible elements
        template <typename TArrayElem> void put_values(TArrayElem arr[], size_t n) { list_of_release_spring_linear lst; ArrayToList(arr, n, lst); put_values(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of release_warping
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class release_warping : public virtual release_spring_linear
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of release_warping
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        release_warping(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "release_warping")
        {}

                /// <summary>
                /// Create new instace of release_warping and returns object of this C++ class to interact with
                /// </summary>
        static release_warping Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "release_warping"); assert(inst); return inst; }

        rotational_stiffness_measure_with_unit get_release_warping_moment();
        void put_release_warping_moment(rotational_stiffness_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of reparametrised_composite_curve_segment
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class reparametrised_composite_curve_segment : public virtual composite_curve_segment
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of reparametrised_composite_curve_segment
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        reparametrised_composite_curve_segment(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "reparametrised_composite_curve_segment")
        {}

                /// <summary>
                /// Create new instace of reparametrised_composite_curve_segment and returns object of this C++ class to interact with
                /// </summary>
        static reparametrised_composite_curve_segment Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "reparametrised_composite_curve_segment"); assert(inst); return inst; }

        Nullable<parameter_value> get_param_length() { parameter_value val = (parameter_value) 0; if (sdaiGetAttrBN(m_instance, "param_length", sdaiREAL, &val)) return val; else return Nullable<parameter_value>(); }
        void put_param_length(parameter_value value) { sdaiPutAttrBN(m_instance, "param_length", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of representation_map
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class representation_map : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of representation_map
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        representation_map(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "representation_map")
        {}

                /// <summary>
                /// Create new instace of representation_map and returns object of this C++ class to interact with
                /// </summary>
        static representation_map Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "representation_map"); assert(inst); return inst; }

        representation_item get_mapping_origin();
        void put_mapping_origin(representation_item inst);

        representation get_mapped_representation();
        void put_mapped_representation(representation inst);

        //TList may be set_of_mapped_item or list of converible elements
        template <typename TList> void get_map_usage(TList& lst) { set_of_mapped_itemSerializer<TList> sr; sr.FromAttr(lst, m_instance, "map_usage"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of representation_relationship
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class representation_relationship : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of representation_relationship
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        representation_relationship(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "representation_relationship")
        {}

                /// <summary>
                /// Create new instace of representation_relationship and returns object of this C++ class to interact with
                /// </summary>
        static representation_relationship Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "representation_relationship"); assert(inst); return inst; }

        label get_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_name(label value) { sdaiPutAttrBN(m_instance, "name", sdaiSTRING, value); }

        text get_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_description(text value) { sdaiPutAttrBN(m_instance, "description", sdaiSTRING, value); }

        representation get_rep_1();
        void put_rep_1(representation inst);

        representation get_rep_2();
        void put_rep_2(representation inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of representation_relationship_with_transformation
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class representation_relationship_with_transformation : public virtual representation_relationship
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of representation_relationship_with_transformation
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        representation_relationship_with_transformation(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "representation_relationship_with_transformation")
        {}

                /// <summary>
                /// Create new instace of representation_relationship_with_transformation and returns object of this C++ class to interact with
                /// </summary>
        static representation_relationship_with_transformation Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "representation_relationship_with_transformation"); assert(inst); return inst; }

        transformation_get get_transformation_operator() { return transformation_get(m_instance, "transformation_operator", NULL); }
        transformation_put put_transformation_operator() { return transformation_put(m_instance, "transformation_operator", NULL); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of resistance
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class resistance : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of resistance
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        resistance(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "resistance")
        {}


        label get_resistance_type() { label val = NULL; if (sdaiGetAttrBN(m_instance, "resistance_type", sdaiSTRING, &val)) return val; else return NULL; }
        void put_resistance_type(label value) { sdaiPutAttrBN(m_instance, "resistance_type", sdaiSTRING, value); }

        text get_resistance_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "resistance_description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_resistance_description(text value) { sdaiPutAttrBN(m_instance, "resistance_description", sdaiSTRING, value); }

        Nullable<double> get_resistance_factor() { double val = (double) 0; if (sdaiGetAttrBN(m_instance, "resistance_factor", sdaiREAL, &val)) return val; else return Nullable<double>(); }
        void put_resistance_factor(double value) { sdaiPutAttrBN(m_instance, "resistance_factor", sdaiREAL, &value); }

        Nullable<elastic_or_plastic_resistance> get_elastic_or_plastic() { int v = getENUM("elastic_or_plastic", elastic_or_plastic_resistance_); if (v >= 0) return (elastic_or_plastic_resistance) v; else return Nullable<elastic_or_plastic_resistance>(); }
        void put_elastic_or_plastic(elastic_or_plastic_resistance value) { TextValue val = elastic_or_plastic_resistance_[(int) value]; sdaiPutAttrBN(m_instance, "elastic_or_plastic", sdaiENUM, val); }

        Nullable<global_or_local_resistance> get_local_or_global() { int v = getENUM("local_or_global", global_or_local_resistance_); if (v >= 0) return (global_or_local_resistance) v; else return Nullable<global_or_local_resistance>(); }
        void put_local_or_global(global_or_local_resistance value) { TextValue val = global_or_local_resistance_[(int) value]; sdaiPutAttrBN(m_instance, "local_or_global", sdaiENUM, val); }

        //TList may be set_of_design_result or list of converible elements
        template <typename TList> void get_results(TList& lst) { set_of_design_resultSerializer<TList> sr; sr.FromAttr(lst, m_instance, "results"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of resistance_axial
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class resistance_axial : public virtual resistance
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of resistance_axial
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        resistance_axial(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "resistance_axial")
        {}

                /// <summary>
                /// Create new instace of resistance_axial and returns object of this C++ class to interact with
                /// </summary>
        static resistance_axial Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "resistance_axial"); assert(inst); return inst; }

        force_measure_with_unit get_tensile_resistance_ptx();
        void put_tensile_resistance_ptx(force_measure_with_unit inst);

        force_measure_with_unit get_compressive_resistance_pcx();
        void put_compressive_resistance_pcx(force_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of resistance_bending
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class resistance_bending : public virtual resistance
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of resistance_bending
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        resistance_bending(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "resistance_bending")
        {}

                /// <summary>
                /// Create new instace of resistance_bending and returns object of this C++ class to interact with
                /// </summary>
        static resistance_bending Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "resistance_bending"); assert(inst); return inst; }

        moment_measure_with_unit get_torsional_resistance_mx();
        void put_torsional_resistance_mx(moment_measure_with_unit inst);

        moment_measure_with_unit get_bending_resistance_my();
        void put_bending_resistance_my(moment_measure_with_unit inst);

        moment_measure_with_unit get_bending_resistance_mz();
        void put_bending_resistance_mz(moment_measure_with_unit inst);

        moment_measure_with_unit get_buckling_resistance_mb();
        void put_buckling_resistance_mb(moment_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of resistance_shear
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class resistance_shear : public virtual resistance
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of resistance_shear
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        resistance_shear(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "resistance_shear")
        {}

                /// <summary>
                /// Create new instace of resistance_shear and returns object of this C++ class to interact with
                /// </summary>
        static resistance_shear Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "resistance_shear"); assert(inst); return inst; }

        force_measure_with_unit get_normal_shear_resistance_pv();
        void put_normal_shear_resistance_pv(force_measure_with_unit inst);

        force_measure_with_unit get_buckling_shear_resistance_pbv();
        void put_buckling_shear_resistance_pbv(force_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of restraint
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class restraint : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of restraint
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        restraint(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "restraint")
        {}


        label get_restraint_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "restraint_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_restraint_name(label value) { sdaiPutAttrBN(m_instance, "restraint_name", sdaiSTRING, value); }

        text get_restraint_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "restraint_description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_restraint_description(text value) { sdaiPutAttrBN(m_instance, "restraint_description", sdaiSTRING, value); }

        point get_restraint_location();
        void put_restraint_location(point inst);

        assembly_design_structural_member get_restrained_mbr();
        void put_restrained_mbr(assembly_design_structural_member inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of restraint_logical
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class restraint_logical : public virtual restraint
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of restraint_logical
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        restraint_logical(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "restraint_logical")
        {}

                /// <summary>
                /// Create new instace of restraint_logical and returns object of this C++ class to interact with
                /// </summary>
        static restraint_logical Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "restraint_logical"); assert(inst); return inst; }

        Nullable<LOGICAL_VALUE> get_restraint_x_displacement() { int v = getENUM("restraint_x_displacement", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_restraint_x_displacement(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "restraint_x_displacement", sdaiENUM, val); }

        Nullable<LOGICAL_VALUE> get_restraint_y_displacement() { int v = getENUM("restraint_y_displacement", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_restraint_y_displacement(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "restraint_y_displacement", sdaiENUM, val); }

        Nullable<LOGICAL_VALUE> get_restraint_z_displacement() { int v = getENUM("restraint_z_displacement", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_restraint_z_displacement(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "restraint_z_displacement", sdaiENUM, val); }

        Nullable<LOGICAL_VALUE> get_restraint_x_rotation() { int v = getENUM("restraint_x_rotation", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_restraint_x_rotation(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "restraint_x_rotation", sdaiENUM, val); }

        Nullable<LOGICAL_VALUE> get_restraint_y_rotation() { int v = getENUM("restraint_y_rotation", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_restraint_y_rotation(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "restraint_y_rotation", sdaiENUM, val); }

        Nullable<LOGICAL_VALUE> get_restraint_z_rotation() { int v = getENUM("restraint_z_rotation", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_restraint_z_rotation(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "restraint_z_rotation", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of restraint_spring
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class restraint_spring : public virtual restraint
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of restraint_spring
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        restraint_spring(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "restraint_spring")
        {}

                /// <summary>
                /// Create new instace of restraint_spring and returns object of this C++ class to interact with
                /// </summary>
        static restraint_spring Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "restraint_spring"); assert(inst); return inst; }

        linear_stiffness_measure_with_unit get_restraint_x_displacement();
        void put_restraint_x_displacement(linear_stiffness_measure_with_unit inst);

        linear_stiffness_measure_with_unit get_restraint_y_displacement();
        void put_restraint_y_displacement(linear_stiffness_measure_with_unit inst);

        linear_stiffness_measure_with_unit get_restraint_z_displacement();
        void put_restraint_z_displacement(linear_stiffness_measure_with_unit inst);

        rotational_stiffness_measure_with_unit get_restraint_x_rotation();
        void put_restraint_x_rotation(rotational_stiffness_measure_with_unit inst);

        rotational_stiffness_measure_with_unit get_restraint_y_rotation();
        void put_restraint_y_rotation(rotational_stiffness_measure_with_unit inst);

        rotational_stiffness_measure_with_unit get_restraint_z_rotation();
        void put_restraint_z_rotation(rotational_stiffness_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of restraint_warping
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class restraint_warping : public virtual restraint_spring
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of restraint_warping
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        restraint_warping(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "restraint_warping")
        {}

                /// <summary>
                /// Create new instace of restraint_warping and returns object of this C++ class to interact with
                /// </summary>
        static restraint_warping Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "restraint_warping"); assert(inst); return inst; }

        rotational_stiffness_measure_with_unit get_restraint_w_rotation();
        void put_restraint_w_rotation(rotational_stiffness_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of revolved_area_solid
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class revolved_area_solid : public virtual swept_area_solid
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of revolved_area_solid
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        revolved_area_solid(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "revolved_area_solid")
        {}

                /// <summary>
                /// Create new instace of revolved_area_solid and returns object of this C++ class to interact with
                /// </summary>
        static revolved_area_solid Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "revolved_area_solid"); assert(inst); return inst; }

        axis1_placement get_axis();
        void put_axis(axis1_placement inst);

        Nullable<plane_angle_measure> get_angle() { plane_angle_measure val = (plane_angle_measure) 0; if (sdaiGetAttrBN(m_instance, "angle", sdaiREAL, &val)) return val; else return Nullable<plane_angle_measure>(); }
        void put_angle(plane_angle_measure value) { sdaiPutAttrBN(m_instance, "angle", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of revolved_face_solid
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class revolved_face_solid : public virtual swept_face_solid
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of revolved_face_solid
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        revolved_face_solid(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "revolved_face_solid")
        {}

                /// <summary>
                /// Create new instace of revolved_face_solid and returns object of this C++ class to interact with
                /// </summary>
        static revolved_face_solid Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "revolved_face_solid"); assert(inst); return inst; }

        axis1_placement get_axis();
        void put_axis(axis1_placement inst);

        Nullable<plane_angle_measure> get_angle() { plane_angle_measure val = (plane_angle_measure) 0; if (sdaiGetAttrBN(m_instance, "angle", sdaiREAL, &val)) return val; else return Nullable<plane_angle_measure>(); }
        void put_angle(plane_angle_measure value) { sdaiPutAttrBN(m_instance, "angle", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of right_angular_wedge
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class right_angular_wedge : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of right_angular_wedge
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        right_angular_wedge(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "right_angular_wedge")
        {}

                /// <summary>
                /// Create new instace of right_angular_wedge and returns object of this C++ class to interact with
                /// </summary>
        static right_angular_wedge Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "right_angular_wedge"); assert(inst); return inst; }

        axis2_placement_3d get_position();
        void put_position(axis2_placement_3d inst);

        Nullable<positive_length_measure> get_x() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "x", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_x(positive_length_measure value) { sdaiPutAttrBN(m_instance, "x", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_y() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "y", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_y(positive_length_measure value) { sdaiPutAttrBN(m_instance, "y", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_z() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "z", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_z(positive_length_measure value) { sdaiPutAttrBN(m_instance, "z", sdaiREAL, &value); }

        Nullable<length_measure> get_ltx() { length_measure val = (length_measure) 0; if (sdaiGetAttrBN(m_instance, "ltx", sdaiREAL, &val)) return val; else return Nullable<length_measure>(); }
        void put_ltx(length_measure value) { sdaiPutAttrBN(m_instance, "ltx", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of right_circular_cone
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class right_circular_cone : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of right_circular_cone
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        right_circular_cone(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "right_circular_cone")
        {}

                /// <summary>
                /// Create new instace of right_circular_cone and returns object of this C++ class to interact with
                /// </summary>
        static right_circular_cone Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "right_circular_cone"); assert(inst); return inst; }

        axis1_placement get_position();
        void put_position(axis1_placement inst);

        Nullable<positive_length_measure> get_height() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "height", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_height(positive_length_measure value) { sdaiPutAttrBN(m_instance, "height", sdaiREAL, &value); }

        Nullable<length_measure> get_radius() { length_measure val = (length_measure) 0; if (sdaiGetAttrBN(m_instance, "radius", sdaiREAL, &val)) return val; else return Nullable<length_measure>(); }
        void put_radius(length_measure value) { sdaiPutAttrBN(m_instance, "radius", sdaiREAL, &value); }

        Nullable<plane_angle_measure> get_semi_angle() { plane_angle_measure val = (plane_angle_measure) 0; if (sdaiGetAttrBN(m_instance, "semi_angle", sdaiREAL, &val)) return val; else return Nullable<plane_angle_measure>(); }
        void put_semi_angle(plane_angle_measure value) { sdaiPutAttrBN(m_instance, "semi_angle", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of right_circular_cylinder
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class right_circular_cylinder : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of right_circular_cylinder
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        right_circular_cylinder(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "right_circular_cylinder")
        {}

                /// <summary>
                /// Create new instace of right_circular_cylinder and returns object of this C++ class to interact with
                /// </summary>
        static right_circular_cylinder Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "right_circular_cylinder"); assert(inst); return inst; }

        axis1_placement get_position();
        void put_position(axis1_placement inst);

        Nullable<positive_length_measure> get_height() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "height", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_height(positive_length_measure value) { sdaiPutAttrBN(m_instance, "height", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_radius() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "radius", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_radius(positive_length_measure value) { sdaiPutAttrBN(m_instance, "radius", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of role_association
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class role_association : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of role_association
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        role_association(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "role_association")
        {}

                /// <summary>
                /// Create new instace of role_association and returns object of this C++ class to interact with
                /// </summary>
        static role_association Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "role_association"); assert(inst); return inst; }

        object_role get_role();
        void put_role(object_role inst);

        role_select_get get_item_with_role() { return role_select_get(m_instance, "item_with_role", NULL); }
        role_select_put put_item_with_role() { return role_select_put(m_instance, "item_with_role", NULL); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of rotational_acceleration_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class rotational_acceleration_measure_with_unit : public virtual derived_measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of rotational_acceleration_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        rotational_acceleration_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "rotational_acceleration_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of rotational_acceleration_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static rotational_acceleration_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "rotational_acceleration_measure_with_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of rotational_acceleration_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class rotational_acceleration_unit : public virtual derived_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of rotational_acceleration_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        rotational_acceleration_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "rotational_acceleration_unit")
        {}

                /// <summary>
                /// Create new instace of rotational_acceleration_unit and returns object of this C++ class to interact with
                /// </summary>
        static rotational_acceleration_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "rotational_acceleration_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of rotational_stiffness_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class rotational_stiffness_measure_with_unit : public virtual derived_measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of rotational_stiffness_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        rotational_stiffness_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "rotational_stiffness_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of rotational_stiffness_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static rotational_stiffness_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "rotational_stiffness_measure_with_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of rotational_stiffness_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class rotational_stiffness_unit : public virtual derived_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of rotational_stiffness_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        rotational_stiffness_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "rotational_stiffness_unit")
        {}

                /// <summary>
                /// Create new instace of rotational_stiffness_unit and returns object of this C++ class to interact with
                /// </summary>
        static rotational_stiffness_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "rotational_stiffness_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of rotational_velocity_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class rotational_velocity_measure_with_unit : public virtual derived_measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of rotational_velocity_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        rotational_velocity_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "rotational_velocity_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of rotational_velocity_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static rotational_velocity_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "rotational_velocity_measure_with_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of rotational_velocity_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class rotational_velocity_unit : public virtual derived_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of rotational_velocity_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        rotational_velocity_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "rotational_velocity_unit")
        {}

                /// <summary>
                /// Create new instace of rotational_velocity_unit and returns object of this C++ class to interact with
                /// </summary>
        static rotational_velocity_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "rotational_velocity_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of seam_curve
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class seam_curve : public virtual surface_curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of seam_curve
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        seam_curve(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "seam_curve")
        {}

                /// <summary>
                /// Create new instace of seam_curve and returns object of this C++ class to interact with
                /// </summary>
        static seam_curve Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "seam_curve"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of section_profile
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class section_profile : public virtual structural_frame_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of section_profile
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        section_profile(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "section_profile")
        {}

                /// <summary>
                /// Create new instace of section_profile and returns object of this C++ class to interact with
                /// </summary>
        static section_profile Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "section_profile"); assert(inst); return inst; }

        label get_section_classification() { label val = NULL; if (sdaiGetAttrBN(m_instance, "section_classification", sdaiSTRING, &val)) return val; else return NULL; }
        void put_section_classification(label value) { sdaiPutAttrBN(m_instance, "section_classification", sdaiSTRING, value); }

        Nullable<cardinal_point_ref> get_cardinal_point() { cardinal_point_ref val = (cardinal_point_ref) 0; if (sdaiGetAttrBN(m_instance, "cardinal_point", sdaiINTEGER, &val)) return val; else return Nullable<cardinal_point_ref>(); }
        void put_cardinal_point(cardinal_point_ref value) { sdaiPutAttrBN(m_instance, "cardinal_point", sdaiINTEGER, &value); }

        Nullable<LOGICAL_VALUE> get_mirrored() { int v = getENUM("mirrored", LOGICAL_VALUE_); if (v >= 0) return (LOGICAL_VALUE) v; else return Nullable<LOGICAL_VALUE>(); }
        void put_mirrored(LOGICAL_VALUE value) { TextValue val = LOGICAL_VALUE_[(int) value]; sdaiPutAttrBN(m_instance, "mirrored", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of section_profile_simple
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class section_profile_simple : public virtual section_profile
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of section_profile_simple
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        section_profile_simple(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "section_profile_simple")
        {}

    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of section_profile_angle
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class section_profile_angle : public virtual section_profile_simple
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of section_profile_angle
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        section_profile_angle(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "section_profile_angle")
        {}

                /// <summary>
                /// Create new instace of section_profile_angle and returns object of this C++ class to interact with
                /// </summary>
        static section_profile_angle Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "section_profile_angle"); assert(inst); return inst; }

        positive_length_measure_with_unit get_depth();
        void put_depth(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_width();
        void put_width(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_thickness();
        void put_thickness(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_internal_fillet_radius();
        void put_internal_fillet_radius(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_edge_fillet_radius();
        void put_edge_fillet_radius(positive_length_measure_with_unit inst);

        ratio_measure_with_unit get_leg_slope();
        void put_leg_slope(ratio_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of section_profile_complex
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class section_profile_complex : public virtual section_profile
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of section_profile_complex
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        section_profile_complex(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "section_profile_complex")
        {}

    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of section_profile_centreline
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class section_profile_centreline : public virtual section_profile_complex
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of section_profile_centreline
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        section_profile_centreline(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "section_profile_centreline")
        {}

                /// <summary>
                /// Create new instace of section_profile_centreline and returns object of this C++ class to interact with
                /// </summary>
        static section_profile_centreline Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "section_profile_centreline"); assert(inst); return inst; }

        curve get_centreline();
        void put_centreline(curve inst);

        positive_length_measure_with_unit get_thickness();
        void put_thickness(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of section_profile_channel
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class section_profile_channel : public virtual section_profile_simple
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of section_profile_channel
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        section_profile_channel(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "section_profile_channel")
        {}

                /// <summary>
                /// Create new instace of section_profile_channel and returns object of this C++ class to interact with
                /// </summary>
        static section_profile_channel Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "section_profile_channel"); assert(inst); return inst; }

        positive_length_measure_with_unit get_overall_depth();
        void put_overall_depth(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_flange_width();
        void put_flange_width(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_flange_thickness();
        void put_flange_thickness(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_web_thickness();
        void put_web_thickness(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_root_radius();
        void put_root_radius(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_fillet_radius();
        void put_fillet_radius(positive_length_measure_with_unit inst);

        ratio_measure_with_unit get_flange_slope();
        void put_flange_slope(ratio_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of section_profile_circle
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class section_profile_circle : public virtual section_profile_simple
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of section_profile_circle
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        section_profile_circle(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "section_profile_circle")
        {}

                /// <summary>
                /// Create new instace of section_profile_circle and returns object of this C++ class to interact with
                /// </summary>
        static section_profile_circle Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "section_profile_circle"); assert(inst); return inst; }

        positive_length_measure_with_unit get_external_radius();
        void put_external_radius(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of section_profile_circle_hollow
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class section_profile_circle_hollow : public virtual section_profile_circle
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of section_profile_circle_hollow
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        section_profile_circle_hollow(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "section_profile_circle_hollow")
        {}

                /// <summary>
                /// Create new instace of section_profile_circle_hollow and returns object of this C++ class to interact with
                /// </summary>
        static section_profile_circle_hollow Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "section_profile_circle_hollow"); assert(inst); return inst; }

        positive_length_measure_with_unit get_wall_thickness();
        void put_wall_thickness(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of section_profile_compound
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class section_profile_compound : public virtual section_profile_complex
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of section_profile_compound
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        section_profile_compound(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "section_profile_compound")
        {}

                /// <summary>
                /// Create new instace of section_profile_compound and returns object of this C++ class to interact with
                /// </summary>
        static section_profile_compound Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "section_profile_compound"); assert(inst); return inst; }

        //TList may be list_of_section_profile or list of converible elements
        template <typename TList> void get_component_sections(TList& lst) { list_of_section_profileSerializer<TList> sr; sr.FromAttr(lst, m_instance, "component_sections"); }

        //TList may be list_of_section_profile or list of converible elements
        template <typename TList> void put_component_sections(TList& lst) { list_of_section_profileSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "component_sections"); }

        //TArrayElem[] may be section_profile[] or array of convertible elements
        template <typename TArrayElem> void put_component_sections(TArrayElem arr[], size_t n) { list_of_section_profile lst; ArrayToList(arr, n, lst); put_component_sections(lst); }

        //TList may be list_of_point or list of converible elements
        template <typename TList> void get_positions(TList& lst) { list_of_pointSerializer<TList> sr; sr.FromAttr(lst, m_instance, "positions"); }

        //TList may be list_of_point or list of converible elements
        template <typename TList> void put_positions(TList& lst) { list_of_pointSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "positions"); }

        //TArrayElem[] may be point[] or array of convertible elements
        template <typename TArrayElem> void put_positions(TArrayElem arr[], size_t n) { list_of_point lst; ArrayToList(arr, n, lst); put_positions(lst); }

        //TList may be list_of_orientation_select or list of converible elements
        template <typename TList> void get_orientations(TList& lst) { list_of_orientation_selectSerializer<TList> sr; sr.FromAttr(lst, m_instance, "orientations"); }

        //TList may be list_of_orientation_select or list of converible elements
        template <typename TList> void put_orientations(TList& lst) { list_of_orientation_selectSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "orientations"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of section_profile_derived
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class section_profile_derived : public virtual section_profile_complex
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of section_profile_derived
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        section_profile_derived(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "section_profile_derived")
        {}

                /// <summary>
                /// Create new instace of section_profile_derived and returns object of this C++ class to interact with
                /// </summary>
        static section_profile_derived Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "section_profile_derived"); assert(inst); return inst; }

        section_profile get_original_section();
        void put_original_section(section_profile inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of section_profile_edge_defined
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class section_profile_edge_defined : public virtual section_profile_complex
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of section_profile_edge_defined
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        section_profile_edge_defined(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "section_profile_edge_defined")
        {}

                /// <summary>
                /// Create new instace of section_profile_edge_defined and returns object of this C++ class to interact with
                /// </summary>
        static section_profile_edge_defined Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "section_profile_edge_defined"); assert(inst); return inst; }

        bounded_curve get_external_edge();
        void put_external_edge(bounded_curve inst);

        //TList may be list_of_bounded_curve or list of converible elements
        template <typename TList> void get_internal_edges(TList& lst) { list_of_bounded_curveSerializer<TList> sr; sr.FromAttr(lst, m_instance, "internal_edges"); }

        //TList may be list_of_bounded_curve or list of converible elements
        template <typename TList> void put_internal_edges(TList& lst) { list_of_bounded_curveSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "internal_edges"); }

        //TArrayElem[] may be bounded_curve[] or array of convertible elements
        template <typename TArrayElem> void put_internal_edges(TArrayElem arr[], size_t n) { list_of_bounded_curve lst; ArrayToList(arr, n, lst); put_internal_edges(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of section_profile_i_type
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class section_profile_i_type : public virtual section_profile_simple
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of section_profile_i_type
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        section_profile_i_type(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "section_profile_i_type")
        {}

                /// <summary>
                /// Create new instace of section_profile_i_type and returns object of this C++ class to interact with
                /// </summary>
        static section_profile_i_type Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "section_profile_i_type"); assert(inst); return inst; }

        positive_length_measure_with_unit get_overall_depth();
        void put_overall_depth(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_overall_width();
        void put_overall_width(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_web_thickness();
        void put_web_thickness(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_flange_thickness();
        void put_flange_thickness(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_internal_depth();
        void put_internal_depth(positive_length_measure_with_unit inst);

        ratio_measure_with_unit get_flange_slope();
        void put_flange_slope(ratio_measure_with_unit inst);

        positive_length_measure_with_unit get_root_radius();
        void put_root_radius(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_edge_radius();
        void put_edge_radius(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of section_profile_i_type_asymmetric
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class section_profile_i_type_asymmetric : public virtual section_profile_i_type
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of section_profile_i_type_asymmetric
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        section_profile_i_type_asymmetric(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "section_profile_i_type_asymmetric")
        {}

                /// <summary>
                /// Create new instace of section_profile_i_type_asymmetric and returns object of this C++ class to interact with
                /// </summary>
        static section_profile_i_type_asymmetric Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "section_profile_i_type_asymmetric"); assert(inst); return inst; }

        positive_length_measure_with_unit get_top_flange_width();
        void put_top_flange_width(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_bottom_flange_width();
        void put_bottom_flange_width(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_bottom_flange_thickness();
        void put_bottom_flange_thickness(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_bottom_root_radius();
        void put_bottom_root_radius(positive_length_measure_with_unit inst);

        ratio_measure_with_unit get_bottom_flange_slope();
        void put_bottom_flange_slope(ratio_measure_with_unit inst);

        positive_length_measure_with_unit get_bottom_flange_edge_radius();
        void put_bottom_flange_edge_radius(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of section_profile_i_type_rail
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class section_profile_i_type_rail : public virtual section_profile_i_type_asymmetric
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of section_profile_i_type_rail
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        section_profile_i_type_rail(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "section_profile_i_type_rail")
        {}

                /// <summary>
                /// Create new instace of section_profile_i_type_rail and returns object of this C++ class to interact with
                /// </summary>
        static section_profile_i_type_rail Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "section_profile_i_type_rail"); assert(inst); return inst; }

        positive_length_measure_with_unit get_top_edge_radius();
        void put_top_edge_radius(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_bottom_edge_radius();
        void put_bottom_edge_radius(positive_length_measure_with_unit inst);

        ratio_measure_with_unit get_top_flange_inner_slope();
        void put_top_flange_inner_slope(ratio_measure_with_unit inst);

        ratio_measure_with_unit get_bottom_flange_inner_slope();
        void put_bottom_flange_inner_slope(ratio_measure_with_unit inst);

        positive_length_measure_with_unit get_transition_radius_top();
        void put_transition_radius_top(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_transition_radius_bottom();
        void put_transition_radius_bottom(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of section_profile_rectangle
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class section_profile_rectangle : public virtual section_profile_simple
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of section_profile_rectangle
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        section_profile_rectangle(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "section_profile_rectangle")
        {}

                /// <summary>
                /// Create new instace of section_profile_rectangle and returns object of this C++ class to interact with
                /// </summary>
        static section_profile_rectangle Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "section_profile_rectangle"); assert(inst); return inst; }

        positive_length_measure_with_unit get_overall_depth();
        void put_overall_depth(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_overall_width();
        void put_overall_width(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_external_fillet_radius();
        void put_external_fillet_radius(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of section_profile_rectangle_hollow
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class section_profile_rectangle_hollow : public virtual section_profile_rectangle
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of section_profile_rectangle_hollow
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        section_profile_rectangle_hollow(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "section_profile_rectangle_hollow")
        {}

                /// <summary>
                /// Create new instace of section_profile_rectangle_hollow and returns object of this C++ class to interact with
                /// </summary>
        static section_profile_rectangle_hollow Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "section_profile_rectangle_hollow"); assert(inst); return inst; }

        positive_length_measure_with_unit get_wall_thickness();
        void put_wall_thickness(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_internal_fillet_radius();
        void put_internal_fillet_radius(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of section_profile_t_type
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class section_profile_t_type : public virtual section_profile_simple
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of section_profile_t_type
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        section_profile_t_type(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "section_profile_t_type")
        {}

                /// <summary>
                /// Create new instace of section_profile_t_type and returns object of this C++ class to interact with
                /// </summary>
        static section_profile_t_type Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "section_profile_t_type"); assert(inst); return inst; }

        positive_length_measure_with_unit get_overall_depth();
        void put_overall_depth(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_flange_width();
        void put_flange_width(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_flange_thickness();
        void put_flange_thickness(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_web_thickness();
        void put_web_thickness(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_root_radius();
        void put_root_radius(positive_length_measure_with_unit inst);

        ratio_measure_with_unit get_flange_slope();
        void put_flange_slope(ratio_measure_with_unit inst);

        ratio_measure_with_unit get_web_slope();
        void put_web_slope(ratio_measure_with_unit inst);

        positive_length_measure_with_unit get_edge_radius();
        void put_edge_radius(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of section_properties
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class section_properties : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of section_properties
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        section_properties(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "section_properties")
        {}

                /// <summary>
                /// Create new instace of section_properties and returns object of this C++ class to interact with
                /// </summary>
        static section_properties Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "section_properties"); assert(inst); return inst; }

        section_profile get_profile();
        void put_profile(section_profile inst);

        //TList may be array_of_length_measure_with_unit or list of converible elements
        template <typename TList> void get_origin_offset(TList& lst) { array_of_length_measure_with_unitSerializer<TList> sr; sr.FromAttr(lst, m_instance, "origin_offset"); }

        //TList may be array_of_length_measure_with_unit or list of converible elements
        template <typename TList> void put_origin_offset(TList& lst) { array_of_length_measure_with_unitSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "origin_offset"); }

        //TArrayElem[] may be length_measure_with_unit[] or array of convertible elements
        template <typename TArrayElem> void put_origin_offset(TArrayElem arr[], size_t n) { array_of_length_measure_with_unit lst; ArrayToList(arr, n, lst); put_origin_offset(lst); }

        inertia_measure_with_unit get_torsional_constant_Ix();
        void put_torsional_constant_Ix(inertia_measure_with_unit inst);

        inertia_measure_with_unit get_inertia_moment_Iy();
        void put_inertia_moment_Iy(inertia_measure_with_unit inst);

        inertia_measure_with_unit get_inertia_moment_Iz();
        void put_inertia_moment_Iz(inertia_measure_with_unit inst);

        area_measure_with_unit get_section_area_Ax();
        void put_section_area_Ax(area_measure_with_unit inst);

        area_measure_with_unit get_shear_area_Asy();
        void put_shear_area_Asy(area_measure_with_unit inst);

        area_measure_with_unit get_shear_area_Asz();
        void put_shear_area_Asz(area_measure_with_unit inst);

        area_measure_with_unit get_shear_deformation_area_Ay();
        void put_shear_deformation_area_Ay(area_measure_with_unit inst);

        area_measure_with_unit get_shear_deformation_area_Az();
        void put_shear_deformation_area_Az(area_measure_with_unit inst);

        positive_length_measure_with_unit get_surface_per_length();
        void put_surface_per_length(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_radius_of_gyration_ry();
        void put_radius_of_gyration_ry(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_radius_of_gyration_rz();
        void put_radius_of_gyration_rz(positive_length_measure_with_unit inst);

        modulus_measure_with_unit get_plastic_modulus_Sy();
        void put_plastic_modulus_Sy(modulus_measure_with_unit inst);

        modulus_measure_with_unit get_plastic_modulus_Sz();
        void put_plastic_modulus_Sz(modulus_measure_with_unit inst);

        derived_measure_with_unit get_warping_constant();
        void put_warping_constant(derived_measure_with_unit inst);

        Nullable<double> get_torsional_index() { double val = (double) 0; if (sdaiGetAttrBN(m_instance, "torsional_index", sdaiREAL, &val)) return val; else return Nullable<double>(); }
        void put_torsional_index(double value) { sdaiPutAttrBN(m_instance, "torsional_index", sdaiREAL, &value); }

        Nullable<double> get_buckling_parameter() { double val = (double) 0; if (sdaiGetAttrBN(m_instance, "buckling_parameter", sdaiREAL, &val)) return val; else return Nullable<double>(); }
        void put_buckling_parameter(double value) { sdaiPutAttrBN(m_instance, "buckling_parameter", sdaiREAL, &value); }

        mass_per_length_measure_with_unit get_nominal_mass();
        void put_nominal_mass(mass_per_length_measure_with_unit inst);

        mass_per_length_measure_with_unit get_actual_mass();
        void put_actual_mass(mass_per_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of section_properties_asymmetric
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class section_properties_asymmetric : public virtual section_properties
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of section_properties_asymmetric
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        section_properties_asymmetric(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "section_properties_asymmetric")
        {}

                /// <summary>
                /// Create new instace of section_properties_asymmetric and returns object of this C++ class to interact with
                /// </summary>
        static section_properties_asymmetric Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "section_properties_asymmetric"); assert(inst); return inst; }

        //TList may be array_of_length_measure_with_unit or list of converible elements
        template <typename TList> void get_neutral_axis_shear_centre(TList& lst) { array_of_length_measure_with_unitSerializer<TList> sr; sr.FromAttr(lst, m_instance, "neutral_axis_shear_centre"); }

        //TList may be array_of_length_measure_with_unit or list of converible elements
        template <typename TList> void put_neutral_axis_shear_centre(TList& lst) { array_of_length_measure_with_unitSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "neutral_axis_shear_centre"); }

        //TArrayElem[] may be length_measure_with_unit[] or array of convertible elements
        template <typename TArrayElem> void put_neutral_axis_shear_centre(TArrayElem arr[], size_t n) { array_of_length_measure_with_unit lst; ArrayToList(arr, n, lst); put_neutral_axis_shear_centre(lst); }

        plane_angle_measure_with_unit get_theta_angle_z_axis_v_axis();
        void put_theta_angle_z_axis_v_axis(plane_angle_measure_with_unit inst);

        inertia_measure_with_unit get_inertia_moment_Iu();
        void put_inertia_moment_Iu(inertia_measure_with_unit inst);

        inertia_measure_with_unit get_inertia_moment_Iv();
        void put_inertia_moment_Iv(inertia_measure_with_unit inst);

        positive_length_measure_with_unit get_radius_of_gyration_ru();
        void put_radius_of_gyration_ru(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_radius_of_gyration_rv();
        void put_radius_of_gyration_rv(positive_length_measure_with_unit inst);

        //TList may be array_of_modulus_measure_with_unit or list of converible elements
        template <typename TList> void get_section_modulii(TList& lst) { array_of_modulus_measure_with_unitSerializer<TList> sr; sr.FromAttr(lst, m_instance, "section_modulii"); }

        //TList may be array_of_modulus_measure_with_unit or list of converible elements
        template <typename TList> void put_section_modulii(TList& lst) { array_of_modulus_measure_with_unitSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "section_modulii"); }

        //TArrayElem[] may be modulus_measure_with_unit[] or array of convertible elements
        template <typename TArrayElem> void put_section_modulii(TArrayElem arr[], size_t n) { array_of_modulus_measure_with_unit lst; ArrayToList(arr, n, lst); put_section_modulii(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of setting_out_point
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class setting_out_point : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of setting_out_point
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        setting_out_point(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "setting_out_point")
        {}

                /// <summary>
                /// Create new instace of setting_out_point and returns object of this C++ class to interact with
                /// </summary>
        static setting_out_point Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "setting_out_point"); assert(inst); return inst; }

        site get_set_out_site();
        void put_set_out_site(site inst);

        geographical_location get_location();
        void put_location(geographical_location inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of shape_representation
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class shape_representation : public virtual representation
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of shape_representation
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        shape_representation(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "shape_representation")
        {}

                /// <summary>
                /// Create new instace of shape_representation and returns object of this C++ class to interact with
                /// </summary>
        static shape_representation Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "shape_representation"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of shape_representation_with_units
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class shape_representation_with_units : public virtual shape_representation
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of shape_representation_with_units
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        shape_representation_with_units(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "shape_representation_with_units")
        {}

                /// <summary>
                /// Create new instace of shape_representation_with_units and returns object of this C++ class to interact with
                /// </summary>
        static shape_representation_with_units Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "shape_representation_with_units"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of shell_based_surface_model
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class shell_based_surface_model : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of shell_based_surface_model
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        shell_based_surface_model(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "shell_based_surface_model")
        {}

                /// <summary>
                /// Create new instace of shell_based_surface_model and returns object of this C++ class to interact with
                /// </summary>
        static shell_based_surface_model Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "shell_based_surface_model"); assert(inst); return inst; }

        //TList may be set_of_shell or list of converible elements
        template <typename TList> void get_sbsm_boundary(TList& lst) { set_of_shellSerializer<TList> sr; sr.FromAttr(lst, m_instance, "sbsm_boundary"); }

        //TList may be set_of_shell or list of converible elements
        template <typename TList> void put_sbsm_boundary(TList& lst) { set_of_shellSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "sbsm_boundary"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of shell_based_wireframe_model
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class shell_based_wireframe_model : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of shell_based_wireframe_model
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        shell_based_wireframe_model(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "shell_based_wireframe_model")
        {}

                /// <summary>
                /// Create new instace of shell_based_wireframe_model and returns object of this C++ class to interact with
                /// </summary>
        static shell_based_wireframe_model Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "shell_based_wireframe_model"); assert(inst); return inst; }

        //TList may be set_of_shell or list of converible elements
        template <typename TList> void get_sbwm_boundary(TList& lst) { set_of_shellSerializer<TList> sr; sr.FromAttr(lst, m_instance, "sbwm_boundary"); }

        //TList may be set_of_shell or list of converible elements
        template <typename TList> void put_sbwm_boundary(TList& lst) { set_of_shellSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "sbwm_boundary"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of si_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class si_unit : public virtual named_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of si_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        si_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "si_unit")
        {}

                /// <summary>
                /// Create new instace of si_unit and returns object of this C++ class to interact with
                /// </summary>
        static si_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "si_unit"); assert(inst); return inst; }

        Nullable<si_prefix> get_prefix() { int v = getENUM("prefix", si_prefix_); if (v >= 0) return (si_prefix) v; else return Nullable<si_prefix>(); }
        void put_prefix(si_prefix value) { TextValue val = si_prefix_[(int) value]; sdaiPutAttrBN(m_instance, "prefix", sdaiENUM, val); }

        Nullable<si_unit_name> get_name() { int v = getENUM("name", si_unit_name_); if (v >= 0) return (si_unit_name) v; else return Nullable<si_unit_name>(); }
        void put_name(si_unit_name value) { TextValue val = si_unit_name_[(int) value]; sdaiPutAttrBN(m_instance, "name", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of site
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class site : public virtual structural_frame_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of site
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        site(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "site")
        {}

                /// <summary>
                /// Create new instace of site and returns object of this C++ class to interact with
                /// </summary>
        static site Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "site"); assert(inst); return inst; }

        address get_site_address();
        void put_site_address(address inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of site_with_shape
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class site_with_shape : public virtual site
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of site_with_shape
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        site_with_shape(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "site_with_shape")
        {}

                /// <summary>
                /// Create new instace of site_with_shape and returns object of this C++ class to interact with
                /// </summary>
        static site_with_shape Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "site_with_shape"); assert(inst); return inst; }

        shape_representation_with_units get_shape();
        void put_shape(shape_representation_with_units inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of solder
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class solder : public virtual structural_frame_process
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of solder
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        solder(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "solder")
        {}

                /// <summary>
                /// Create new instace of solder and returns object of this C++ class to interact with
                /// </summary>
        static solder Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "solder"); assert(inst); return inst; }

        Nullable<soldering_type> get_solder_type() { int v = getENUM("solder_type", soldering_type_); if (v >= 0) return (soldering_type) v; else return Nullable<soldering_type>(); }
        void put_solder_type(soldering_type value) { TextValue val = soldering_type_[(int) value]; sdaiPutAttrBN(m_instance, "solder_type", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of solid_angle_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class solid_angle_measure_with_unit : public virtual measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of solid_angle_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        solid_angle_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "solid_angle_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of solid_angle_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static solid_angle_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "solid_angle_measure_with_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of solid_angle_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class solid_angle_unit : public virtual named_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of solid_angle_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        solid_angle_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "solid_angle_unit")
        {}

                /// <summary>
                /// Create new instace of solid_angle_unit and returns object of this C++ class to interact with
                /// </summary>
        static solid_angle_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "solid_angle_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of solid_replica
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class solid_replica : public virtual solid_model
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of solid_replica
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        solid_replica(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "solid_replica")
        {}

                /// <summary>
                /// Create new instace of solid_replica and returns object of this C++ class to interact with
                /// </summary>
        static solid_replica Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "solid_replica"); assert(inst); return inst; }

        solid_model get_parent_solid();
        void put_parent_solid(solid_model inst);

        cartesian_transformation_operator_3d get_transformation();
        void put_transformation(cartesian_transformation_operator_3d inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of sphere
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class sphere : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of sphere
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        sphere(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "sphere")
        {}

                /// <summary>
                /// Create new instace of sphere and returns object of this C++ class to interact with
                /// </summary>
        static sphere Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "sphere"); assert(inst); return inst; }

        Nullable<positive_length_measure> get_radius() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "radius", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_radius(positive_length_measure value) { sdaiPutAttrBN(m_instance, "radius", sdaiREAL, &value); }

        point get_centre();
        void put_centre(point inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of spherical_point
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class spherical_point : public virtual cartesian_point
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of spherical_point
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        spherical_point(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "spherical_point")
        {}

                /// <summary>
                /// Create new instace of spherical_point and returns object of this C++ class to interact with
                /// </summary>
        static spherical_point Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "spherical_point"); assert(inst); return inst; }

        Nullable<length_measure> get_r() { length_measure val = (length_measure) 0; if (sdaiGetAttrBN(m_instance, "r", sdaiREAL, &val)) return val; else return Nullable<length_measure>(); }
        void put_r(length_measure value) { sdaiPutAttrBN(m_instance, "r", sdaiREAL, &value); }

        Nullable<plane_angle_measure> get_theta() { plane_angle_measure val = (plane_angle_measure) 0; if (sdaiGetAttrBN(m_instance, "theta", sdaiREAL, &val)) return val; else return Nullable<plane_angle_measure>(); }
        void put_theta(plane_angle_measure value) { sdaiPutAttrBN(m_instance, "theta", sdaiREAL, &value); }

        Nullable<plane_angle_measure> get_phi() { plane_angle_measure val = (plane_angle_measure) 0; if (sdaiGetAttrBN(m_instance, "phi", sdaiREAL, &val)) return val; else return Nullable<plane_angle_measure>(); }
        void put_phi(plane_angle_measure value) { sdaiPutAttrBN(m_instance, "phi", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of spherical_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class spherical_surface : public virtual elementary_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of spherical_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        spherical_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "spherical_surface")
        {}

                /// <summary>
                /// Create new instace of spherical_surface and returns object of this C++ class to interact with
                /// </summary>
        static spherical_surface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "spherical_surface"); assert(inst); return inst; }

        Nullable<positive_length_measure> get_radius() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "radius", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_radius(positive_length_measure value) { sdaiPutAttrBN(m_instance, "radius", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of spherical_volume
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class spherical_volume : public virtual volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of spherical_volume
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        spherical_volume(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "spherical_volume")
        {}

                /// <summary>
                /// Create new instace of spherical_volume and returns object of this C++ class to interact with
                /// </summary>
        static spherical_volume Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "spherical_volume"); assert(inst); return inst; }

        axis2_placement_3d get_position();
        void put_position(axis2_placement_3d inst);

        Nullable<positive_length_measure> get_radius() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "radius", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_radius(positive_length_measure value) { sdaiPutAttrBN(m_instance, "radius", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of standard_uncertainty
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class standard_uncertainty : public virtual uncertainty_qualifier
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of standard_uncertainty
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        standard_uncertainty(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "standard_uncertainty")
        {}

                /// <summary>
                /// Create new instace of standard_uncertainty and returns object of this C++ class to interact with
                /// </summary>
        static standard_uncertainty Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "standard_uncertainty"); assert(inst); return inst; }

        Nullable<double> get_uncertainty_value() { double val = (double) 0; if (sdaiGetAttrBN(m_instance, "uncertainty_value", sdaiREAL, &val)) return val; else return Nullable<double>(); }
        void put_uncertainty_value(double value) { sdaiPutAttrBN(m_instance, "uncertainty_value", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of step_file
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class step_file : public virtual media_file
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of step_file
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        step_file(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "step_file")
        {}

                /// <summary>
                /// Create new instace of step_file and returns object of this C++ class to interact with
                /// </summary>
        static step_file Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "step_file"); assert(inst); return inst; }

        //TList may be set_of_group_assignment or list of converible elements
        template <typename TList> void get_selected_content(TList& lst) { set_of_group_assignmentSerializer<TList> sr; sr.FromAttr(lst, m_instance, "selected_content"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of structural_frame_item_approved
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class structural_frame_item_approved : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of structural_frame_item_approved
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        structural_frame_item_approved(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "structural_frame_item_approved")
        {}

                /// <summary>
                /// Create new instace of structural_frame_item_approved and returns object of this C++ class to interact with
                /// </summary>
        static structural_frame_item_approved Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "structural_frame_item_approved"); assert(inst); return inst; }

        structural_frame_item get_approved_item();
        void put_approved_item(structural_frame_item inst);

        approval get_assigned_approval();
        void put_assigned_approval(approval inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of structural_frame_item_certified
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class structural_frame_item_certified : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of structural_frame_item_certified
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        structural_frame_item_certified(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "structural_frame_item_certified")
        {}

                /// <summary>
                /// Create new instace of structural_frame_item_certified and returns object of this C++ class to interact with
                /// </summary>
        static structural_frame_item_certified Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "structural_frame_item_certified"); assert(inst); return inst; }

        structural_frame_item get_certified_item();
        void put_certified_item(structural_frame_item inst);

        certification get_assigned_certification();
        void put_assigned_certification(certification inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of structural_frame_item_documented
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class structural_frame_item_documented : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of structural_frame_item_documented
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        structural_frame_item_documented(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "structural_frame_item_documented")
        {}

                /// <summary>
                /// Create new instace of structural_frame_item_documented and returns object of this C++ class to interact with
                /// </summary>
        static structural_frame_item_documented Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "structural_frame_item_documented"); assert(inst); return inst; }

        structural_frame_item get_documented_item();
        void put_documented_item(structural_frame_item inst);

        document_usage_constraint get_document_reference();
        void put_document_reference(document_usage_constraint inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of structural_frame_item_priced
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class structural_frame_item_priced : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of structural_frame_item_priced
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        structural_frame_item_priced(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "structural_frame_item_priced")
        {}

                /// <summary>
                /// Create new instace of structural_frame_item_priced and returns object of this C++ class to interact with
                /// </summary>
        static structural_frame_item_priced Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "structural_frame_item_priced"); assert(inst); return inst; }

        structural_frame_item get_priced_item();
        void put_priced_item(structural_frame_item inst);

        currency_measure_with_unit get_assigned_price();
        void put_assigned_price(currency_measure_with_unit inst);

        text get_price_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "price_description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_price_description(text value) { sdaiPutAttrBN(m_instance, "price_description", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of structural_frame_item_relationship
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class structural_frame_item_relationship : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of structural_frame_item_relationship
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        structural_frame_item_relationship(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "structural_frame_item_relationship")
        {}

                /// <summary>
                /// Create new instace of structural_frame_item_relationship and returns object of this C++ class to interact with
                /// </summary>
        static structural_frame_item_relationship Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "structural_frame_item_relationship"); assert(inst); return inst; }

        label get_relationship_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "relationship_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_relationship_name(label value) { sdaiPutAttrBN(m_instance, "relationship_name", sdaiSTRING, value); }

        text get_relationship_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "relationship_description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_relationship_description(text value) { sdaiPutAttrBN(m_instance, "relationship_description", sdaiSTRING, value); }

        structural_frame_item get_related_item();
        void put_related_item(structural_frame_item inst);

        structural_frame_item get_relating_item();
        void put_relating_item(structural_frame_item inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of structural_frame_product_with_material
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class structural_frame_product_with_material : public virtual structural_frame_product
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of structural_frame_product_with_material
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        structural_frame_product_with_material(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "structural_frame_product_with_material")
        {}

                /// <summary>
                /// Create new instace of structural_frame_product_with_material and returns object of this C++ class to interact with
                /// </summary>
        static structural_frame_product_with_material Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "structural_frame_product_with_material"); assert(inst); return inst; }

        material get_material_definition();
        void put_material_definition(material inst);

        mass_measure_with_unit get_nominal_mass();
        void put_nominal_mass(mass_measure_with_unit inst);

        mass_measure_with_unit get_actual_mass();
        void put_actual_mass(mass_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of structure
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class structure : public virtual structural_frame_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of structure
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        structure(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "structure")
        {}

                /// <summary>
                /// Create new instace of structure and returns object of this C++ class to interact with
                /// </summary>
        static structure Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "structure"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of subedge
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class subedge : public virtual edge
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of subedge
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        subedge(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "subedge")
        {}

                /// <summary>
                /// Create new instace of subedge and returns object of this C++ class to interact with
                /// </summary>
        static subedge Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "subedge"); assert(inst); return inst; }

        edge get_parent_edge();
        void put_parent_edge(edge inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of subface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class subface : public virtual face
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of subface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        subface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "subface")
        {}

                /// <summary>
                /// Create new instace of subface and returns object of this C++ class to interact with
                /// </summary>
        static subface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "subface"); assert(inst); return inst; }

        face get_parent_face();
        void put_parent_face(face inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of surface_curve_swept_area_solid
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class surface_curve_swept_area_solid : public virtual swept_area_solid
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of surface_curve_swept_area_solid
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        surface_curve_swept_area_solid(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "surface_curve_swept_area_solid")
        {}

                /// <summary>
                /// Create new instace of surface_curve_swept_area_solid and returns object of this C++ class to interact with
                /// </summary>
        static surface_curve_swept_area_solid Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "surface_curve_swept_area_solid"); assert(inst); return inst; }

        curve get_directrix();
        void put_directrix(curve inst);

        Nullable<double> get_start_param() { double val = (double) 0; if (sdaiGetAttrBN(m_instance, "start_param", sdaiREAL, &val)) return val; else return Nullable<double>(); }
        void put_start_param(double value) { sdaiPutAttrBN(m_instance, "start_param", sdaiREAL, &value); }

        Nullable<double> get_end_param() { double val = (double) 0; if (sdaiGetAttrBN(m_instance, "end_param", sdaiREAL, &val)) return val; else return Nullable<double>(); }
        void put_end_param(double value) { sdaiPutAttrBN(m_instance, "end_param", sdaiREAL, &value); }

        surface get_reference_surface();
        void put_reference_surface(surface inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of surface_curve_swept_face_solid
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class surface_curve_swept_face_solid : public virtual swept_face_solid
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of surface_curve_swept_face_solid
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        surface_curve_swept_face_solid(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "surface_curve_swept_face_solid")
        {}

                /// <summary>
                /// Create new instace of surface_curve_swept_face_solid and returns object of this C++ class to interact with
                /// </summary>
        static surface_curve_swept_face_solid Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "surface_curve_swept_face_solid"); assert(inst); return inst; }

        curve get_directrix();
        void put_directrix(curve inst);

        Nullable<double> get_start_param() { double val = (double) 0; if (sdaiGetAttrBN(m_instance, "start_param", sdaiREAL, &val)) return val; else return Nullable<double>(); }
        void put_start_param(double value) { sdaiPutAttrBN(m_instance, "start_param", sdaiREAL, &value); }

        Nullable<double> get_end_param() { double val = (double) 0; if (sdaiGetAttrBN(m_instance, "end_param", sdaiREAL, &val)) return val; else return Nullable<double>(); }
        void put_end_param(double value) { sdaiPutAttrBN(m_instance, "end_param", sdaiREAL, &value); }

        surface get_reference_surface();
        void put_reference_surface(surface inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of surface_curve_swept_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class surface_curve_swept_surface : public virtual swept_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of surface_curve_swept_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        surface_curve_swept_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "surface_curve_swept_surface")
        {}

                /// <summary>
                /// Create new instace of surface_curve_swept_surface and returns object of this C++ class to interact with
                /// </summary>
        static surface_curve_swept_surface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "surface_curve_swept_surface"); assert(inst); return inst; }

        curve get_directrix();
        void put_directrix(curve inst);

        surface get_reference_surface();
        void put_reference_surface(surface inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of surface_of_linear_extrusion
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class surface_of_linear_extrusion : public virtual swept_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of surface_of_linear_extrusion
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        surface_of_linear_extrusion(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "surface_of_linear_extrusion")
        {}

                /// <summary>
                /// Create new instace of surface_of_linear_extrusion and returns object of this C++ class to interact with
                /// </summary>
        static surface_of_linear_extrusion Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "surface_of_linear_extrusion"); assert(inst); return inst; }

        vector get_extrusion_axis();
        void put_extrusion_axis(vector inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of surface_of_revolution
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class surface_of_revolution : public virtual swept_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of surface_of_revolution
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        surface_of_revolution(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "surface_of_revolution")
        {}

                /// <summary>
                /// Create new instace of surface_of_revolution and returns object of this C++ class to interact with
                /// </summary>
        static surface_of_revolution Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "surface_of_revolution"); assert(inst); return inst; }

        axis1_placement get_axis_position();
        void put_axis_position(axis1_placement inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of surface_patch
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class surface_patch : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of surface_patch
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        surface_patch(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "surface_patch")
        {}

                /// <summary>
                /// Create new instace of surface_patch and returns object of this C++ class to interact with
                /// </summary>
        static surface_patch Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "surface_patch"); assert(inst); return inst; }

        bounded_surface get_parent_surface();
        void put_parent_surface(bounded_surface inst);

        Nullable<transition_code> get_u_transition() { int v = getENUM("u_transition", transition_code_); if (v >= 0) return (transition_code) v; else return Nullable<transition_code>(); }
        void put_u_transition(transition_code value) { TextValue val = transition_code_[(int) value]; sdaiPutAttrBN(m_instance, "u_transition", sdaiENUM, val); }

        Nullable<transition_code> get_v_transition() { int v = getENUM("v_transition", transition_code_); if (v >= 0) return (transition_code) v; else return Nullable<transition_code>(); }
        void put_v_transition(transition_code value) { TextValue val = transition_code_[(int) value]; sdaiPutAttrBN(m_instance, "v_transition", sdaiENUM, val); }

        Nullable<bool> get_u_sense() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "u_sense", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_u_sense(bool value) { sdaiPutAttrBN(m_instance, "u_sense", sdaiBOOLEAN, &value); }

        Nullable<bool> get_v_sense() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "v_sense", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_v_sense(bool value) { sdaiPutAttrBN(m_instance, "v_sense", sdaiBOOLEAN, &value); }

        //TList may be bag_of_rectangular_composite_surface or list of converible elements
        template <typename TList> void get_using_surfaces(TList& lst) { bag_of_rectangular_composite_surfaceSerializer<TList> sr; sr.FromAttr(lst, m_instance, "using_surfaces"); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of surface_replica
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class surface_replica : public virtual surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of surface_replica
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        surface_replica(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "surface_replica")
        {}

                /// <summary>
                /// Create new instace of surface_replica and returns object of this C++ class to interact with
                /// </summary>
        static surface_replica Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "surface_replica"); assert(inst); return inst; }

        surface get_parent_surface();
        void put_parent_surface(surface inst);

        cartesian_transformation_operator_3d get_transformation();
        void put_transformation(cartesian_transformation_operator_3d inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of surface_treatment
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class surface_treatment : public virtual structural_frame_process
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of surface_treatment
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        surface_treatment(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "surface_treatment")
        {}


        text get_surface_finish_specification() { text val = NULL; if (sdaiGetAttrBN(m_instance, "surface_finish_specification", sdaiSTRING, &val)) return val; else return NULL; }
        void put_surface_finish_specification(text value) { sdaiPutAttrBN(m_instance, "surface_finish_specification", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of surface_treatment_clean
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class surface_treatment_clean : public virtual surface_treatment
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of surface_treatment_clean
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        surface_treatment_clean(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "surface_treatment_clean")
        {}

                /// <summary>
                /// Create new instace of surface_treatment_clean and returns object of this C++ class to interact with
                /// </summary>
        static surface_treatment_clean Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "surface_treatment_clean"); assert(inst); return inst; }

        Nullable<cleaning_method> get_method() { int v = getENUM("method", cleaning_method_); if (v >= 0) return (cleaning_method) v; else return Nullable<cleaning_method>(); }
        void put_method(cleaning_method value) { TextValue val = cleaning_method_[(int) value]; sdaiPutAttrBN(m_instance, "method", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of surface_treatment_coat
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class surface_treatment_coat : public virtual surface_treatment
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of surface_treatment_coat
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        surface_treatment_coat(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "surface_treatment_coat")
        {}

                /// <summary>
                /// Create new instace of surface_treatment_coat and returns object of this C++ class to interact with
                /// </summary>
        static surface_treatment_coat Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "surface_treatment_coat"); assert(inst); return inst; }

        //TList may be list_of_coating_method or list of converible elements
        template <typename TList> void get_methods(TList& lst) { list_of_coating_methodSerializer<TList> sr; sr.FromAttr(lst, m_instance, "methods"); }

        //TList may be list_of_coating_method or list of converible elements
        template <typename TList> void put_methods(TList& lst) { list_of_coating_methodSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "methods"); }

        //TArrayElem[] may be coating_method[] or array of convertible elements
        template <typename TArrayElem> void put_methods(TArrayElem arr[], size_t n) { list_of_coating_method lst; ArrayToList(arr, n, lst); put_methods(lst); }

        //TList may be list_of_positive_length_measure_with_unit or list of converible elements
        template <typename TList> void get_layer_thicknesses(TList& lst) { list_of_positive_length_measure_with_unitSerializer<TList> sr; sr.FromAttr(lst, m_instance, "layer_thicknesses"); }

        //TList may be list_of_positive_length_measure_with_unit or list of converible elements
        template <typename TList> void put_layer_thicknesses(TList& lst) { list_of_positive_length_measure_with_unitSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "layer_thicknesses"); }

        //TArrayElem[] may be positive_length_measure_with_unit[] or array of convertible elements
        template <typename TArrayElem> void put_layer_thicknesses(TArrayElem arr[], size_t n) { list_of_positive_length_measure_with_unit lst; ArrayToList(arr, n, lst); put_layer_thicknesses(lst); }

        //TList may be list_of_coating or list of converible elements
        template <typename TList> void get_coating_specifications(TList& lst) { list_of_coatingSerializer<TList> sr; sr.FromAttr(lst, m_instance, "coating_specifications"); }

        //TList may be list_of_coating or list of converible elements
        template <typename TList> void put_coating_specifications(TList& lst) { list_of_coatingSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "coating_specifications"); }

        //TArrayElem[] may be coating[] or array of convertible elements
        template <typename TArrayElem> void put_coating_specifications(TArrayElem arr[], size_t n) { list_of_coating lst; ArrayToList(arr, n, lst); put_coating_specifications(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of surface_treatment_grind
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class surface_treatment_grind : public virtual surface_treatment
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of surface_treatment_grind
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        surface_treatment_grind(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "surface_treatment_grind")
        {}

                /// <summary>
                /// Create new instace of surface_treatment_grind and returns object of this C++ class to interact with
                /// </summary>
        static surface_treatment_grind Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "surface_treatment_grind"); assert(inst); return inst; }

        length_measure_with_unit get_finished_surface_irregularity();
        void put_finished_surface_irregularity(length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of surface_treatment_hard_stamp
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class surface_treatment_hard_stamp : public virtual surface_treatment
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of surface_treatment_hard_stamp
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        surface_treatment_hard_stamp(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "surface_treatment_hard_stamp")
        {}

                /// <summary>
                /// Create new instace of surface_treatment_hard_stamp and returns object of this C++ class to interact with
                /// </summary>
        static surface_treatment_hard_stamp Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "surface_treatment_hard_stamp"); assert(inst); return inst; }

        Nullable<cutting_type> get_stamp_method() { int v = getENUM("stamp_method", cutting_type_); if (v >= 0) return (cutting_type) v; else return Nullable<cutting_type>(); }
        void put_stamp_method(cutting_type value) { TextValue val = cutting_type_[(int) value]; sdaiPutAttrBN(m_instance, "stamp_method", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of surface_treatment_thermal
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class surface_treatment_thermal : public virtual surface_treatment
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of surface_treatment_thermal
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        surface_treatment_thermal(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "surface_treatment_thermal")
        {}

                /// <summary>
                /// Create new instace of surface_treatment_thermal and returns object of this C++ class to interact with
                /// </summary>
        static surface_treatment_thermal Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "surface_treatment_thermal"); assert(inst); return inst; }

        thermodynamic_temperature_measure_with_unit get_initial_temperature();
        void put_initial_temperature(thermodynamic_temperature_measure_with_unit inst);

        thermodynamic_temperature_measure_with_unit get_final_temperature();
        void put_final_temperature(thermodynamic_temperature_measure_with_unit inst);

        thermodynamic_temperature_measure_with_unit get_maximum_temperature();
        void put_maximum_temperature(thermodynamic_temperature_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of surface_treatment_thermal_timed
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class surface_treatment_thermal_timed : public virtual surface_treatment_thermal
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of surface_treatment_thermal_timed
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        surface_treatment_thermal_timed(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "surface_treatment_thermal_timed")
        {}

                /// <summary>
                /// Create new instace of surface_treatment_thermal_timed and returns object of this C++ class to interact with
                /// </summary>
        static surface_treatment_thermal_timed Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "surface_treatment_thermal_timed"); assert(inst); return inst; }

        time_measure_with_unit get_time_to_maximum();
        void put_time_to_maximum(time_measure_with_unit inst);

        time_measure_with_unit get_time_at_maximum();
        void put_time_at_maximum(time_measure_with_unit inst);

        time_measure_with_unit get_time_to_final();
        void put_time_to_final(time_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of tetrahedron
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class tetrahedron : public virtual faceted_primitive
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of tetrahedron
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        tetrahedron(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "tetrahedron")
        {}

                /// <summary>
                /// Create new instace of tetrahedron and returns object of this C++ class to interact with
                /// </summary>
        static tetrahedron Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "tetrahedron"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of tetrahedron_volume
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class tetrahedron_volume : public virtual volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of tetrahedron_volume
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        tetrahedron_volume(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "tetrahedron_volume")
        {}

                /// <summary>
                /// Create new instace of tetrahedron_volume and returns object of this C++ class to interact with
                /// </summary>
        static tetrahedron_volume Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "tetrahedron_volume"); assert(inst); return inst; }

        cartesian_point get_point_1();
        void put_point_1(cartesian_point inst);

        cartesian_point get_point_2();
        void put_point_2(cartesian_point inst);

        cartesian_point get_point_3();
        void put_point_3(cartesian_point inst);

        cartesian_point get_point_4();
        void put_point_4(cartesian_point inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of thermodynamic_temperature_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class thermodynamic_temperature_measure_with_unit : public virtual measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of thermodynamic_temperature_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        thermodynamic_temperature_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "thermodynamic_temperature_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of thermodynamic_temperature_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static thermodynamic_temperature_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "thermodynamic_temperature_measure_with_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of thermodynamic_temperature_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class thermodynamic_temperature_unit : public virtual named_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of thermodynamic_temperature_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        thermodynamic_temperature_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "thermodynamic_temperature_unit")
        {}

                /// <summary>
                /// Create new instace of thermodynamic_temperature_unit and returns object of this C++ class to interact with
                /// </summary>
        static thermodynamic_temperature_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "thermodynamic_temperature_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of time_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class time_measure_with_unit : public virtual measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of time_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        time_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "time_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of time_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static time_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "time_measure_with_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of time_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class time_unit : public virtual named_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of time_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        time_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "time_unit")
        {}

                /// <summary>
                /// Create new instace of time_unit and returns object of this C++ class to interact with
                /// </summary>
        static time_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "time_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of toroidal_volume
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class toroidal_volume : public virtual volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of toroidal_volume
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        toroidal_volume(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "toroidal_volume")
        {}

                /// <summary>
                /// Create new instace of toroidal_volume and returns object of this C++ class to interact with
                /// </summary>
        static toroidal_volume Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "toroidal_volume"); assert(inst); return inst; }

        axis2_placement_3d get_position();
        void put_position(axis2_placement_3d inst);

        Nullable<positive_length_measure> get_major_radius() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "major_radius", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_major_radius(positive_length_measure value) { sdaiPutAttrBN(m_instance, "major_radius", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_minor_radius() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "minor_radius", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_minor_radius(positive_length_measure value) { sdaiPutAttrBN(m_instance, "minor_radius", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of torus
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class torus : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of torus
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        torus(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "torus")
        {}

                /// <summary>
                /// Create new instace of torus and returns object of this C++ class to interact with
                /// </summary>
        static torus Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "torus"); assert(inst); return inst; }

        axis1_placement get_position();
        void put_position(axis1_placement inst);

        Nullable<positive_length_measure> get_major_radius() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "major_radius", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_major_radius(positive_length_measure value) { sdaiPutAttrBN(m_instance, "major_radius", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_minor_radius() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "minor_radius", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_minor_radius(positive_length_measure value) { sdaiPutAttrBN(m_instance, "minor_radius", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of trimmed_curve
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class trimmed_curve : public virtual bounded_curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of trimmed_curve
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        trimmed_curve(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "trimmed_curve")
        {}

                /// <summary>
                /// Create new instace of trimmed_curve and returns object of this C++ class to interact with
                /// </summary>
        static trimmed_curve Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "trimmed_curve"); assert(inst); return inst; }

        curve get_basis_curve();
        void put_basis_curve(curve inst);

        //TList may be set_of_trimming_select or list of converible elements
        template <typename TList> void get_trim_1(TList& lst) { set_of_trimming_selectSerializer<TList> sr; sr.FromAttr(lst, m_instance, "trim_1"); }

        //TList may be set_of_trimming_select or list of converible elements
        template <typename TList> void put_trim_1(TList& lst) { set_of_trimming_selectSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "trim_1"); }

        //TList may be set_of_trimming_select or list of converible elements
        template <typename TList> void get_trim_2(TList& lst) { set_of_trimming_selectSerializer<TList> sr; sr.FromAttr(lst, m_instance, "trim_2"); }

        //TList may be set_of_trimming_select or list of converible elements
        template <typename TList> void put_trim_2(TList& lst) { set_of_trimming_selectSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "trim_2"); }

        Nullable<bool> get_sense_agreement() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "sense_agreement", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_sense_agreement(bool value) { sdaiPutAttrBN(m_instance, "sense_agreement", sdaiBOOLEAN, &value); }

        Nullable<trimming_preference> get_master_representation() { int v = getENUM("master_representation", trimming_preference_); if (v >= 0) return (trimming_preference) v; else return Nullable<trimming_preference>(); }
        void put_master_representation(trimming_preference value) { TextValue val = trimming_preference_[(int) value]; sdaiPutAttrBN(m_instance, "master_representation", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of trimmed_volume
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class trimmed_volume : public virtual solid_model
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of trimmed_volume
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        trimmed_volume(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "trimmed_volume")
        {}

                /// <summary>
                /// Create new instace of trimmed_volume and returns object of this C++ class to interact with
                /// </summary>
        static trimmed_volume Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "trimmed_volume"); assert(inst); return inst; }

        volume get_basis_volume();
        void put_basis_volume(volume inst);

        Nullable<parameter_value> get_u1() { parameter_value val = (parameter_value) 0; if (sdaiGetAttrBN(m_instance, "u1", sdaiREAL, &val)) return val; else return Nullable<parameter_value>(); }
        void put_u1(parameter_value value) { sdaiPutAttrBN(m_instance, "u1", sdaiREAL, &value); }

        Nullable<parameter_value> get_u2() { parameter_value val = (parameter_value) 0; if (sdaiGetAttrBN(m_instance, "u2", sdaiREAL, &val)) return val; else return Nullable<parameter_value>(); }
        void put_u2(parameter_value value) { sdaiPutAttrBN(m_instance, "u2", sdaiREAL, &value); }

        Nullable<parameter_value> get_v1() { parameter_value val = (parameter_value) 0; if (sdaiGetAttrBN(m_instance, "v1", sdaiREAL, &val)) return val; else return Nullable<parameter_value>(); }
        void put_v1(parameter_value value) { sdaiPutAttrBN(m_instance, "v1", sdaiREAL, &value); }

        Nullable<parameter_value> get_v2() { parameter_value val = (parameter_value) 0; if (sdaiGetAttrBN(m_instance, "v2", sdaiREAL, &val)) return val; else return Nullable<parameter_value>(); }
        void put_v2(parameter_value value) { sdaiPutAttrBN(m_instance, "v2", sdaiREAL, &value); }

        Nullable<parameter_value> get_w1() { parameter_value val = (parameter_value) 0; if (sdaiGetAttrBN(m_instance, "w1", sdaiREAL, &val)) return val; else return Nullable<parameter_value>(); }
        void put_w1(parameter_value value) { sdaiPutAttrBN(m_instance, "w1", sdaiREAL, &value); }

        Nullable<parameter_value> get_w2() { parameter_value val = (parameter_value) 0; if (sdaiGetAttrBN(m_instance, "w2", sdaiREAL, &val)) return val; else return Nullable<parameter_value>(); }
        void put_w2(parameter_value value) { sdaiPutAttrBN(m_instance, "w2", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of truncated_pyramid
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class truncated_pyramid : public virtual boolean_result
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of truncated_pyramid
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        truncated_pyramid(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "truncated_pyramid")
        {}

                /// <summary>
                /// Create new instace of truncated_pyramid and returns object of this C++ class to interact with
                /// </summary>
        static truncated_pyramid Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "truncated_pyramid"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of type_qualifier
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class type_qualifier : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of type_qualifier
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        type_qualifier(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "type_qualifier")
        {}

                /// <summary>
                /// Create new instace of type_qualifier and returns object of this C++ class to interact with
                /// </summary>
        static type_qualifier Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "type_qualifier"); assert(inst); return inst; }

        label get_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_name(label value) { sdaiPutAttrBN(m_instance, "name", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of uncertainty_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class uncertainty_measure_with_unit : public virtual measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of uncertainty_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        uncertainty_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "uncertainty_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of uncertainty_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static uncertainty_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "uncertainty_measure_with_unit"); assert(inst); return inst; }

        label get_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_name(label value) { sdaiPutAttrBN(m_instance, "name", sdaiSTRING, value); }

        text get_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_description(text value) { sdaiPutAttrBN(m_instance, "description", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of uniform_curve
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class uniform_curve : public virtual b_spline_curve
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of uniform_curve
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        uniform_curve(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "uniform_curve")
        {}

                /// <summary>
                /// Create new instace of uniform_curve and returns object of this C++ class to interact with
                /// </summary>
        static uniform_curve Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "uniform_curve"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of uniform_surface
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class uniform_surface : public virtual b_spline_surface
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of uniform_surface
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        uniform_surface(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "uniform_surface")
        {}

                /// <summary>
                /// Create new instace of uniform_surface and returns object of this C++ class to interact with
                /// </summary>
        static uniform_surface Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "uniform_surface"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of uniform_volume
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class uniform_volume : public virtual b_spline_volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of uniform_volume
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        uniform_volume(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "uniform_volume")
        {}

                /// <summary>
                /// Create new instace of uniform_volume and returns object of this C++ class to interact with
                /// </summary>
        static uniform_volume Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "uniform_volume"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of vector
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class vector : public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of vector
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        vector(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "vector")
        {}

                /// <summary>
                /// Create new instace of vector and returns object of this C++ class to interact with
                /// </summary>
        static vector Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "vector"); assert(inst); return inst; }

        direction get_orientation();
        void put_orientation(direction inst);

        Nullable<length_measure> get_magnitude() { length_measure val = (length_measure) 0; if (sdaiGetAttrBN(m_instance, "magnitude", sdaiREAL, &val)) return val; else return Nullable<length_measure>(); }
        void put_magnitude(length_measure value) { sdaiPutAttrBN(m_instance, "magnitude", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of versioned_action_request
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class versioned_action_request : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of versioned_action_request
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        versioned_action_request(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "versioned_action_request")
        {}

                /// <summary>
                /// Create new instace of versioned_action_request and returns object of this C++ class to interact with
                /// </summary>
        static versioned_action_request Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "versioned_action_request"); assert(inst); return inst; }

        identifier get_id() { identifier val = NULL; if (sdaiGetAttrBN(m_instance, "id", sdaiSTRING, &val)) return val; else return NULL; }
        void put_id(identifier value) { sdaiPutAttrBN(m_instance, "id", sdaiSTRING, value); }

        label get_version() { label val = NULL; if (sdaiGetAttrBN(m_instance, "version", sdaiSTRING, &val)) return val; else return NULL; }
        void put_version(label value) { sdaiPutAttrBN(m_instance, "version", sdaiSTRING, value); }

        text get_purpose() { text val = NULL; if (sdaiGetAttrBN(m_instance, "purpose", sdaiSTRING, &val)) return val; else return NULL; }
        void put_purpose(text value) { sdaiPutAttrBN(m_instance, "purpose", sdaiSTRING, value); }

        text get_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_description(text value) { sdaiPutAttrBN(m_instance, "description", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of vertex
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class vertex : public virtual topological_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of vertex
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        vertex(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "vertex")
        {}

                /// <summary>
                /// Create new instace of vertex and returns object of this C++ class to interact with
                /// </summary>
        static vertex Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "vertex"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of vertex_loop
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class vertex_loop : public virtual loop
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of vertex_loop
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        vertex_loop(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "vertex_loop")
        {}

                /// <summary>
                /// Create new instace of vertex_loop and returns object of this C++ class to interact with
                /// </summary>
        static vertex_loop Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "vertex_loop"); assert(inst); return inst; }

        vertex get_loop_vertex();
        void put_loop_vertex(vertex inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of vertex_point
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class vertex_point : public virtual vertex, public virtual geometric_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of vertex_point
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        vertex_point(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "vertex_point")
        {}

                /// <summary>
                /// Create new instace of vertex_point and returns object of this C++ class to interact with
                /// </summary>
        static vertex_point Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "vertex_point"); assert(inst); return inst; }

        point get_vertex_geometry();
        void put_vertex_geometry(point inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of vertex_shell
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class vertex_shell : public virtual topological_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of vertex_shell
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        vertex_shell(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "vertex_shell")
        {}

                /// <summary>
                /// Create new instace of vertex_shell and returns object of this C++ class to interact with
                /// </summary>
        static vertex_shell Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "vertex_shell"); assert(inst); return inst; }

        vertex_loop get_vertex_shell_extent();
        void put_vertex_shell_extent(vertex_loop inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of volume_measure_with_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class volume_measure_with_unit : public virtual measure_with_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of volume_measure_with_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        volume_measure_with_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "volume_measure_with_unit")
        {}

                /// <summary>
                /// Create new instace of volume_measure_with_unit and returns object of this C++ class to interact with
                /// </summary>
        static volume_measure_with_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "volume_measure_with_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of volume_unit
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class volume_unit : public virtual named_unit
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of volume_unit
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        volume_unit(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "volume_unit")
        {}

                /// <summary>
                /// Create new instace of volume_unit and returns object of this C++ class to interact with
                /// </summary>
        static volume_unit Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "volume_unit"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of wedge_volume
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class wedge_volume : public virtual volume
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of wedge_volume
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        wedge_volume(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "wedge_volume")
        {}

                /// <summary>
                /// Create new instace of wedge_volume and returns object of this C++ class to interact with
                /// </summary>
        static wedge_volume Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "wedge_volume"); assert(inst); return inst; }

        axis2_placement_3d get_position();
        void put_position(axis2_placement_3d inst);

        Nullable<positive_length_measure> get_x() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "x", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_x(positive_length_measure value) { sdaiPutAttrBN(m_instance, "x", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_y() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "y", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_y(positive_length_measure value) { sdaiPutAttrBN(m_instance, "y", sdaiREAL, &value); }

        Nullable<positive_length_measure> get_z() { positive_length_measure val = (positive_length_measure) 0; if (sdaiGetAttrBN(m_instance, "z", sdaiREAL, &val)) return val; else return Nullable<positive_length_measure>(); }
        void put_z(positive_length_measure value) { sdaiPutAttrBN(m_instance, "z", sdaiREAL, &value); }

        Nullable<length_measure> get_ltx() { length_measure val = (length_measure) 0; if (sdaiGetAttrBN(m_instance, "ltx", sdaiREAL, &val)) return val; else return Nullable<length_measure>(); }
        void put_ltx(length_measure value) { sdaiPutAttrBN(m_instance, "ltx", sdaiREAL, &value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of weld
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class weld : public virtual structural_frame_process
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of weld
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        weld(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "weld")
        {}

                /// <summary>
                /// Create new instace of weld and returns object of this C++ class to interact with
                /// </summary>
        static weld Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "weld"); assert(inst); return inst; }

        label get_electrode_type() { label val = NULL; if (sdaiGetAttrBN(m_instance, "electrode_type", sdaiSTRING, &val)) return val; else return NULL; }
        void put_electrode_type(label value) { sdaiPutAttrBN(m_instance, "electrode_type", sdaiSTRING, value); }

        Nullable<welding_type> get_weld_type() { int v = getENUM("weld_type", welding_type_); if (v >= 0) return (welding_type) v; else return Nullable<welding_type>(); }
        void put_weld_type(welding_type value) { TextValue val = welding_type_[(int) value]; sdaiPutAttrBN(m_instance, "weld_type", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of weld_arc
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class weld_arc : public virtual weld
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of weld_arc
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        weld_arc(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "weld_arc")
        {}

                /// <summary>
                /// Create new instace of weld_arc and returns object of this C++ class to interact with
                /// </summary>
        static weld_arc Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "weld_arc"); assert(inst); return inst; }

        Nullable<welding_type_arc> get_weld_arc_type() { int v = getENUM("weld_arc_type", welding_type_arc_); if (v >= 0) return (welding_type_arc) v; else return Nullable<welding_type_arc>(); }
        void put_weld_arc_type(welding_type_arc value) { TextValue val = welding_type_arc_[(int) value]; sdaiPutAttrBN(m_instance, "weld_arc_type", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of weld_beam
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class weld_beam : public virtual weld
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of weld_beam
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        weld_beam(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "weld_beam")
        {}

                /// <summary>
                /// Create new instace of weld_beam and returns object of this C++ class to interact with
                /// </summary>
        static weld_beam Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "weld_beam"); assert(inst); return inst; }

        Nullable<welding_type_beam> get_weld_beam_type() { int v = getENUM("weld_beam_type", welding_type_beam_); if (v >= 0) return (welding_type_beam) v; else return Nullable<welding_type_beam>(); }
        void put_weld_beam_type(welding_type_beam value) { TextValue val = welding_type_beam_[(int) value]; sdaiPutAttrBN(m_instance, "weld_beam_type", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of weld_gas
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class weld_gas : public virtual weld
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of weld_gas
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        weld_gas(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "weld_gas")
        {}

                /// <summary>
                /// Create new instace of weld_gas and returns object of this C++ class to interact with
                /// </summary>
        static weld_gas Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "weld_gas"); assert(inst); return inst; }

        Nullable<welding_type_gas> get_weld_gas_type() { int v = getENUM("weld_gas_type", welding_type_gas_); if (v >= 0) return (welding_type_gas) v; else return Nullable<welding_type_gas>(); }
        void put_weld_gas_type(welding_type_gas value) { TextValue val = welding_type_gas_[(int) value]; sdaiPutAttrBN(m_instance, "weld_gas_type", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of weld_mechanism
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class weld_mechanism : public virtual structural_frame_product
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of weld_mechanism
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        weld_mechanism(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "weld_mechanism")
        {}

                /// <summary>
                /// Create new instace of weld_mechanism and returns object of this C++ class to interact with
                /// </summary>
        static weld_mechanism Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "weld_mechanism"); assert(inst); return inst; }

        Nullable<weld_type> get_weld_mechanism_type() { int v = getENUM("weld_mechanism_type", weld_type_); if (v >= 0) return (weld_type) v; else return Nullable<weld_type>(); }
        void put_weld_mechanism_type(weld_type value) { TextValue val = weld_type_[(int) value]; sdaiPutAttrBN(m_instance, "weld_mechanism_type", sdaiENUM, val); }

        Nullable<weld_penetration> get_penetration() { int v = getENUM("penetration", weld_penetration_); if (v >= 0) return (weld_penetration) v; else return Nullable<weld_penetration>(); }
        void put_penetration(weld_penetration value) { TextValue val = weld_penetration_[(int) value]; sdaiPutAttrBN(m_instance, "penetration", sdaiENUM, val); }

        positive_length_measure_with_unit get_weld_dimension();
        void put_weld_dimension(positive_length_measure_with_unit inst);

        label get_weld_dimension_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "weld_dimension_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_weld_dimension_name(label value) { sdaiPutAttrBN(m_instance, "weld_dimension_name", sdaiSTRING, value); }

        pressure_measure_with_unit get_weld_design_strength();
        void put_weld_design_strength(pressure_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of weld_mechanism_complex
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class weld_mechanism_complex : public virtual weld_mechanism
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of weld_mechanism_complex
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        weld_mechanism_complex(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "weld_mechanism_complex")
        {}

                /// <summary>
                /// Create new instace of weld_mechanism_complex and returns object of this C++ class to interact with
                /// </summary>
        static weld_mechanism_complex Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "weld_mechanism_complex"); assert(inst); return inst; }

        shape_representation_with_units get_weld_shape();
        void put_weld_shape(shape_representation_with_units inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of weld_mechanism_fillet
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class weld_mechanism_fillet : public virtual weld_mechanism
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of weld_mechanism_fillet
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        weld_mechanism_fillet(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "weld_mechanism_fillet")
        {}

                /// <summary>
                /// Create new instace of weld_mechanism_fillet and returns object of this C++ class to interact with
                /// </summary>
        static weld_mechanism_fillet Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "weld_mechanism_fillet"); assert(inst); return inst; }

        Nullable<weld_sidedness> get_sidedness() { int v = getENUM("sidedness", weld_sidedness_); if (v >= 0) return (weld_sidedness) v; else return Nullable<weld_sidedness>(); }
        void put_sidedness(weld_sidedness value) { TextValue val = weld_sidedness_[(int) value]; sdaiPutAttrBN(m_instance, "sidedness", sdaiENUM, val); }

        Nullable<weld_surface_shape> get_surface_shape() { int v = getENUM("surface_shape", weld_surface_shape_); if (v >= 0) return (weld_surface_shape) v; else return Nullable<weld_surface_shape>(); }
        void put_surface_shape(weld_surface_shape value) { TextValue val = weld_surface_shape_[(int) value]; sdaiPutAttrBN(m_instance, "surface_shape", sdaiENUM, val); }

        Nullable<weld_configuration> get_joint_configuration() { int v = getENUM("joint_configuration", weld_configuration_); if (v >= 0) return (weld_configuration) v; else return Nullable<weld_configuration>(); }
        void put_joint_configuration(weld_configuration value) { TextValue val = weld_configuration_[(int) value]; sdaiPutAttrBN(m_instance, "joint_configuration", sdaiENUM, val); }

        positive_length_measure_with_unit get_leg_length_y();
        void put_leg_length_y(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_leg_length_z();
        void put_leg_length_z(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of weld_mechanism_fillet_continuous
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class weld_mechanism_fillet_continuous : public virtual weld_mechanism_fillet
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of weld_mechanism_fillet_continuous
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        weld_mechanism_fillet_continuous(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "weld_mechanism_fillet_continuous")
        {}

                /// <summary>
                /// Create new instace of weld_mechanism_fillet_continuous and returns object of this C++ class to interact with
                /// </summary>
        static weld_mechanism_fillet_continuous Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "weld_mechanism_fillet_continuous"); assert(inst); return inst; }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of weld_mechanism_fillet_intermittent
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class weld_mechanism_fillet_intermittent : public virtual weld_mechanism_fillet
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of weld_mechanism_fillet_intermittent
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        weld_mechanism_fillet_intermittent(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "weld_mechanism_fillet_intermittent")
        {}

                /// <summary>
                /// Create new instace of weld_mechanism_fillet_intermittent and returns object of this C++ class to interact with
                /// </summary>
        static weld_mechanism_fillet_intermittent Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "weld_mechanism_fillet_intermittent"); assert(inst); return inst; }

        Nullable<weld_intermittent_rule> get_end_rules() { int v = getENUM("end_rules", weld_intermittent_rule_); if (v >= 0) return (weld_intermittent_rule) v; else return Nullable<weld_intermittent_rule>(); }
        void put_end_rules(weld_intermittent_rule value) { TextValue val = weld_intermittent_rule_[(int) value]; sdaiPutAttrBN(m_instance, "end_rules", sdaiENUM, val); }

        Nullable<weld_intermittent_rule> get_cutout_rules() { int v = getENUM("cutout_rules", weld_intermittent_rule_); if (v >= 0) return (weld_intermittent_rule) v; else return Nullable<weld_intermittent_rule>(); }
        void put_cutout_rules(weld_intermittent_rule value) { TextValue val = weld_intermittent_rule_[(int) value]; sdaiPutAttrBN(m_instance, "cutout_rules", sdaiENUM, val); }

        Nullable<weld_intermittent_rule> get_penetration_rules() { int v = getENUM("penetration_rules", weld_intermittent_rule_); if (v >= 0) return (weld_intermittent_rule) v; else return Nullable<weld_intermittent_rule>(); }
        void put_penetration_rules(weld_intermittent_rule value) { TextValue val = weld_intermittent_rule_[(int) value]; sdaiPutAttrBN(m_instance, "penetration_rules", sdaiENUM, val); }

        positive_length_measure_with_unit get_fillet_weld_length();
        void put_fillet_weld_length(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_fillet_weld_spacing();
        void put_fillet_weld_spacing(positive_length_measure_with_unit inst);

        Nullable<weld_alignment> get_fillet_alignment() { int v = getENUM("fillet_alignment", weld_alignment_); if (v >= 0) return (weld_alignment) v; else return Nullable<weld_alignment>(); }
        void put_fillet_alignment(weld_alignment value) { TextValue val = weld_alignment_[(int) value]; sdaiPutAttrBN(m_instance, "fillet_alignment", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of weld_mechanism_groove
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class weld_mechanism_groove : public virtual weld_mechanism
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of weld_mechanism_groove
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        weld_mechanism_groove(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "weld_mechanism_groove")
        {}

                /// <summary>
                /// Create new instace of weld_mechanism_groove and returns object of this C++ class to interact with
                /// </summary>
        static weld_mechanism_groove Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "weld_mechanism_groove"); assert(inst); return inst; }

        Nullable<weld_sidedness> get_sidedness() { int v = getENUM("sidedness", weld_sidedness_); if (v >= 0) return (weld_sidedness) v; else return Nullable<weld_sidedness>(); }
        void put_sidedness(weld_sidedness value) { TextValue val = weld_sidedness_[(int) value]; sdaiPutAttrBN(m_instance, "sidedness", sdaiENUM, val); }

        Nullable<weld_backing_type> get_backing_type() { int v = getENUM("backing_type", weld_backing_type_); if (v >= 0) return (weld_backing_type) v; else return Nullable<weld_backing_type>(); }
        void put_backing_type(weld_backing_type value) { TextValue val = weld_backing_type_[(int) value]; sdaiPutAttrBN(m_instance, "backing_type", sdaiENUM, val); }

        Nullable<bool> get_weld_joint_spacer() { bool val = (bool) 0; if (sdaiGetAttrBN(m_instance, "weld_joint_spacer", sdaiBOOLEAN, &val)) return val; else return Nullable<bool>(); }
        void put_weld_joint_spacer(bool value) { sdaiPutAttrBN(m_instance, "weld_joint_spacer", sdaiBOOLEAN, &value); }

        Nullable<weld_surface_shape> get_surface_shape() { int v = getENUM("surface_shape", weld_surface_shape_); if (v >= 0) return (weld_surface_shape) v; else return Nullable<weld_surface_shape>(); }
        void put_surface_shape(weld_surface_shape value) { TextValue val = weld_surface_shape_[(int) value]; sdaiPutAttrBN(m_instance, "surface_shape", sdaiENUM, val); }

        Nullable<weld_configuration> get_joint_configuration() { int v = getENUM("joint_configuration", weld_configuration_); if (v >= 0) return (weld_configuration) v; else return Nullable<weld_configuration>(); }
        void put_joint_configuration(weld_configuration value) { TextValue val = weld_configuration_[(int) value]; sdaiPutAttrBN(m_instance, "joint_configuration", sdaiENUM, val); }

        positive_length_measure_with_unit get_root_gap();
        void put_root_gap(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_root_face();
        void put_root_face(positive_length_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of weld_mechanism_groove_beveled
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class weld_mechanism_groove_beveled : public virtual weld_mechanism_groove
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of weld_mechanism_groove_beveled
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        weld_mechanism_groove_beveled(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "weld_mechanism_groove_beveled")
        {}

                /// <summary>
                /// Create new instace of weld_mechanism_groove_beveled and returns object of this C++ class to interact with
                /// </summary>
        static weld_mechanism_groove_beveled Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "weld_mechanism_groove_beveled"); assert(inst); return inst; }

        Nullable<weld_shape_bevel> get_endcut_shape() { int v = getENUM("endcut_shape", weld_shape_bevel_); if (v >= 0) return (weld_shape_bevel) v; else return Nullable<weld_shape_bevel>(); }
        void put_endcut_shape(weld_shape_bevel value) { TextValue val = weld_shape_bevel_[(int) value]; sdaiPutAttrBN(m_instance, "endcut_shape", sdaiENUM, val); }

        plane_angle_measure_with_unit get_groove_angle();
        void put_groove_angle(plane_angle_measure_with_unit inst);

        positive_length_measure_with_unit get_groove_depth();
        void put_groove_depth(positive_length_measure_with_unit inst);

        positive_length_measure_with_unit get_groove_radius();
        void put_groove_radius(positive_length_measure_with_unit inst);

        Nullable<weld_taper_type> get_taper() { int v = getENUM("taper", weld_taper_type_); if (v >= 0) return (weld_taper_type) v; else return Nullable<weld_taper_type>(); }
        void put_taper(weld_taper_type value) { TextValue val = weld_taper_type_[(int) value]; sdaiPutAttrBN(m_instance, "taper", sdaiENUM, val); }

        plane_angle_measure_with_unit get_taper_angle();
        void put_taper_angle(plane_angle_measure_with_unit inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of weld_mechanism_groove_butt
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class weld_mechanism_groove_butt : public virtual weld_mechanism_groove
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of weld_mechanism_groove_butt
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        weld_mechanism_groove_butt(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "weld_mechanism_groove_butt")
        {}

                /// <summary>
                /// Create new instace of weld_mechanism_groove_butt and returns object of this C++ class to interact with
                /// </summary>
        static weld_mechanism_groove_butt Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "weld_mechanism_groove_butt"); assert(inst); return inst; }

        Nullable<weld_shape_butt> get_face_shape() { int v = getENUM("face_shape", weld_shape_butt_); if (v >= 0) return (weld_shape_butt) v; else return Nullable<weld_shape_butt>(); }
        void put_face_shape(weld_shape_butt value) { TextValue val = weld_shape_butt_[(int) value]; sdaiPutAttrBN(m_instance, "face_shape", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of weld_mechanism_prismatic
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class weld_mechanism_prismatic : public virtual weld_mechanism
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of weld_mechanism_prismatic
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        weld_mechanism_prismatic(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "weld_mechanism_prismatic")
        {}

                /// <summary>
                /// Create new instace of weld_mechanism_prismatic and returns object of this C++ class to interact with
                /// </summary>
        static weld_mechanism_prismatic Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "weld_mechanism_prismatic"); assert(inst); return inst; }

        //TList may be list_of_section_profile or list of converible elements
        template <typename TList> void get_cross_sections(TList& lst) { list_of_section_profileSerializer<TList> sr; sr.FromAttr(lst, m_instance, "cross_sections"); }

        //TList may be list_of_section_profile or list of converible elements
        template <typename TList> void put_cross_sections(TList& lst) { list_of_section_profileSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "cross_sections"); }

        //TArrayElem[] may be section_profile[] or array of convertible elements
        template <typename TArrayElem> void put_cross_sections(TArrayElem arr[], size_t n) { list_of_section_profile lst; ArrayToList(arr, n, lst); put_cross_sections(lst); }

        //TList may be list_of_point_on_curve or list of converible elements
        template <typename TList> void get_points_defining_weld_path(TList& lst) { list_of_point_on_curveSerializer<TList> sr; sr.FromAttr(lst, m_instance, "points_defining_weld_path"); }

        //TList may be list_of_point_on_curve or list of converible elements
        template <typename TList> void put_points_defining_weld_path(TList& lst) { list_of_point_on_curveSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "points_defining_weld_path"); }

        //TArrayElem[] may be point_on_curve[] or array of convertible elements
        template <typename TArrayElem> void put_points_defining_weld_path(TArrayElem arr[], size_t n) { list_of_point_on_curve lst; ArrayToList(arr, n, lst); put_points_defining_weld_path(lst); }

        //TList may be list_of_orientation_select or list of converible elements
        template <typename TList> void get_section_orientations(TList& lst) { list_of_orientation_selectSerializer<TList> sr; sr.FromAttr(lst, m_instance, "section_orientations"); }

        //TList may be list_of_orientation_select or list of converible elements
        template <typename TList> void put_section_orientations(TList& lst) { list_of_orientation_selectSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "section_orientations"); }

        Nullable<weld_configuration> get_joint_configuration() { int v = getENUM("joint_configuration", weld_configuration_); if (v >= 0) return (weld_configuration) v; else return Nullable<weld_configuration>(); }
        void put_joint_configuration(weld_configuration value) { TextValue val = weld_configuration_[(int) value]; sdaiPutAttrBN(m_instance, "joint_configuration", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of weld_mechanism_spot_seam
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class weld_mechanism_spot_seam : public virtual weld_mechanism
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of weld_mechanism_spot_seam
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        weld_mechanism_spot_seam(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "weld_mechanism_spot_seam")
        {}

                /// <summary>
                /// Create new instace of weld_mechanism_spot_seam and returns object of this C++ class to interact with
                /// </summary>
        static weld_mechanism_spot_seam Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "weld_mechanism_spot_seam"); assert(inst); return inst; }

        Nullable<weld_configuration> get_joint_configuration() { int v = getENUM("joint_configuration", weld_configuration_); if (v >= 0) return (weld_configuration) v; else return Nullable<weld_configuration>(); }
        void put_joint_configuration(weld_configuration value) { TextValue val = weld_configuration_[(int) value]; sdaiPutAttrBN(m_instance, "joint_configuration", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of weld_other
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class weld_other : public virtual weld
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of weld_other
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        weld_other(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "weld_other")
        {}

                /// <summary>
                /// Create new instace of weld_other and returns object of this C++ class to interact with
                /// </summary>
        static weld_other Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "weld_other"); assert(inst); return inst; }

        Nullable<welding_type_other> get_weld_other_type() { int v = getENUM("weld_other_type", welding_type_other_); if (v >= 0) return (welding_type_other) v; else return Nullable<welding_type_other>(); }
        void put_weld_other_type(welding_type_other value) { TextValue val = welding_type_other_[(int) value]; sdaiPutAttrBN(m_instance, "weld_other_type", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of weld_pressure
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class weld_pressure : public virtual weld
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of weld_pressure
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        weld_pressure(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "weld_pressure")
        {}

                /// <summary>
                /// Create new instace of weld_pressure and returns object of this C++ class to interact with
                /// </summary>
        static weld_pressure Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "weld_pressure"); assert(inst); return inst; }

        Nullable<welding_type_pressure> get_weld_pressure_type() { int v = getENUM("weld_pressure_type", welding_type_pressure_); if (v >= 0) return (welding_type_pressure) v; else return Nullable<welding_type_pressure>(); }
        void put_weld_pressure_type(welding_type_pressure value) { TextValue val = welding_type_pressure_[(int) value]; sdaiPutAttrBN(m_instance, "weld_pressure_type", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of weld_resistance
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class weld_resistance : public virtual weld
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of weld_resistance
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        weld_resistance(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "weld_resistance")
        {}

                /// <summary>
                /// Create new instace of weld_resistance and returns object of this C++ class to interact with
                /// </summary>
        static weld_resistance Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "weld_resistance"); assert(inst); return inst; }

        Nullable<welding_type_resistance> get_weld_resistance_type() { int v = getENUM("weld_resistance_type", welding_type_resistance_); if (v >= 0) return (welding_type_resistance) v; else return Nullable<welding_type_resistance>(); }
        void put_weld_resistance_type(welding_type_resistance value) { TextValue val = welding_type_resistance_[(int) value]; sdaiPutAttrBN(m_instance, "weld_resistance_type", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of weld_stud
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class weld_stud : public virtual weld
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of weld_stud
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        weld_stud(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "weld_stud")
        {}

                /// <summary>
                /// Create new instace of weld_stud and returns object of this C++ class to interact with
                /// </summary>
        static weld_stud Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "weld_stud"); assert(inst); return inst; }

        Nullable<welding_type_stud> get_weld_stud_type() { int v = getENUM("weld_stud_type", welding_type_stud_); if (v >= 0) return (welding_type_stud) v; else return Nullable<welding_type_stud>(); }
        void put_weld_stud_type(welding_type_stud value) { TextValue val = welding_type_stud_[(int) value]; sdaiPutAttrBN(m_instance, "weld_stud_type", sdaiENUM, val); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of wire_shell
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class wire_shell : public virtual topological_representation_item
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of wire_shell
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        wire_shell(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "wire_shell")
        {}

                /// <summary>
                /// Create new instace of wire_shell and returns object of this C++ class to interact with
                /// </summary>
        static wire_shell Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "wire_shell"); assert(inst); return inst; }

        //TList may be set_of_loop or list of converible elements
        template <typename TList> void get_wire_shell_extent(TList& lst) { set_of_loopSerializer<TList> sr; sr.FromAttr(lst, m_instance, "wire_shell_extent"); }

        //TList may be set_of_loop or list of converible elements
        template <typename TList> void put_wire_shell_extent(TList& lst) { set_of_loopSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "wire_shell_extent"); }

        //TArrayElem[] may be loop[] or array of convertible elements
        template <typename TArrayElem> void put_wire_shell_extent(TArrayElem arr[], size_t n) { set_of_loop lst; ArrayToList(arr, n, lst); put_wire_shell_extent(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of zone
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class zone : public virtual Entity
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of zone
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        zone(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "zone")
        {}


        label get_zone_name() { label val = NULL; if (sdaiGetAttrBN(m_instance, "zone_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_zone_name(label value) { sdaiPutAttrBN(m_instance, "zone_name", sdaiSTRING, value); }

        text get_zone_description() { text val = NULL; if (sdaiGetAttrBN(m_instance, "zone_description", sdaiSTRING, &val)) return val; else return NULL; }
        void put_zone_description(text value) { sdaiPutAttrBN(m_instance, "zone_description", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of zone_bounded
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class zone_bounded : public virtual zone
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of zone_bounded
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        zone_bounded(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "zone_bounded")
        {}

                /// <summary>
                /// Create new instace of zone_bounded and returns object of this C++ class to interact with
                /// </summary>
        static zone_bounded Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "zone_bounded"); assert(inst); return inst; }

        //TList may be set_of_gridline or list of converible elements
        template <typename TList> void get_bounding_gridlines(TList& lst) { set_of_gridlineSerializer<TList> sr; sr.FromAttr(lst, m_instance, "bounding_gridlines"); }

        //TList may be set_of_gridline or list of converible elements
        template <typename TList> void put_bounding_gridlines(TList& lst) { set_of_gridlineSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "bounding_gridlines"); }

        //TArrayElem[] may be gridline[] or array of convertible elements
        template <typename TArrayElem> void put_bounding_gridlines(TArrayElem arr[], size_t n) { set_of_gridline lst; ArrayToList(arr, n, lst); put_bounding_gridlines(lst); }

        //TList may be set_of_grid_level or list of converible elements
        template <typename TList> void get_bounding_levels(TList& lst) { set_of_grid_levelSerializer<TList> sr; sr.FromAttr(lst, m_instance, "bounding_levels"); }

        //TList may be set_of_grid_level or list of converible elements
        template <typename TList> void put_bounding_levels(TList& lst) { set_of_grid_levelSerializer<TList> sr;  sr.ToSdaiAggr(lst, m_instance, "bounding_levels"); }

        //TArrayElem[] may be grid_level[] or array of convertible elements
        template <typename TArrayElem> void put_bounding_levels(TArrayElem arr[], size_t n) { set_of_grid_level lst; ArrayToList(arr, n, lst); put_bounding_levels(lst); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of zone_of_building
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class zone_of_building : public virtual zone
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of zone_of_building
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        zone_of_building(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "zone_of_building")
        {}

                /// <summary>
                /// Create new instace of zone_of_building and returns object of this C++ class to interact with
                /// </summary>
        static zone_of_building Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "zone_of_building"); assert(inst); return inst; }

        building get_zone_for_building();
        void put_zone_for_building(building inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of zone_of_building_storey
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class zone_of_building_storey : public virtual zone_of_building
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of zone_of_building_storey
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        zone_of_building_storey(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "zone_of_building_storey")
        {}

                /// <summary>
                /// Create new instace of zone_of_building_storey and returns object of this C++ class to interact with
                /// </summary>
        static zone_of_building_storey Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "zone_of_building_storey"); assert(inst); return inst; }

        positive_length_measure_with_unit get_storey_height();
        void put_storey_height(positive_length_measure_with_unit inst);

        length_measure_with_unit get_storey_level();
        void put_storey_level(length_measure_with_unit inst);

        text get_datum_name() { text val = NULL; if (sdaiGetAttrBN(m_instance, "datum_name", sdaiSTRING, &val)) return val; else return NULL; }
        void put_datum_name(text value) { sdaiPutAttrBN(m_instance, "datum_name", sdaiSTRING, value); }
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of zone_of_project
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class zone_of_project : public virtual zone
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of zone_of_project
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        zone_of_project(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "zone_of_project")
        {}

                /// <summary>
                /// Create new instace of zone_of_project and returns object of this C++ class to interact with
                /// </summary>
        static zone_of_project Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "zone_of_project"); assert(inst); return inst; }

        project get_zone_for_project();
        void put_zone_for_project(project inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of zone_of_site
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class zone_of_site : public virtual zone
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of zone_of_site
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        zone_of_site(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "zone_of_site")
        {}

                /// <summary>
                /// Create new instace of zone_of_site and returns object of this C++ class to interact with
                /// </summary>
        static zone_of_site Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "zone_of_site"); assert(inst); return inst; }

        site get_zone_for_site();
        void put_zone_for_site(site inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of zone_of_structure
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class zone_of_structure : public virtual zone
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of zone_of_structure
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        zone_of_structure(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "zone_of_structure")
        {}

                /// <summary>
                /// Create new instace of zone_of_structure and returns object of this C++ class to interact with
                /// </summary>
        static zone_of_structure Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "zone_of_structure"); assert(inst); return inst; }

        structure get_zone_for_structure();
        void put_zone_for_structure(structure inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of zone_of_structure_sequence
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class zone_of_structure_sequence : public virtual zone_of_structure
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of zone_of_structure_sequence
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        zone_of_structure_sequence(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "zone_of_structure_sequence")
        {}

                /// <summary>
                /// Create new instace of zone_of_structure_sequence and returns object of this C++ class to interact with
                /// </summary>
        static zone_of_structure_sequence Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "zone_of_structure_sequence"); assert(inst); return inst; }

        zone_of_structure get_parent_zone();
        void put_parent_zone(zone_of_structure inst);
    };


        /// <summary>
        /// Provides utility methods to interact with an instnace of zone_of_structure_sequence_lot
        /// You also can use object of this C++ class instead of IntValue handle of the OWL instance in any place where the handle is required
        /// </summary>
    class zone_of_structure_sequence_lot : public virtual zone_of_structure_sequence
    {
    public:
        /// <summary>
        /// Constructs object of this C++ class that wraps existing SdaiInstance of zone_of_structure_sequence_lot
        /// </summary>
        /// <param name="instance">An instance to interact with</param>
        zone_of_structure_sequence_lot(SdaiInstance instance = NULL, TextValue entityName = NULL)
            : Entity(instance, entityName ? entityName : "zone_of_structure_sequence_lot")
        {}

                /// <summary>
                /// Create new instace of zone_of_structure_sequence_lot and returns object of this C++ class to interact with
                /// </summary>
        static zone_of_structure_sequence_lot Create(SdaiModel model) { SdaiInstance inst = sdaiCreateInstanceBN(model, "zone_of_structure_sequence_lot"); assert(inst); return inst; }
    };

    inline located_assembly assembly_component_select::get_located_assembly() { return getEntityInstance("LOCATED_ASSEMBLY"); }
    inline void assembly_component_select::put_located_assembly(located_assembly inst) { putEntityInstance("LOCATED_ASSEMBLY", inst); }
    inline located_part assembly_component_select::get_located_part() { return getEntityInstance("LOCATED_PART"); }
    inline void assembly_component_select::put_located_part(located_part inst) { putEntityInstance("LOCATED_PART", inst); }
    inline located_feature assembly_component_select::get_located_feature() { return getEntityInstance("LOCATED_FEATURE"); }
    inline void assembly_component_select::put_located_feature(located_feature inst) { putEntityInstance("LOCATED_FEATURE", inst); }
    inline located_joint_system assembly_component_select::get_located_joint_system() { return getEntityInstance("LOCATED_JOINT_SYSTEM"); }
    inline void assembly_component_select::put_located_joint_system(located_joint_system inst) { putEntityInstance("LOCATED_JOINT_SYSTEM", inst); }
    inline located_assembly assembly_component_select_get::get_located_assembly() { return getEntityInstance("LOCATED_ASSEMBLY"); }
    inline located_part assembly_component_select_get::get_located_part() { return getEntityInstance("LOCATED_PART"); }
    inline located_feature assembly_component_select_get::get_located_feature() { return getEntityInstance("LOCATED_FEATURE"); }
    inline located_joint_system assembly_component_select_get::get_located_joint_system() { return getEntityInstance("LOCATED_JOINT_SYSTEM"); }
    inline void assembly_component_select_put::put_located_assembly(located_assembly inst) { putEntityInstance("LOCATED_ASSEMBLY", inst); }
    inline void assembly_component_select_put::put_located_part(located_part inst) { putEntityInstance("LOCATED_PART", inst); }
    inline void assembly_component_select_put::put_located_feature(located_feature inst) { putEntityInstance("LOCATED_FEATURE", inst); }
    inline void assembly_component_select_put::put_located_joint_system(located_joint_system inst) { putEntityInstance("LOCATED_JOINT_SYSTEM", inst); }
    inline axis2_placement_2d axis2_placement::get_axis2_placement_2d() { return getEntityInstance("AXIS2_PLACEMENT_2D"); }
    inline void axis2_placement::put_axis2_placement_2d(axis2_placement_2d inst) { putEntityInstance("AXIS2_PLACEMENT_2D", inst); }
    inline axis2_placement_3d axis2_placement::get_axis2_placement_3d() { return getEntityInstance("AXIS2_PLACEMENT_3D"); }
    inline void axis2_placement::put_axis2_placement_3d(axis2_placement_3d inst) { putEntityInstance("AXIS2_PLACEMENT_3D", inst); }
    inline axis2_placement_2d axis2_placement_get::get_axis2_placement_2d() { return getEntityInstance("AXIS2_PLACEMENT_2D"); }
    inline axis2_placement_3d axis2_placement_get::get_axis2_placement_3d() { return getEntityInstance("AXIS2_PLACEMENT_3D"); }
    inline void axis2_placement_put::put_axis2_placement_2d(axis2_placement_2d inst) { putEntityInstance("AXIS2_PLACEMENT_2D", inst); }
    inline void axis2_placement_put::put_axis2_placement_3d(axis2_placement_3d inst) { putEntityInstance("AXIS2_PLACEMENT_3D", inst); }
    inline sphere csg_primitive::get_sphere() { return getEntityInstance("SPHERE"); }
    inline void csg_primitive::put_sphere(sphere inst) { putEntityInstance("SPHERE", inst); }
    inline ellipsoid csg_primitive::get_ellipsoid() { return getEntityInstance("ELLIPSOID"); }
    inline void csg_primitive::put_ellipsoid(ellipsoid inst) { putEntityInstance("ELLIPSOID", inst); }
    inline block csg_primitive::get_block() { return getEntityInstance("BLOCK"); }
    inline void csg_primitive::put_block(block inst) { putEntityInstance("BLOCK", inst); }
    inline right_angular_wedge csg_primitive::get_right_angular_wedge() { return getEntityInstance("RIGHT_ANGULAR_WEDGE"); }
    inline void csg_primitive::put_right_angular_wedge(right_angular_wedge inst) { putEntityInstance("RIGHT_ANGULAR_WEDGE", inst); }
    inline faceted_primitive csg_primitive::get_faceted_primitive() { return getEntityInstance("FACETED_PRIMITIVE"); }
    inline void csg_primitive::put_faceted_primitive(faceted_primitive inst) { putEntityInstance("FACETED_PRIMITIVE", inst); }
    inline rectangular_pyramid csg_primitive::get_rectangular_pyramid() { return getEntityInstance("RECTANGULAR_PYRAMID"); }
    inline void csg_primitive::put_rectangular_pyramid(rectangular_pyramid inst) { putEntityInstance("RECTANGULAR_PYRAMID", inst); }
    inline torus csg_primitive::get_torus() { return getEntityInstance("TORUS"); }
    inline void csg_primitive::put_torus(torus inst) { putEntityInstance("TORUS", inst); }
    inline right_circular_cone csg_primitive::get_right_circular_cone() { return getEntityInstance("RIGHT_CIRCULAR_CONE"); }
    inline void csg_primitive::put_right_circular_cone(right_circular_cone inst) { putEntityInstance("RIGHT_CIRCULAR_CONE", inst); }
    inline eccentric_cone csg_primitive::get_eccentric_cone() { return getEntityInstance("ECCENTRIC_CONE"); }
    inline void csg_primitive::put_eccentric_cone(eccentric_cone inst) { putEntityInstance("ECCENTRIC_CONE", inst); }
    inline right_circular_cylinder csg_primitive::get_right_circular_cylinder() { return getEntityInstance("RIGHT_CIRCULAR_CYLINDER"); }
    inline void csg_primitive::put_right_circular_cylinder(right_circular_cylinder inst) { putEntityInstance("RIGHT_CIRCULAR_CYLINDER", inst); }
    inline cyclide_segment_solid csg_primitive::get_cyclide_segment_solid() { return getEntityInstance("CYCLIDE_SEGMENT_SOLID"); }
    inline void csg_primitive::put_cyclide_segment_solid(cyclide_segment_solid inst) { putEntityInstance("CYCLIDE_SEGMENT_SOLID", inst); }
    inline primitive_2d csg_primitive::get_primitive_2d() { return getEntityInstance("PRIMITIVE_2D"); }
    inline void csg_primitive::put_primitive_2d(primitive_2d inst) { putEntityInstance("PRIMITIVE_2D", inst); }
    inline sphere csg_primitive_get::get_sphere() { return getEntityInstance("SPHERE"); }
    inline ellipsoid csg_primitive_get::get_ellipsoid() { return getEntityInstance("ELLIPSOID"); }
    inline block csg_primitive_get::get_block() { return getEntityInstance("BLOCK"); }
    inline right_angular_wedge csg_primitive_get::get_right_angular_wedge() { return getEntityInstance("RIGHT_ANGULAR_WEDGE"); }
    inline faceted_primitive csg_primitive_get::get_faceted_primitive() { return getEntityInstance("FACETED_PRIMITIVE"); }
    inline rectangular_pyramid csg_primitive_get::get_rectangular_pyramid() { return getEntityInstance("RECTANGULAR_PYRAMID"); }
    inline torus csg_primitive_get::get_torus() { return getEntityInstance("TORUS"); }
    inline right_circular_cone csg_primitive_get::get_right_circular_cone() { return getEntityInstance("RIGHT_CIRCULAR_CONE"); }
    inline eccentric_cone csg_primitive_get::get_eccentric_cone() { return getEntityInstance("ECCENTRIC_CONE"); }
    inline right_circular_cylinder csg_primitive_get::get_right_circular_cylinder() { return getEntityInstance("RIGHT_CIRCULAR_CYLINDER"); }
    inline cyclide_segment_solid csg_primitive_get::get_cyclide_segment_solid() { return getEntityInstance("CYCLIDE_SEGMENT_SOLID"); }
    inline primitive_2d csg_primitive_get::get_primitive_2d() { return getEntityInstance("PRIMITIVE_2D"); }
    inline void csg_primitive_put::put_sphere(sphere inst) { putEntityInstance("SPHERE", inst); }
    inline void csg_primitive_put::put_ellipsoid(ellipsoid inst) { putEntityInstance("ELLIPSOID", inst); }
    inline void csg_primitive_put::put_block(block inst) { putEntityInstance("BLOCK", inst); }
    inline void csg_primitive_put::put_right_angular_wedge(right_angular_wedge inst) { putEntityInstance("RIGHT_ANGULAR_WEDGE", inst); }
    inline void csg_primitive_put::put_faceted_primitive(faceted_primitive inst) { putEntityInstance("FACETED_PRIMITIVE", inst); }
    inline void csg_primitive_put::put_rectangular_pyramid(rectangular_pyramid inst) { putEntityInstance("RECTANGULAR_PYRAMID", inst); }
    inline void csg_primitive_put::put_torus(torus inst) { putEntityInstance("TORUS", inst); }
    inline void csg_primitive_put::put_right_circular_cone(right_circular_cone inst) { putEntityInstance("RIGHT_CIRCULAR_CONE", inst); }
    inline void csg_primitive_put::put_eccentric_cone(eccentric_cone inst) { putEntityInstance("ECCENTRIC_CONE", inst); }
    inline void csg_primitive_put::put_right_circular_cylinder(right_circular_cylinder inst) { putEntityInstance("RIGHT_CIRCULAR_CYLINDER", inst); }
    inline void csg_primitive_put::put_cyclide_segment_solid(cyclide_segment_solid inst) { putEntityInstance("CYCLIDE_SEGMENT_SOLID", inst); }
    inline void csg_primitive_put::put_primitive_2d(primitive_2d inst) { putEntityInstance("PRIMITIVE_2D", inst); }
    inline solid_model boolean_operand::get_solid_model() { return getEntityInstance("SOLID_MODEL"); }
    inline void boolean_operand::put_solid_model(solid_model inst) { putEntityInstance("SOLID_MODEL", inst); }
    inline half_space_solid boolean_operand::get_half_space_solid() { return getEntityInstance("HALF_SPACE_SOLID"); }
    inline void boolean_operand::put_half_space_solid(half_space_solid inst) { putEntityInstance("HALF_SPACE_SOLID", inst); }
    inline boolean_result boolean_operand::get_boolean_result() { return getEntityInstance("BOOLEAN_RESULT"); }
    inline void boolean_operand::put_boolean_result(boolean_result inst) { putEntityInstance("BOOLEAN_RESULT", inst); }
    inline half_space_2d boolean_operand::get_half_space_2d() { return getEntityInstance("HALF_SPACE_2D"); }
    inline void boolean_operand::put_half_space_2d(half_space_2d inst) { putEntityInstance("HALF_SPACE_2D", inst); }
    inline solid_model boolean_operand_get::get_solid_model() { return getEntityInstance("SOLID_MODEL"); }
    inline half_space_solid boolean_operand_get::get_half_space_solid() { return getEntityInstance("HALF_SPACE_SOLID"); }
    inline boolean_result boolean_operand_get::get_boolean_result() { return getEntityInstance("BOOLEAN_RESULT"); }
    inline half_space_2d boolean_operand_get::get_half_space_2d() { return getEntityInstance("HALF_SPACE_2D"); }
    inline void boolean_operand_put::put_solid_model(solid_model inst) { putEntityInstance("SOLID_MODEL", inst); }
    inline void boolean_operand_put::put_half_space_solid(half_space_solid inst) { putEntityInstance("HALF_SPACE_SOLID", inst); }
    inline void boolean_operand_put::put_boolean_result(boolean_result inst) { putEntityInstance("BOOLEAN_RESULT", inst); }
    inline void boolean_operand_put::put_half_space_2d(half_space_2d inst) { putEntityInstance("HALF_SPACE_2D", inst); }
    inline boolean_result csg_select::get_boolean_result() { return getEntityInstance("BOOLEAN_RESULT"); }
    inline void csg_select::put_boolean_result(boolean_result inst) { putEntityInstance("BOOLEAN_RESULT", inst); }
    inline boolean_result csg_select_get::get_boolean_result() { return getEntityInstance("BOOLEAN_RESULT"); }
    inline void csg_select_put::put_boolean_result(boolean_result inst) { putEntityInstance("BOOLEAN_RESULT", inst); }
    inline pcurve curve_on_surface::get_pcurve() { return getEntityInstance("PCURVE"); }
    inline void curve_on_surface::put_pcurve(pcurve inst) { putEntityInstance("PCURVE", inst); }
    inline surface_curve curve_on_surface::get_surface_curve() { return getEntityInstance("SURFACE_CURVE"); }
    inline void curve_on_surface::put_surface_curve(surface_curve inst) { putEntityInstance("SURFACE_CURVE", inst); }
    inline composite_curve_on_surface curve_on_surface::get_composite_curve_on_surface() { return getEntityInstance("COMPOSITE_CURVE_ON_SURFACE"); }
    inline void curve_on_surface::put_composite_curve_on_surface(composite_curve_on_surface inst) { putEntityInstance("COMPOSITE_CURVE_ON_SURFACE", inst); }
    inline pcurve curve_on_surface_get::get_pcurve() { return getEntityInstance("PCURVE"); }
    inline surface_curve curve_on_surface_get::get_surface_curve() { return getEntityInstance("SURFACE_CURVE"); }
    inline composite_curve_on_surface curve_on_surface_get::get_composite_curve_on_surface() { return getEntityInstance("COMPOSITE_CURVE_ON_SURFACE"); }
    inline void curve_on_surface_put::put_pcurve(pcurve inst) { putEntityInstance("PCURVE", inst); }
    inline void curve_on_surface_put::put_surface_curve(surface_curve inst) { putEntityInstance("SURFACE_CURVE", inst); }
    inline void curve_on_surface_put::put_composite_curve_on_surface(composite_curve_on_surface inst) { putEntityInstance("COMPOSITE_CURVE_ON_SURFACE", inst); }
    inline person_and_organization_role description_attribute_select::get_person_and_organization_role() { return getEntityInstance("PERSON_AND_ORGANIZATION_ROLE"); }
    inline void description_attribute_select::put_person_and_organization_role(person_and_organization_role inst) { putEntityInstance("PERSON_AND_ORGANIZATION_ROLE", inst); }
    inline person_and_organization description_attribute_select::get_person_and_organization() { return getEntityInstance("PERSON_AND_ORGANIZATION"); }
    inline void description_attribute_select::put_person_and_organization(person_and_organization inst) { putEntityInstance("PERSON_AND_ORGANIZATION", inst); }
    inline representation description_attribute_select::get_representation() { return getEntityInstance("REPRESENTATION"); }
    inline void description_attribute_select::put_representation(representation inst) { putEntityInstance("REPRESENTATION", inst); }
    inline person_and_organization_role description_attribute_select_get::get_person_and_organization_role() { return getEntityInstance("PERSON_AND_ORGANIZATION_ROLE"); }
    inline person_and_organization description_attribute_select_get::get_person_and_organization() { return getEntityInstance("PERSON_AND_ORGANIZATION"); }
    inline representation description_attribute_select_get::get_representation() { return getEntityInstance("REPRESENTATION"); }
    inline void description_attribute_select_put::put_person_and_organization_role(person_and_organization_role inst) { putEntityInstance("PERSON_AND_ORGANIZATION_ROLE", inst); }
    inline void description_attribute_select_put::put_person_and_organization(person_and_organization inst) { putEntityInstance("PERSON_AND_ORGANIZATION", inst); }
    inline void description_attribute_select_put::put_representation(representation inst) { putEntityInstance("REPRESENTATION", inst); }
    inline founded_item founded_item_select::get_founded_item() { return getEntityInstance("FOUNDED_ITEM"); }
    inline void founded_item_select::put_founded_item(founded_item inst) { putEntityInstance("FOUNDED_ITEM", inst); }
    inline representation_item founded_item_select::get_representation_item() { return getEntityInstance("REPRESENTATION_ITEM"); }
    inline void founded_item_select::put_representation_item(representation_item inst) { putEntityInstance("REPRESENTATION_ITEM", inst); }
    inline founded_item founded_item_select_get::get_founded_item() { return getEntityInstance("FOUNDED_ITEM"); }
    inline representation_item founded_item_select_get::get_representation_item() { return getEntityInstance("REPRESENTATION_ITEM"); }
    inline void founded_item_select_put::put_founded_item(founded_item inst) { putEntityInstance("FOUNDED_ITEM", inst); }
    inline void founded_item_select_put::put_representation_item(representation_item inst) { putEntityInstance("REPRESENTATION_ITEM", inst); }
    inline point geometric_set_select::get_point() { return getEntityInstance("POINT"); }
    inline void geometric_set_select::put_point(point inst) { putEntityInstance("POINT", inst); }
    inline curve geometric_set_select::get_curve() { return getEntityInstance("CURVE"); }
    inline void geometric_set_select::put_curve(curve inst) { putEntityInstance("CURVE", inst); }
    inline surface geometric_set_select::get_surface() { return getEntityInstance("SURFACE"); }
    inline void geometric_set_select::put_surface(surface inst) { putEntityInstance("SURFACE", inst); }
    inline point geometric_set_select_get::get_point() { return getEntityInstance("POINT"); }
    inline curve geometric_set_select_get::get_curve() { return getEntityInstance("CURVE"); }
    inline surface geometric_set_select_get::get_surface() { return getEntityInstance("SURFACE"); }
    inline void geometric_set_select_put::put_point(point inst) { putEntityInstance("POINT", inst); }
    inline void geometric_set_select_put::put_curve(curve inst) { putEntityInstance("CURVE", inst); }
    inline void geometric_set_select_put::put_surface(surface inst) { putEntityInstance("SURFACE", inst); }
    inline action id_attribute_select::get_action() { return getEntityInstance("ACTION"); }
    inline void id_attribute_select::put_action(action inst) { putEntityInstance("ACTION", inst); }
    inline address id_attribute_select::get_address() { return getEntityInstance("ADDRESS"); }
    inline void id_attribute_select::put_address(address inst) { putEntityInstance("ADDRESS", inst); }
    inline group id_attribute_select::get_group() { return getEntityInstance("GROUP"); }
    inline void id_attribute_select::put_group(group inst) { putEntityInstance("GROUP", inst); }
    inline representation id_attribute_select::get_representation() { return getEntityInstance("REPRESENTATION"); }
    inline void id_attribute_select::put_representation(representation inst) { putEntityInstance("REPRESENTATION", inst); }
    inline action id_attribute_select_get::get_action() { return getEntityInstance("ACTION"); }
    inline address id_attribute_select_get::get_address() { return getEntityInstance("ADDRESS"); }
    inline group id_attribute_select_get::get_group() { return getEntityInstance("GROUP"); }
    inline representation id_attribute_select_get::get_representation() { return getEntityInstance("REPRESENTATION"); }
    inline void id_attribute_select_put::put_action(action inst) { putEntityInstance("ACTION", inst); }
    inline void id_attribute_select_put::put_address(address inst) { putEntityInstance("ADDRESS", inst); }
    inline void id_attribute_select_put::put_group(group inst) { putEntityInstance("GROUP", inst); }
    inline void id_attribute_select_put::put_representation(representation inst) { putEntityInstance("REPRESENTATION", inst); }
    inline measure_with_unit measure_select::get_measure_with_unit() { return getEntityInstance("MEASURE_WITH_UNIT"); }
    inline void measure_select::put_measure_with_unit(measure_with_unit inst) { putEntityInstance("MEASURE_WITH_UNIT", inst); }
    inline measure_with_unit measure_select_get::get_measure_with_unit() { return getEntityInstance("MEASURE_WITH_UNIT"); }
    inline void measure_select_put::put_measure_with_unit(measure_with_unit inst) { putEntityInstance("MEASURE_WITH_UNIT", inst); }
    inline address name_attribute_select::get_address() { return getEntityInstance("ADDRESS"); }
    inline void name_attribute_select::put_address(address inst) { putEntityInstance("ADDRESS", inst); }
    inline derived_unit name_attribute_select::get_derived_unit() { return getEntityInstance("DERIVED_UNIT"); }
    inline void name_attribute_select::put_derived_unit(derived_unit inst) { putEntityInstance("DERIVED_UNIT", inst); }
    inline person_and_organization name_attribute_select::get_person_and_organization() { return getEntityInstance("PERSON_AND_ORGANIZATION"); }
    inline void name_attribute_select::put_person_and_organization(person_and_organization inst) { putEntityInstance("PERSON_AND_ORGANIZATION", inst); }
    inline address name_attribute_select_get::get_address() { return getEntityInstance("ADDRESS"); }
    inline derived_unit name_attribute_select_get::get_derived_unit() { return getEntityInstance("DERIVED_UNIT"); }
    inline person_and_organization name_attribute_select_get::get_person_and_organization() { return getEntityInstance("PERSON_AND_ORGANIZATION"); }
    inline void name_attribute_select_put::put_address(address inst) { putEntityInstance("ADDRESS", inst); }
    inline void name_attribute_select_put::put_derived_unit(derived_unit inst) { putEntityInstance("DERIVED_UNIT", inst); }
    inline void name_attribute_select_put::put_person_and_organization(person_and_organization inst) { putEntityInstance("PERSON_AND_ORGANIZATION", inst); }
    inline plane_angle_measure_with_unit orientation_select::get_plane_angle_measure_with_unit() { return getEntityInstance("PLANE_ANGLE_MEASURE_WITH_UNIT"); }
    inline void orientation_select::put_plane_angle_measure_with_unit(plane_angle_measure_with_unit inst) { putEntityInstance("PLANE_ANGLE_MEASURE_WITH_UNIT", inst); }
    inline direction orientation_select::get_direction() { return getEntityInstance("DIRECTION"); }
    inline void orientation_select::put_direction(direction inst) { putEntityInstance("DIRECTION", inst); }
    inline plane_angle_measure_with_unit orientation_select_get::get_plane_angle_measure_with_unit() { return getEntityInstance("PLANE_ANGLE_MEASURE_WITH_UNIT"); }
    inline direction orientation_select_get::get_direction() { return getEntityInstance("DIRECTION"); }
    inline void orientation_select_put::put_plane_angle_measure_with_unit(plane_angle_measure_with_unit inst) { putEntityInstance("PLANE_ANGLE_MEASURE_WITH_UNIT", inst); }
    inline void orientation_select_put::put_direction(direction inst) { putEntityInstance("DIRECTION", inst); }
    inline part part_select::get_part() { return getEntityInstance("PART"); }
    inline void part_select::put_part(part inst) { putEntityInstance("PART", inst); }
    inline design_part part_select::get_design_part() { return getEntityInstance("DESIGN_PART"); }
    inline void part_select::put_design_part(design_part inst) { putEntityInstance("DESIGN_PART", inst); }
    inline located_part part_select::get_located_part() { return getEntityInstance("LOCATED_PART"); }
    inline void part_select::put_located_part(located_part inst) { putEntityInstance("LOCATED_PART", inst); }
    inline part part_select_get::get_part() { return getEntityInstance("PART"); }
    inline design_part part_select_get::get_design_part() { return getEntityInstance("DESIGN_PART"); }
    inline located_part part_select_get::get_located_part() { return getEntityInstance("LOCATED_PART"); }
    inline void part_select_put::put_part(part inst) { putEntityInstance("PART", inst); }
    inline void part_select_put::put_design_part(design_part inst) { putEntityInstance("DESIGN_PART", inst); }
    inline void part_select_put::put_located_part(located_part inst) { putEntityInstance("LOCATED_PART", inst); }
    inline pcurve pcurve_or_surface::get_pcurve() { return getEntityInstance("PCURVE"); }
    inline void pcurve_or_surface::put_pcurve(pcurve inst) { putEntityInstance("PCURVE", inst); }
    inline surface pcurve_or_surface::get_surface() { return getEntityInstance("SURFACE"); }
    inline void pcurve_or_surface::put_surface(surface inst) { putEntityInstance("SURFACE", inst); }
    inline pcurve pcurve_or_surface_get::get_pcurve() { return getEntityInstance("PCURVE"); }
    inline surface pcurve_or_surface_get::get_surface() { return getEntityInstance("SURFACE"); }
    inline void pcurve_or_surface_put::put_pcurve(pcurve inst) { putEntityInstance("PCURVE", inst); }
    inline void pcurve_or_surface_put::put_surface(surface inst) { putEntityInstance("SURFACE", inst); }
    inline structural_frame_product product_item_select::get_structural_frame_product() { return getEntityInstance("STRUCTURAL_FRAME_PRODUCT"); }
    inline void product_item_select::put_structural_frame_product(structural_frame_product inst) { putEntityInstance("STRUCTURAL_FRAME_PRODUCT", inst); }
    inline structural_frame_product product_item_select_get::get_structural_frame_product() { return getEntityInstance("STRUCTURAL_FRAME_PRODUCT"); }
    inline void product_item_select_put::put_structural_frame_product(structural_frame_product inst) { putEntityInstance("STRUCTURAL_FRAME_PRODUCT", inst); }
    inline project project_select::get_project() { return getEntityInstance("PROJECT"); }
    inline void project_select::put_project(project inst) { putEntityInstance("PROJECT", inst); }
    inline zone_of_project project_select::get_zone_of_project() { return getEntityInstance("ZONE_OF_PROJECT"); }
    inline void project_select::put_zone_of_project(zone_of_project inst) { putEntityInstance("ZONE_OF_PROJECT", inst); }
    inline project project_select_get::get_project() { return getEntityInstance("PROJECT"); }
    inline zone_of_project project_select_get::get_zone_of_project() { return getEntityInstance("ZONE_OF_PROJECT"); }
    inline void project_select_put::put_project(project inst) { putEntityInstance("PROJECT", inst); }
    inline void project_select_put::put_zone_of_project(zone_of_project inst) { putEntityInstance("ZONE_OF_PROJECT", inst); }
    inline edge reversible_topology_item::get_edge() { return getEntityInstance("EDGE"); }
    inline void reversible_topology_item::put_edge(edge inst) { putEntityInstance("EDGE", inst); }
    inline path reversible_topology_item::get_path() { return getEntityInstance("PATH"); }
    inline void reversible_topology_item::put_path(path inst) { putEntityInstance("PATH", inst); }
    inline face reversible_topology_item::get_face() { return getEntityInstance("FACE"); }
    inline void reversible_topology_item::put_face(face inst) { putEntityInstance("FACE", inst); }
    inline face_bound reversible_topology_item::get_face_bound() { return getEntityInstance("FACE_BOUND"); }
    inline void reversible_topology_item::put_face_bound(face_bound inst) { putEntityInstance("FACE_BOUND", inst); }
    inline closed_shell reversible_topology_item::get_closed_shell() { return getEntityInstance("CLOSED_SHELL"); }
    inline void reversible_topology_item::put_closed_shell(closed_shell inst) { putEntityInstance("CLOSED_SHELL", inst); }
    inline open_shell reversible_topology_item::get_open_shell() { return getEntityInstance("OPEN_SHELL"); }
    inline void reversible_topology_item::put_open_shell(open_shell inst) { putEntityInstance("OPEN_SHELL", inst); }
    inline edge reversible_topology_item_get::get_edge() { return getEntityInstance("EDGE"); }
    inline path reversible_topology_item_get::get_path() { return getEntityInstance("PATH"); }
    inline face reversible_topology_item_get::get_face() { return getEntityInstance("FACE"); }
    inline face_bound reversible_topology_item_get::get_face_bound() { return getEntityInstance("FACE_BOUND"); }
    inline closed_shell reversible_topology_item_get::get_closed_shell() { return getEntityInstance("CLOSED_SHELL"); }
    inline open_shell reversible_topology_item_get::get_open_shell() { return getEntityInstance("OPEN_SHELL"); }
    inline void reversible_topology_item_put::put_edge(edge inst) { putEntityInstance("EDGE", inst); }
    inline void reversible_topology_item_put::put_path(path inst) { putEntityInstance("PATH", inst); }
    inline void reversible_topology_item_put::put_face(face inst) { putEntityInstance("FACE", inst); }
    inline void reversible_topology_item_put::put_face_bound(face_bound inst) { putEntityInstance("FACE_BOUND", inst); }
    inline void reversible_topology_item_put::put_closed_shell(closed_shell inst) { putEntityInstance("CLOSED_SHELL", inst); }
    inline void reversible_topology_item_put::put_open_shell(open_shell inst) { putEntityInstance("OPEN_SHELL", inst); }
    inline group_assignment role_select::get_group_assignment() { return getEntityInstance("GROUP_ASSIGNMENT"); }
    inline void role_select::put_group_assignment(group_assignment inst) { putEntityInstance("GROUP_ASSIGNMENT", inst); }
    inline group_assignment role_select_get::get_group_assignment() { return getEntityInstance("GROUP_ASSIGNMENT"); }
    inline void role_select_put::put_group_assignment(group_assignment inst) { putEntityInstance("GROUP_ASSIGNMENT", inst); }
    inline analysis_method select_analysis_model_item::get_analysis_method() { return getEntityInstance("ANALYSIS_METHOD"); }
    inline void select_analysis_model_item::put_analysis_method(analysis_method inst) { putEntityInstance("ANALYSIS_METHOD", inst); }
    inline boundary_condition select_analysis_model_item::get_boundary_condition() { return getEntityInstance("BOUNDARY_CONDITION"); }
    inline void select_analysis_model_item::put_boundary_condition(boundary_condition inst) { putEntityInstance("BOUNDARY_CONDITION", inst); }
    inline element_eccentricity select_analysis_model_item::get_element_eccentricity() { return getEntityInstance("ELEMENT_ECCENTRICITY"); }
    inline void select_analysis_model_item::put_element_eccentricity(element_eccentricity inst) { putEntityInstance("ELEMENT_ECCENTRICITY", inst); }
    inline element_node_connectivity select_analysis_model_item::get_element_node_connectivity() { return getEntityInstance("ELEMENT_NODE_CONNECTIVITY"); }
    inline void select_analysis_model_item::put_element_node_connectivity(element_node_connectivity inst) { putEntityInstance("ELEMENT_NODE_CONNECTIVITY", inst); }
    inline analysis_model select_analysis_model_item::get_analysis_model() { return getEntityInstance("ANALYSIS_MODEL"); }
    inline void select_analysis_model_item::put_analysis_model(analysis_model inst) { putEntityInstance("ANALYSIS_MODEL", inst); }
    inline analysis_model_mapping select_analysis_model_item::get_analysis_model_mapping() { return getEntityInstance("ANALYSIS_MODEL_MAPPING"); }
    inline void select_analysis_model_item::put_analysis_model_mapping(analysis_model_mapping inst) { putEntityInstance("ANALYSIS_MODEL_MAPPING", inst); }
    inline analysis_model_relationship select_analysis_model_item::get_analysis_model_relationship() { return getEntityInstance("ANALYSIS_MODEL_RELATIONSHIP"); }
    inline void select_analysis_model_item::put_analysis_model_relationship(analysis_model_relationship inst) { putEntityInstance("ANALYSIS_MODEL_RELATIONSHIP", inst); }
    inline element select_analysis_model_item::get_element() { return getEntityInstance("ELEMENT"); }
    inline void select_analysis_model_item::put_element(element inst) { putEntityInstance("ELEMENT", inst); }
    inline element_mapping select_analysis_model_item::get_element_mapping() { return getEntityInstance("ELEMENT_MAPPING"); }
    inline void select_analysis_model_item::put_element_mapping(element_mapping inst) { putEntityInstance("ELEMENT_MAPPING", inst); }
    inline node select_analysis_model_item::get_node() { return getEntityInstance("NODE"); }
    inline void select_analysis_model_item::put_node(node inst) { putEntityInstance("NODE", inst); }
    inline node_dependency select_analysis_model_item::get_node_dependency() { return getEntityInstance("NODE_DEPENDENCY"); }
    inline void select_analysis_model_item::put_node_dependency(node_dependency inst) { putEntityInstance("NODE_DEPENDENCY", inst); }
    inline release select_analysis_model_item::get_release() { return getEntityInstance("RELEASE"); }
    inline void select_analysis_model_item::put_release(release inst) { putEntityInstance("RELEASE", inst); }
    inline analysis_method select_analysis_model_item_get::get_analysis_method() { return getEntityInstance("ANALYSIS_METHOD"); }
    inline boundary_condition select_analysis_model_item_get::get_boundary_condition() { return getEntityInstance("BOUNDARY_CONDITION"); }
    inline element_eccentricity select_analysis_model_item_get::get_element_eccentricity() { return getEntityInstance("ELEMENT_ECCENTRICITY"); }
    inline element_node_connectivity select_analysis_model_item_get::get_element_node_connectivity() { return getEntityInstance("ELEMENT_NODE_CONNECTIVITY"); }
    inline analysis_model select_analysis_model_item_get::get_analysis_model() { return getEntityInstance("ANALYSIS_MODEL"); }
    inline analysis_model_mapping select_analysis_model_item_get::get_analysis_model_mapping() { return getEntityInstance("ANALYSIS_MODEL_MAPPING"); }
    inline analysis_model_relationship select_analysis_model_item_get::get_analysis_model_relationship() { return getEntityInstance("ANALYSIS_MODEL_RELATIONSHIP"); }
    inline element select_analysis_model_item_get::get_element() { return getEntityInstance("ELEMENT"); }
    inline element_mapping select_analysis_model_item_get::get_element_mapping() { return getEntityInstance("ELEMENT_MAPPING"); }
    inline node select_analysis_model_item_get::get_node() { return getEntityInstance("NODE"); }
    inline node_dependency select_analysis_model_item_get::get_node_dependency() { return getEntityInstance("NODE_DEPENDENCY"); }
    inline release select_analysis_model_item_get::get_release() { return getEntityInstance("RELEASE"); }
    inline void select_analysis_model_item_put::put_analysis_method(analysis_method inst) { putEntityInstance("ANALYSIS_METHOD", inst); }
    inline void select_analysis_model_item_put::put_boundary_condition(boundary_condition inst) { putEntityInstance("BOUNDARY_CONDITION", inst); }
    inline void select_analysis_model_item_put::put_element_eccentricity(element_eccentricity inst) { putEntityInstance("ELEMENT_ECCENTRICITY", inst); }
    inline void select_analysis_model_item_put::put_element_node_connectivity(element_node_connectivity inst) { putEntityInstance("ELEMENT_NODE_CONNECTIVITY", inst); }
    inline void select_analysis_model_item_put::put_analysis_model(analysis_model inst) { putEntityInstance("ANALYSIS_MODEL", inst); }
    inline void select_analysis_model_item_put::put_analysis_model_mapping(analysis_model_mapping inst) { putEntityInstance("ANALYSIS_MODEL_MAPPING", inst); }
    inline void select_analysis_model_item_put::put_analysis_model_relationship(analysis_model_relationship inst) { putEntityInstance("ANALYSIS_MODEL_RELATIONSHIP", inst); }
    inline void select_analysis_model_item_put::put_element(element inst) { putEntityInstance("ELEMENT", inst); }
    inline void select_analysis_model_item_put::put_element_mapping(element_mapping inst) { putEntityInstance("ELEMENT_MAPPING", inst); }
    inline void select_analysis_model_item_put::put_node(node inst) { putEntityInstance("NODE", inst); }
    inline void select_analysis_model_item_put::put_node_dependency(node_dependency inst) { putEntityInstance("NODE_DEPENDENCY", inst); }
    inline void select_analysis_model_item_put::put_release(release inst) { putEntityInstance("RELEASE", inst); }
    inline applied_load select_loading_item::get_applied_load() { return getEntityInstance("APPLIED_LOAD"); }
    inline void select_loading_item::put_applied_load(applied_load inst) { putEntityInstance("APPLIED_LOAD", inst); }
    inline load_case select_loading_item::get_load_case() { return getEntityInstance("LOAD_CASE"); }
    inline void select_loading_item::put_load_case(load_case inst) { putEntityInstance("LOAD_CASE", inst); }
    inline load select_loading_item::get_load() { return getEntityInstance("LOAD"); }
    inline void select_loading_item::put_load(load inst) { putEntityInstance("LOAD", inst); }
    inline loaded_product select_loading_item::get_loaded_product() { return getEntityInstance("LOADED_PRODUCT"); }
    inline void select_loading_item::put_loaded_product(loaded_product inst) { putEntityInstance("LOADED_PRODUCT", inst); }
    inline loading_combination select_loading_item::get_loading_combination() { return getEntityInstance("LOADING_COMBINATION"); }
    inline void select_loading_item::put_loading_combination(loading_combination inst) { putEntityInstance("LOADING_COMBINATION", inst); }
    inline load_combination_occurrence select_loading_item::get_load_combination_occurrence() { return getEntityInstance("LOAD_COMBINATION_OCCURRENCE"); }
    inline void select_loading_item::put_load_combination_occurrence(load_combination_occurrence inst) { putEntityInstance("LOAD_COMBINATION_OCCURRENCE", inst); }
    inline physical_action select_loading_item::get_physical_action() { return getEntityInstance("PHYSICAL_ACTION"); }
    inline void select_loading_item::put_physical_action(physical_action inst) { putEntityInstance("PHYSICAL_ACTION", inst); }
    inline applied_load select_loading_item_get::get_applied_load() { return getEntityInstance("APPLIED_LOAD"); }
    inline load_case select_loading_item_get::get_load_case() { return getEntityInstance("LOAD_CASE"); }
    inline load select_loading_item_get::get_load() { return getEntityInstance("LOAD"); }
    inline loaded_product select_loading_item_get::get_loaded_product() { return getEntityInstance("LOADED_PRODUCT"); }
    inline loading_combination select_loading_item_get::get_loading_combination() { return getEntityInstance("LOADING_COMBINATION"); }
    inline load_combination_occurrence select_loading_item_get::get_load_combination_occurrence() { return getEntityInstance("LOAD_COMBINATION_OCCURRENCE"); }
    inline physical_action select_loading_item_get::get_physical_action() { return getEntityInstance("PHYSICAL_ACTION"); }
    inline void select_loading_item_put::put_applied_load(applied_load inst) { putEntityInstance("APPLIED_LOAD", inst); }
    inline void select_loading_item_put::put_load_case(load_case inst) { putEntityInstance("LOAD_CASE", inst); }
    inline void select_loading_item_put::put_load(load inst) { putEntityInstance("LOAD", inst); }
    inline void select_loading_item_put::put_loaded_product(loaded_product inst) { putEntityInstance("LOADED_PRODUCT", inst); }
    inline void select_loading_item_put::put_loading_combination(loading_combination inst) { putEntityInstance("LOADING_COMBINATION", inst); }
    inline void select_loading_item_put::put_load_combination_occurrence(load_combination_occurrence inst) { putEntityInstance("LOAD_COMBINATION_OCCURRENCE", inst); }
    inline void select_loading_item_put::put_physical_action(physical_action inst) { putEntityInstance("PHYSICAL_ACTION", inst); }
    inline analysis_result select_response_item::get_analysis_result() { return getEntityInstance("ANALYSIS_RESULT"); }
    inline void select_response_item::put_analysis_result(analysis_result inst) { putEntityInstance("ANALYSIS_RESULT", inst); }
    inline analysis_results_set select_response_item::get_analysis_results_set() { return getEntityInstance("ANALYSIS_RESULTS_SET"); }
    inline void select_response_item::put_analysis_results_set(analysis_results_set inst) { putEntityInstance("ANALYSIS_RESULTS_SET", inst); }
    inline design_result select_response_item::get_design_result() { return getEntityInstance("DESIGN_RESULT"); }
    inline void select_response_item::put_design_result(design_result inst) { putEntityInstance("DESIGN_RESULT", inst); }
    inline reaction select_response_item::get_reaction() { return getEntityInstance("REACTION"); }
    inline void select_response_item::put_reaction(reaction inst) { putEntityInstance("REACTION", inst); }
    inline analysis_result select_response_item_get::get_analysis_result() { return getEntityInstance("ANALYSIS_RESULT"); }
    inline analysis_results_set select_response_item_get::get_analysis_results_set() { return getEntityInstance("ANALYSIS_RESULTS_SET"); }
    inline design_result select_response_item_get::get_design_result() { return getEntityInstance("DESIGN_RESULT"); }
    inline reaction select_response_item_get::get_reaction() { return getEntityInstance("REACTION"); }
    inline void select_response_item_put::put_analysis_result(analysis_result inst) { putEntityInstance("ANALYSIS_RESULT", inst); }
    inline void select_response_item_put::put_analysis_results_set(analysis_results_set inst) { putEntityInstance("ANALYSIS_RESULTS_SET", inst); }
    inline void select_response_item_put::put_design_result(design_result inst) { putEntityInstance("DESIGN_RESULT", inst); }
    inline void select_response_item_put::put_reaction(reaction inst) { putEntityInstance("REACTION", inst); }
    inline precision_qualifier value_qualifier::get_precision_qualifier() { return getEntityInstance("PRECISION_QUALIFIER"); }
    inline void value_qualifier::put_precision_qualifier(precision_qualifier inst) { putEntityInstance("PRECISION_QUALIFIER", inst); }
    inline type_qualifier value_qualifier::get_type_qualifier() { return getEntityInstance("TYPE_QUALIFIER"); }
    inline void value_qualifier::put_type_qualifier(type_qualifier inst) { putEntityInstance("TYPE_QUALIFIER", inst); }
    inline uncertainty_qualifier value_qualifier::get_uncertainty_qualifier() { return getEntityInstance("UNCERTAINTY_QUALIFIER"); }
    inline void value_qualifier::put_uncertainty_qualifier(uncertainty_qualifier inst) { putEntityInstance("UNCERTAINTY_QUALIFIER", inst); }
    inline precision_qualifier value_qualifier_get::get_precision_qualifier() { return getEntityInstance("PRECISION_QUALIFIER"); }
    inline type_qualifier value_qualifier_get::get_type_qualifier() { return getEntityInstance("TYPE_QUALIFIER"); }
    inline uncertainty_qualifier value_qualifier_get::get_uncertainty_qualifier() { return getEntityInstance("UNCERTAINTY_QUALIFIER"); }
    inline void value_qualifier_put::put_precision_qualifier(precision_qualifier inst) { putEntityInstance("PRECISION_QUALIFIER", inst); }
    inline void value_qualifier_put::put_type_qualifier(type_qualifier inst) { putEntityInstance("TYPE_QUALIFIER", inst); }
    inline void value_qualifier_put::put_uncertainty_qualifier(uncertainty_qualifier inst) { putEntityInstance("UNCERTAINTY_QUALIFIER", inst); }
    inline action select_generic_item::get_action() { return getEntityInstance("ACTION"); }
    inline void select_generic_item::put_action(action inst) { putEntityInstance("ACTION", inst); }
    inline action_directive select_generic_item::get_action_directive() { return getEntityInstance("ACTION_DIRECTIVE"); }
    inline void select_generic_item::put_action_directive(action_directive inst) { putEntityInstance("ACTION_DIRECTIVE", inst); }
    inline action_method select_generic_item::get_action_method() { return getEntityInstance("ACTION_METHOD"); }
    inline void select_generic_item::put_action_method(action_method inst) { putEntityInstance("ACTION_METHOD", inst); }
    inline address select_generic_item::get_address() { return getEntityInstance("ADDRESS"); }
    inline void select_generic_item::put_address(address inst) { putEntityInstance("ADDRESS", inst); }
    inline approval select_generic_item::get_approval() { return getEntityInstance("APPROVAL"); }
    inline void select_generic_item::put_approval(approval inst) { putEntityInstance("APPROVAL", inst); }
    inline approval_status select_generic_item::get_approval_status() { return getEntityInstance("APPROVAL_STATUS"); }
    inline void select_generic_item::put_approval_status(approval_status inst) { putEntityInstance("APPROVAL_STATUS", inst); }
    inline box_domain select_generic_item::get_box_domain() { return getEntityInstance("BOX_DOMAIN"); }
    inline void select_generic_item::put_box_domain(box_domain inst) { putEntityInstance("BOX_DOMAIN", inst); }
    inline certification select_generic_item::get_certification() { return getEntityInstance("CERTIFICATION"); }
    inline void select_generic_item::put_certification(certification inst) { putEntityInstance("CERTIFICATION", inst); }
    inline certification_type select_generic_item::get_certification_type() { return getEntityInstance("CERTIFICATION_TYPE"); }
    inline void select_generic_item::put_certification_type(certification_type inst) { putEntityInstance("CERTIFICATION_TYPE", inst); }
    inline contract select_generic_item::get_contract() { return getEntityInstance("CONTRACT"); }
    inline void select_generic_item::put_contract(contract inst) { putEntityInstance("CONTRACT", inst); }
    inline contract_type select_generic_item::get_contract_type() { return getEntityInstance("CONTRACT_TYPE"); }
    inline void select_generic_item::put_contract_type(contract_type inst) { putEntityInstance("CONTRACT_TYPE", inst); }
    inline coordinated_universal_time_offset select_generic_item::get_coordinated_universal_time_offset() { return getEntityInstance("COORDINATED_UNIVERSAL_TIME_OFFSET"); }
    inline void select_generic_item::put_coordinated_universal_time_offset(coordinated_universal_time_offset inst) { putEntityInstance("COORDINATED_UNIVERSAL_TIME_OFFSET", inst); }
    inline date select_generic_item::get_date() { return getEntityInstance("DATE"); }
    inline void select_generic_item::put_date(date inst) { putEntityInstance("DATE", inst); }
    inline date_and_time select_generic_item::get_date_and_time() { return getEntityInstance("DATE_AND_TIME"); }
    inline void select_generic_item::put_date_and_time(date_and_time inst) { putEntityInstance("DATE_AND_TIME", inst); }
    inline derived_unit select_generic_item::get_derived_unit() { return getEntityInstance("DERIVED_UNIT"); }
    inline void select_generic_item::put_derived_unit(derived_unit inst) { putEntityInstance("DERIVED_UNIT", inst); }
    inline derived_unit_element select_generic_item::get_derived_unit_element() { return getEntityInstance("DERIVED_UNIT_ELEMENT"); }
    inline void select_generic_item::put_derived_unit_element(derived_unit_element inst) { putEntityInstance("DERIVED_UNIT_ELEMENT", inst); }
    inline description_attribute select_generic_item::get_description_attribute() { return getEntityInstance("DESCRIPTION_ATTRIBUTE"); }
    inline void select_generic_item::put_description_attribute(description_attribute inst) { putEntityInstance("DESCRIPTION_ATTRIBUTE", inst); }
    inline dimensional_exponents select_generic_item::get_dimensional_exponents() { return getEntityInstance("DIMENSIONAL_EXPONENTS"); }
    inline void select_generic_item::put_dimensional_exponents(dimensional_exponents inst) { putEntityInstance("DIMENSIONAL_EXPONENTS", inst); }
    inline document select_generic_item::get_document() { return getEntityInstance("DOCUMENT"); }
    inline void select_generic_item::put_document(document inst) { putEntityInstance("DOCUMENT", inst); }
    inline document_type select_generic_item::get_document_type() { return getEntityInstance("DOCUMENT_TYPE"); }
    inline void select_generic_item::put_document_type(document_type inst) { putEntityInstance("DOCUMENT_TYPE", inst); }
    inline document_relationship select_generic_item::get_document_relationship() { return getEntityInstance("DOCUMENT_RELATIONSHIP"); }
    inline void select_generic_item::put_document_relationship(document_relationship inst) { putEntityInstance("DOCUMENT_RELATIONSHIP", inst); }
    inline document_representation_type select_generic_item::get_document_representation_type() { return getEntityInstance("DOCUMENT_REPRESENTATION_TYPE"); }
    inline void select_generic_item::put_document_representation_type(document_representation_type inst) { putEntityInstance("DOCUMENT_REPRESENTATION_TYPE", inst); }
    inline document_usage_constraint select_generic_item::get_document_usage_constraint() { return getEntityInstance("DOCUMENT_USAGE_CONSTRAINT"); }
    inline void select_generic_item::put_document_usage_constraint(document_usage_constraint inst) { putEntityInstance("DOCUMENT_USAGE_CONSTRAINT", inst); }
    inline founded_item select_generic_item::get_founded_item() { return getEntityInstance("FOUNDED_ITEM"); }
    inline void select_generic_item::put_founded_item(founded_item inst) { putEntityInstance("FOUNDED_ITEM", inst); }
    inline functionally_defined_transformation select_generic_item::get_functionally_defined_transformation() { return getEntityInstance("FUNCTIONALLY_DEFINED_TRANSFORMATION"); }
    inline void select_generic_item::put_functionally_defined_transformation(functionally_defined_transformation inst) { putEntityInstance("FUNCTIONALLY_DEFINED_TRANSFORMATION", inst); }
    inline group select_generic_item::get_group() { return getEntityInstance("GROUP"); }
    inline void select_generic_item::put_group(group inst) { putEntityInstance("GROUP", inst); }
    inline group_assignment select_generic_item::get_group_assignment() { return getEntityInstance("GROUP_ASSIGNMENT"); }
    inline void select_generic_item::put_group_assignment(group_assignment inst) { putEntityInstance("GROUP_ASSIGNMENT", inst); }
    inline group_relationship select_generic_item::get_group_relationship() { return getEntityInstance("GROUP_RELATIONSHIP"); }
    inline void select_generic_item::put_group_relationship(group_relationship inst) { putEntityInstance("GROUP_RELATIONSHIP", inst); }
    inline id_attribute select_generic_item::get_id_attribute() { return getEntityInstance("ID_ATTRIBUTE"); }
    inline void select_generic_item::put_id_attribute(id_attribute inst) { putEntityInstance("ID_ATTRIBUTE", inst); }
    inline item_defined_transformation select_generic_item::get_item_defined_transformation() { return getEntityInstance("ITEM_DEFINED_TRANSFORMATION"); }
    inline void select_generic_item::put_item_defined_transformation(item_defined_transformation inst) { putEntityInstance("ITEM_DEFINED_TRANSFORMATION", inst); }
    inline local_time select_generic_item::get_local_time() { return getEntityInstance("LOCAL_TIME"); }
    inline void select_generic_item::put_local_time(local_time inst) { putEntityInstance("LOCAL_TIME", inst); }
    inline measure_qualification select_generic_item::get_measure_qualification() { return getEntityInstance("MEASURE_QUALIFICATION"); }
    inline void select_generic_item::put_measure_qualification(measure_qualification inst) { putEntityInstance("MEASURE_QUALIFICATION", inst); }
    inline measure_with_unit select_generic_item::get_measure_with_unit() { return getEntityInstance("MEASURE_WITH_UNIT"); }
    inline void select_generic_item::put_measure_with_unit(measure_with_unit inst) { putEntityInstance("MEASURE_WITH_UNIT", inst); }
    inline name_attribute select_generic_item::get_name_attribute() { return getEntityInstance("NAME_ATTRIBUTE"); }
    inline void select_generic_item::put_name_attribute(name_attribute inst) { putEntityInstance("NAME_ATTRIBUTE", inst); }
    inline named_unit select_generic_item::get_named_unit() { return getEntityInstance("NAMED_UNIT"); }
    inline void select_generic_item::put_named_unit(named_unit inst) { putEntityInstance("NAMED_UNIT", inst); }
    inline object_role select_generic_item::get_object_role() { return getEntityInstance("OBJECT_ROLE"); }
    inline void select_generic_item::put_object_role(object_role inst) { putEntityInstance("OBJECT_ROLE", inst); }
    inline organization select_generic_item::get_organization() { return getEntityInstance("ORGANIZATION"); }
    inline void select_generic_item::put_organization(organization inst) { putEntityInstance("ORGANIZATION", inst); }
    inline organization_relationship select_generic_item::get_organization_relationship() { return getEntityInstance("ORGANIZATION_RELATIONSHIP"); }
    inline void select_generic_item::put_organization_relationship(organization_relationship inst) { putEntityInstance("ORGANIZATION_RELATIONSHIP", inst); }
    inline person select_generic_item::get_person() { return getEntityInstance("PERSON"); }
    inline void select_generic_item::put_person(person inst) { putEntityInstance("PERSON", inst); }
    inline person_and_organization select_generic_item::get_person_and_organization() { return getEntityInstance("PERSON_AND_ORGANIZATION"); }
    inline void select_generic_item::put_person_and_organization(person_and_organization inst) { putEntityInstance("PERSON_AND_ORGANIZATION", inst); }
    inline person_and_organization_role select_generic_item::get_person_and_organization_role() { return getEntityInstance("PERSON_AND_ORGANIZATION_ROLE"); }
    inline void select_generic_item::put_person_and_organization_role(person_and_organization_role inst) { putEntityInstance("PERSON_AND_ORGANIZATION_ROLE", inst); }
    inline representation select_generic_item::get_representation() { return getEntityInstance("REPRESENTATION"); }
    inline void select_generic_item::put_representation(representation inst) { putEntityInstance("REPRESENTATION", inst); }
    inline representation_context select_generic_item::get_representation_context() { return getEntityInstance("REPRESENTATION_CONTEXT"); }
    inline void select_generic_item::put_representation_context(representation_context inst) { putEntityInstance("REPRESENTATION_CONTEXT", inst); }
    inline representation_item select_generic_item::get_representation_item() { return getEntityInstance("REPRESENTATION_ITEM"); }
    inline void select_generic_item::put_representation_item(representation_item inst) { putEntityInstance("REPRESENTATION_ITEM", inst); }
    inline representation_map select_generic_item::get_representation_map() { return getEntityInstance("REPRESENTATION_MAP"); }
    inline void select_generic_item::put_representation_map(representation_map inst) { putEntityInstance("REPRESENTATION_MAP", inst); }
    inline representation_relationship select_generic_item::get_representation_relationship() { return getEntityInstance("REPRESENTATION_RELATIONSHIP"); }
    inline void select_generic_item::put_representation_relationship(representation_relationship inst) { putEntityInstance("REPRESENTATION_RELATIONSHIP", inst); }
    inline role_association select_generic_item::get_role_association() { return getEntityInstance("ROLE_ASSOCIATION"); }
    inline void select_generic_item::put_role_association(role_association inst) { putEntityInstance("ROLE_ASSOCIATION", inst); }
    inline surface_patch select_generic_item::get_surface_patch() { return getEntityInstance("SURFACE_PATCH"); }
    inline void select_generic_item::put_surface_patch(surface_patch inst) { putEntityInstance("SURFACE_PATCH", inst); }
    inline versioned_action_request select_generic_item::get_versioned_action_request() { return getEntityInstance("VERSIONED_ACTION_REQUEST"); }
    inline void select_generic_item::put_versioned_action_request(versioned_action_request inst) { putEntityInstance("VERSIONED_ACTION_REQUEST", inst); }
    inline action select_generic_item_get::get_action() { return getEntityInstance("ACTION"); }
    inline action_directive select_generic_item_get::get_action_directive() { return getEntityInstance("ACTION_DIRECTIVE"); }
    inline action_method select_generic_item_get::get_action_method() { return getEntityInstance("ACTION_METHOD"); }
    inline address select_generic_item_get::get_address() { return getEntityInstance("ADDRESS"); }
    inline approval select_generic_item_get::get_approval() { return getEntityInstance("APPROVAL"); }
    inline approval_status select_generic_item_get::get_approval_status() { return getEntityInstance("APPROVAL_STATUS"); }
    inline box_domain select_generic_item_get::get_box_domain() { return getEntityInstance("BOX_DOMAIN"); }
    inline certification select_generic_item_get::get_certification() { return getEntityInstance("CERTIFICATION"); }
    inline certification_type select_generic_item_get::get_certification_type() { return getEntityInstance("CERTIFICATION_TYPE"); }
    inline contract select_generic_item_get::get_contract() { return getEntityInstance("CONTRACT"); }
    inline contract_type select_generic_item_get::get_contract_type() { return getEntityInstance("CONTRACT_TYPE"); }
    inline coordinated_universal_time_offset select_generic_item_get::get_coordinated_universal_time_offset() { return getEntityInstance("COORDINATED_UNIVERSAL_TIME_OFFSET"); }
    inline date select_generic_item_get::get_date() { return getEntityInstance("DATE"); }
    inline date_and_time select_generic_item_get::get_date_and_time() { return getEntityInstance("DATE_AND_TIME"); }
    inline derived_unit select_generic_item_get::get_derived_unit() { return getEntityInstance("DERIVED_UNIT"); }
    inline derived_unit_element select_generic_item_get::get_derived_unit_element() { return getEntityInstance("DERIVED_UNIT_ELEMENT"); }
    inline description_attribute select_generic_item_get::get_description_attribute() { return getEntityInstance("DESCRIPTION_ATTRIBUTE"); }
    inline dimensional_exponents select_generic_item_get::get_dimensional_exponents() { return getEntityInstance("DIMENSIONAL_EXPONENTS"); }
    inline document select_generic_item_get::get_document() { return getEntityInstance("DOCUMENT"); }
    inline document_type select_generic_item_get::get_document_type() { return getEntityInstance("DOCUMENT_TYPE"); }
    inline document_relationship select_generic_item_get::get_document_relationship() { return getEntityInstance("DOCUMENT_RELATIONSHIP"); }
    inline document_representation_type select_generic_item_get::get_document_representation_type() { return getEntityInstance("DOCUMENT_REPRESENTATION_TYPE"); }
    inline document_usage_constraint select_generic_item_get::get_document_usage_constraint() { return getEntityInstance("DOCUMENT_USAGE_CONSTRAINT"); }
    inline founded_item select_generic_item_get::get_founded_item() { return getEntityInstance("FOUNDED_ITEM"); }
    inline functionally_defined_transformation select_generic_item_get::get_functionally_defined_transformation() { return getEntityInstance("FUNCTIONALLY_DEFINED_TRANSFORMATION"); }
    inline group select_generic_item_get::get_group() { return getEntityInstance("GROUP"); }
    inline group_assignment select_generic_item_get::get_group_assignment() { return getEntityInstance("GROUP_ASSIGNMENT"); }
    inline group_relationship select_generic_item_get::get_group_relationship() { return getEntityInstance("GROUP_RELATIONSHIP"); }
    inline id_attribute select_generic_item_get::get_id_attribute() { return getEntityInstance("ID_ATTRIBUTE"); }
    inline item_defined_transformation select_generic_item_get::get_item_defined_transformation() { return getEntityInstance("ITEM_DEFINED_TRANSFORMATION"); }
    inline local_time select_generic_item_get::get_local_time() { return getEntityInstance("LOCAL_TIME"); }
    inline measure_qualification select_generic_item_get::get_measure_qualification() { return getEntityInstance("MEASURE_QUALIFICATION"); }
    inline measure_with_unit select_generic_item_get::get_measure_with_unit() { return getEntityInstance("MEASURE_WITH_UNIT"); }
    inline name_attribute select_generic_item_get::get_name_attribute() { return getEntityInstance("NAME_ATTRIBUTE"); }
    inline named_unit select_generic_item_get::get_named_unit() { return getEntityInstance("NAMED_UNIT"); }
    inline object_role select_generic_item_get::get_object_role() { return getEntityInstance("OBJECT_ROLE"); }
    inline organization select_generic_item_get::get_organization() { return getEntityInstance("ORGANIZATION"); }
    inline organization_relationship select_generic_item_get::get_organization_relationship() { return getEntityInstance("ORGANIZATION_RELATIONSHIP"); }
    inline person select_generic_item_get::get_person() { return getEntityInstance("PERSON"); }
    inline person_and_organization select_generic_item_get::get_person_and_organization() { return getEntityInstance("PERSON_AND_ORGANIZATION"); }
    inline person_and_organization_role select_generic_item_get::get_person_and_organization_role() { return getEntityInstance("PERSON_AND_ORGANIZATION_ROLE"); }
    inline representation select_generic_item_get::get_representation() { return getEntityInstance("REPRESENTATION"); }
    inline representation_context select_generic_item_get::get_representation_context() { return getEntityInstance("REPRESENTATION_CONTEXT"); }
    inline representation_item select_generic_item_get::get_representation_item() { return getEntityInstance("REPRESENTATION_ITEM"); }
    inline representation_map select_generic_item_get::get_representation_map() { return getEntityInstance("REPRESENTATION_MAP"); }
    inline representation_relationship select_generic_item_get::get_representation_relationship() { return getEntityInstance("REPRESENTATION_RELATIONSHIP"); }
    inline role_association select_generic_item_get::get_role_association() { return getEntityInstance("ROLE_ASSOCIATION"); }
    inline surface_patch select_generic_item_get::get_surface_patch() { return getEntityInstance("SURFACE_PATCH"); }
    inline versioned_action_request select_generic_item_get::get_versioned_action_request() { return getEntityInstance("VERSIONED_ACTION_REQUEST"); }
    inline void select_generic_item_put::put_action(action inst) { putEntityInstance("ACTION", inst); }
    inline void select_generic_item_put::put_action_directive(action_directive inst) { putEntityInstance("ACTION_DIRECTIVE", inst); }
    inline void select_generic_item_put::put_action_method(action_method inst) { putEntityInstance("ACTION_METHOD", inst); }
    inline void select_generic_item_put::put_address(address inst) { putEntityInstance("ADDRESS", inst); }
    inline void select_generic_item_put::put_approval(approval inst) { putEntityInstance("APPROVAL", inst); }
    inline void select_generic_item_put::put_approval_status(approval_status inst) { putEntityInstance("APPROVAL_STATUS", inst); }
    inline void select_generic_item_put::put_box_domain(box_domain inst) { putEntityInstance("BOX_DOMAIN", inst); }
    inline void select_generic_item_put::put_certification(certification inst) { putEntityInstance("CERTIFICATION", inst); }
    inline void select_generic_item_put::put_certification_type(certification_type inst) { putEntityInstance("CERTIFICATION_TYPE", inst); }
    inline void select_generic_item_put::put_contract(contract inst) { putEntityInstance("CONTRACT", inst); }
    inline void select_generic_item_put::put_contract_type(contract_type inst) { putEntityInstance("CONTRACT_TYPE", inst); }
    inline void select_generic_item_put::put_coordinated_universal_time_offset(coordinated_universal_time_offset inst) { putEntityInstance("COORDINATED_UNIVERSAL_TIME_OFFSET", inst); }
    inline void select_generic_item_put::put_date(date inst) { putEntityInstance("DATE", inst); }
    inline void select_generic_item_put::put_date_and_time(date_and_time inst) { putEntityInstance("DATE_AND_TIME", inst); }
    inline void select_generic_item_put::put_derived_unit(derived_unit inst) { putEntityInstance("DERIVED_UNIT", inst); }
    inline void select_generic_item_put::put_derived_unit_element(derived_unit_element inst) { putEntityInstance("DERIVED_UNIT_ELEMENT", inst); }
    inline void select_generic_item_put::put_description_attribute(description_attribute inst) { putEntityInstance("DESCRIPTION_ATTRIBUTE", inst); }
    inline void select_generic_item_put::put_dimensional_exponents(dimensional_exponents inst) { putEntityInstance("DIMENSIONAL_EXPONENTS", inst); }
    inline void select_generic_item_put::put_document(document inst) { putEntityInstance("DOCUMENT", inst); }
    inline void select_generic_item_put::put_document_type(document_type inst) { putEntityInstance("DOCUMENT_TYPE", inst); }
    inline void select_generic_item_put::put_document_relationship(document_relationship inst) { putEntityInstance("DOCUMENT_RELATIONSHIP", inst); }
    inline void select_generic_item_put::put_document_representation_type(document_representation_type inst) { putEntityInstance("DOCUMENT_REPRESENTATION_TYPE", inst); }
    inline void select_generic_item_put::put_document_usage_constraint(document_usage_constraint inst) { putEntityInstance("DOCUMENT_USAGE_CONSTRAINT", inst); }
    inline void select_generic_item_put::put_founded_item(founded_item inst) { putEntityInstance("FOUNDED_ITEM", inst); }
    inline void select_generic_item_put::put_functionally_defined_transformation(functionally_defined_transformation inst) { putEntityInstance("FUNCTIONALLY_DEFINED_TRANSFORMATION", inst); }
    inline void select_generic_item_put::put_group(group inst) { putEntityInstance("GROUP", inst); }
    inline void select_generic_item_put::put_group_assignment(group_assignment inst) { putEntityInstance("GROUP_ASSIGNMENT", inst); }
    inline void select_generic_item_put::put_group_relationship(group_relationship inst) { putEntityInstance("GROUP_RELATIONSHIP", inst); }
    inline void select_generic_item_put::put_id_attribute(id_attribute inst) { putEntityInstance("ID_ATTRIBUTE", inst); }
    inline void select_generic_item_put::put_item_defined_transformation(item_defined_transformation inst) { putEntityInstance("ITEM_DEFINED_TRANSFORMATION", inst); }
    inline void select_generic_item_put::put_local_time(local_time inst) { putEntityInstance("LOCAL_TIME", inst); }
    inline void select_generic_item_put::put_measure_qualification(measure_qualification inst) { putEntityInstance("MEASURE_QUALIFICATION", inst); }
    inline void select_generic_item_put::put_measure_with_unit(measure_with_unit inst) { putEntityInstance("MEASURE_WITH_UNIT", inst); }
    inline void select_generic_item_put::put_name_attribute(name_attribute inst) { putEntityInstance("NAME_ATTRIBUTE", inst); }
    inline void select_generic_item_put::put_named_unit(named_unit inst) { putEntityInstance("NAMED_UNIT", inst); }
    inline void select_generic_item_put::put_object_role(object_role inst) { putEntityInstance("OBJECT_ROLE", inst); }
    inline void select_generic_item_put::put_organization(organization inst) { putEntityInstance("ORGANIZATION", inst); }
    inline void select_generic_item_put::put_organization_relationship(organization_relationship inst) { putEntityInstance("ORGANIZATION_RELATIONSHIP", inst); }
    inline void select_generic_item_put::put_person(person inst) { putEntityInstance("PERSON", inst); }
    inline void select_generic_item_put::put_person_and_organization(person_and_organization inst) { putEntityInstance("PERSON_AND_ORGANIZATION", inst); }
    inline void select_generic_item_put::put_person_and_organization_role(person_and_organization_role inst) { putEntityInstance("PERSON_AND_ORGANIZATION_ROLE", inst); }
    inline void select_generic_item_put::put_representation(representation inst) { putEntityInstance("REPRESENTATION", inst); }
    inline void select_generic_item_put::put_representation_context(representation_context inst) { putEntityInstance("REPRESENTATION_CONTEXT", inst); }
    inline void select_generic_item_put::put_representation_item(representation_item inst) { putEntityInstance("REPRESENTATION_ITEM", inst); }
    inline void select_generic_item_put::put_representation_map(representation_map inst) { putEntityInstance("REPRESENTATION_MAP", inst); }
    inline void select_generic_item_put::put_representation_relationship(representation_relationship inst) { putEntityInstance("REPRESENTATION_RELATIONSHIP", inst); }
    inline void select_generic_item_put::put_role_association(role_association inst) { putEntityInstance("ROLE_ASSOCIATION", inst); }
    inline void select_generic_item_put::put_surface_patch(surface_patch inst) { putEntityInstance("SURFACE_PATCH", inst); }
    inline void select_generic_item_put::put_versioned_action_request(versioned_action_request inst) { putEntityInstance("VERSIONED_ACTION_REQUEST", inst); }
    inline assembly_design select_design_item::get_assembly_design() { return getEntityInstance("ASSEMBLY_DESIGN"); }
    inline void select_design_item::put_assembly_design(assembly_design inst) { putEntityInstance("ASSEMBLY_DESIGN", inst); }
    inline assembly_map select_design_item::get_assembly_map() { return getEntityInstance("ASSEMBLY_MAP"); }
    inline void select_design_item::put_assembly_map(assembly_map inst) { putEntityInstance("ASSEMBLY_MAP", inst); }
    inline assembly_relationship select_design_item::get_assembly_relationship() { return getEntityInstance("ASSEMBLY_RELATIONSHIP"); }
    inline void select_design_item::put_assembly_relationship(assembly_relationship inst) { putEntityInstance("ASSEMBLY_RELATIONSHIP", inst); }
    inline design_criterion select_design_item::get_design_criterion() { return getEntityInstance("DESIGN_CRITERION"); }
    inline void select_design_item::put_design_criterion(design_criterion inst) { putEntityInstance("DESIGN_CRITERION", inst); }
    inline design_joint_system select_design_item::get_design_joint_system() { return getEntityInstance("DESIGN_JOINT_SYSTEM"); }
    inline void select_design_item::put_design_joint_system(design_joint_system inst) { putEntityInstance("DESIGN_JOINT_SYSTEM", inst); }
    inline design_part select_design_item::get_design_part() { return getEntityInstance("DESIGN_PART"); }
    inline void select_design_item::put_design_part(design_part inst) { putEntityInstance("DESIGN_PART", inst); }
    inline design_result select_design_item::get_design_result() { return getEntityInstance("DESIGN_RESULT"); }
    inline void select_design_item::put_design_result(design_result inst) { putEntityInstance("DESIGN_RESULT", inst); }
    inline effective_buckling_length select_design_item::get_effective_buckling_length() { return getEntityInstance("EFFECTIVE_BUCKLING_LENGTH"); }
    inline void select_design_item::put_effective_buckling_length(effective_buckling_length inst) { putEntityInstance("EFFECTIVE_BUCKLING_LENGTH", inst); }
    inline functional_role select_design_item::get_functional_role() { return getEntityInstance("FUNCTIONAL_ROLE"); }
    inline void select_design_item::put_functional_role(functional_role inst) { putEntityInstance("FUNCTIONAL_ROLE", inst); }
    inline resistance select_design_item::get_resistance() { return getEntityInstance("RESISTANCE"); }
    inline void select_design_item::put_resistance(resistance inst) { putEntityInstance("RESISTANCE", inst); }
    inline restraint select_design_item::get_restraint() { return getEntityInstance("RESTRAINT"); }
    inline void select_design_item::put_restraint(restraint inst) { putEntityInstance("RESTRAINT", inst); }
    inline assembly_design select_design_item_get::get_assembly_design() { return getEntityInstance("ASSEMBLY_DESIGN"); }
    inline assembly_map select_design_item_get::get_assembly_map() { return getEntityInstance("ASSEMBLY_MAP"); }
    inline assembly_relationship select_design_item_get::get_assembly_relationship() { return getEntityInstance("ASSEMBLY_RELATIONSHIP"); }
    inline design_criterion select_design_item_get::get_design_criterion() { return getEntityInstance("DESIGN_CRITERION"); }
    inline design_joint_system select_design_item_get::get_design_joint_system() { return getEntityInstance("DESIGN_JOINT_SYSTEM"); }
    inline design_part select_design_item_get::get_design_part() { return getEntityInstance("DESIGN_PART"); }
    inline design_result select_design_item_get::get_design_result() { return getEntityInstance("DESIGN_RESULT"); }
    inline effective_buckling_length select_design_item_get::get_effective_buckling_length() { return getEntityInstance("EFFECTIVE_BUCKLING_LENGTH"); }
    inline functional_role select_design_item_get::get_functional_role() { return getEntityInstance("FUNCTIONAL_ROLE"); }
    inline resistance select_design_item_get::get_resistance() { return getEntityInstance("RESISTANCE"); }
    inline restraint select_design_item_get::get_restraint() { return getEntityInstance("RESTRAINT"); }
    inline void select_design_item_put::put_assembly_design(assembly_design inst) { putEntityInstance("ASSEMBLY_DESIGN", inst); }
    inline void select_design_item_put::put_assembly_map(assembly_map inst) { putEntityInstance("ASSEMBLY_MAP", inst); }
    inline void select_design_item_put::put_assembly_relationship(assembly_relationship inst) { putEntityInstance("ASSEMBLY_RELATIONSHIP", inst); }
    inline void select_design_item_put::put_design_criterion(design_criterion inst) { putEntityInstance("DESIGN_CRITERION", inst); }
    inline void select_design_item_put::put_design_joint_system(design_joint_system inst) { putEntityInstance("DESIGN_JOINT_SYSTEM", inst); }
    inline void select_design_item_put::put_design_part(design_part inst) { putEntityInstance("DESIGN_PART", inst); }
    inline void select_design_item_put::put_design_result(design_result inst) { putEntityInstance("DESIGN_RESULT", inst); }
    inline void select_design_item_put::put_effective_buckling_length(effective_buckling_length inst) { putEntityInstance("EFFECTIVE_BUCKLING_LENGTH", inst); }
    inline void select_design_item_put::put_functional_role(functional_role inst) { putEntityInstance("FUNCTIONAL_ROLE", inst); }
    inline void select_design_item_put::put_resistance(resistance inst) { putEntityInstance("RESISTANCE", inst); }
    inline void select_design_item_put::put_restraint(restraint inst) { putEntityInstance("RESTRAINT", inst); }
    inline located_item select_physical_item::get_located_item() { return getEntityInstance("LOCATED_ITEM"); }
    inline void select_physical_item::put_located_item(located_item inst) { putEntityInstance("LOCATED_ITEM", inst); }
    inline located_part_joint select_physical_item::get_located_part_joint() { return getEntityInstance("LOCATED_PART_JOINT"); }
    inline void select_physical_item::put_located_part_joint(located_part_joint inst) { putEntityInstance("LOCATED_PART_JOINT", inst); }
    inline located_item select_physical_item_get::get_located_item() { return getEntityInstance("LOCATED_ITEM"); }
    inline located_part_joint select_physical_item_get::get_located_part_joint() { return getEntityInstance("LOCATED_PART_JOINT"); }
    inline void select_physical_item_put::put_located_item(located_item inst) { putEntityInstance("LOCATED_ITEM", inst); }
    inline void select_physical_item_put::put_located_part_joint(located_part_joint inst) { putEntityInstance("LOCATED_PART_JOINT", inst); }
    inline assembly select_project_definition_item::get_assembly() { return getEntityInstance("ASSEMBLY"); }
    inline void select_project_definition_item::put_assembly(assembly inst) { putEntityInstance("ASSEMBLY", inst); }
    inline building select_project_definition_item::get_building() { return getEntityInstance("BUILDING"); }
    inline void select_project_definition_item::put_building(building inst) { putEntityInstance("BUILDING", inst); }
    inline building_complex select_project_definition_item::get_building_complex() { return getEntityInstance("BUILDING_COMPLEX"); }
    inline void select_project_definition_item::put_building_complex(building_complex inst) { putEntityInstance("BUILDING_COMPLEX", inst); }
    inline currency_measure_with_unit select_project_definition_item::get_currency_measure_with_unit() { return getEntityInstance("CURRENCY_MEASURE_WITH_UNIT"); }
    inline void select_project_definition_item::put_currency_measure_with_unit(currency_measure_with_unit inst) { putEntityInstance("CURRENCY_MEASURE_WITH_UNIT", inst); }
    inline project select_project_definition_item::get_project() { return getEntityInstance("PROJECT"); }
    inline void select_project_definition_item::put_project(project inst) { putEntityInstance("PROJECT", inst); }
    inline project_plan select_project_definition_item::get_project_plan() { return getEntityInstance("PROJECT_PLAN"); }
    inline void select_project_definition_item::put_project_plan(project_plan inst) { putEntityInstance("PROJECT_PLAN", inst); }
    inline project_plan_item select_project_definition_item::get_project_plan_item() { return getEntityInstance("PROJECT_PLAN_ITEM"); }
    inline void select_project_definition_item::put_project_plan_item(project_plan_item inst) { putEntityInstance("PROJECT_PLAN_ITEM", inst); }
    inline project_plan_item_relationship select_project_definition_item::get_project_plan_item_relationship() { return getEntityInstance("PROJECT_PLAN_ITEM_RELATIONSHIP"); }
    inline void select_project_definition_item::put_project_plan_item_relationship(project_plan_item_relationship inst) { putEntityInstance("PROJECT_PLAN_ITEM_RELATIONSHIP", inst); }
    inline project_organization select_project_definition_item::get_project_organization() { return getEntityInstance("PROJECT_ORGANIZATION"); }
    inline void select_project_definition_item::put_project_organization(project_organization inst) { putEntityInstance("PROJECT_ORGANIZATION", inst); }
    inline site select_project_definition_item::get_site() { return getEntityInstance("SITE"); }
    inline void select_project_definition_item::put_site(site inst) { putEntityInstance("SITE", inst); }
    inline structure select_project_definition_item::get_structure() { return getEntityInstance("STRUCTURE"); }
    inline void select_project_definition_item::put_structure(structure inst) { putEntityInstance("STRUCTURE", inst); }
    inline assembly select_project_definition_item_get::get_assembly() { return getEntityInstance("ASSEMBLY"); }
    inline building select_project_definition_item_get::get_building() { return getEntityInstance("BUILDING"); }
    inline building_complex select_project_definition_item_get::get_building_complex() { return getEntityInstance("BUILDING_COMPLEX"); }
    inline currency_measure_with_unit select_project_definition_item_get::get_currency_measure_with_unit() { return getEntityInstance("CURRENCY_MEASURE_WITH_UNIT"); }
    inline project select_project_definition_item_get::get_project() { return getEntityInstance("PROJECT"); }
    inline project_plan select_project_definition_item_get::get_project_plan() { return getEntityInstance("PROJECT_PLAN"); }
    inline project_plan_item select_project_definition_item_get::get_project_plan_item() { return getEntityInstance("PROJECT_PLAN_ITEM"); }
    inline project_plan_item_relationship select_project_definition_item_get::get_project_plan_item_relationship() { return getEntityInstance("PROJECT_PLAN_ITEM_RELATIONSHIP"); }
    inline project_organization select_project_definition_item_get::get_project_organization() { return getEntityInstance("PROJECT_ORGANIZATION"); }
    inline site select_project_definition_item_get::get_site() { return getEntityInstance("SITE"); }
    inline structure select_project_definition_item_get::get_structure() { return getEntityInstance("STRUCTURE"); }
    inline void select_project_definition_item_put::put_assembly(assembly inst) { putEntityInstance("ASSEMBLY", inst); }
    inline void select_project_definition_item_put::put_building(building inst) { putEntityInstance("BUILDING", inst); }
    inline void select_project_definition_item_put::put_building_complex(building_complex inst) { putEntityInstance("BUILDING_COMPLEX", inst); }
    inline void select_project_definition_item_put::put_currency_measure_with_unit(currency_measure_with_unit inst) { putEntityInstance("CURRENCY_MEASURE_WITH_UNIT", inst); }
    inline void select_project_definition_item_put::put_project(project inst) { putEntityInstance("PROJECT", inst); }
    inline void select_project_definition_item_put::put_project_plan(project_plan inst) { putEntityInstance("PROJECT_PLAN", inst); }
    inline void select_project_definition_item_put::put_project_plan_item(project_plan_item inst) { putEntityInstance("PROJECT_PLAN_ITEM", inst); }
    inline void select_project_definition_item_put::put_project_plan_item_relationship(project_plan_item_relationship inst) { putEntityInstance("PROJECT_PLAN_ITEM_RELATIONSHIP", inst); }
    inline void select_project_definition_item_put::put_project_organization(project_organization inst) { putEntityInstance("PROJECT_ORGANIZATION", inst); }
    inline void select_project_definition_item_put::put_site(site inst) { putEntityInstance("SITE", inst); }
    inline void select_project_definition_item_put::put_structure(structure inst) { putEntityInstance("STRUCTURE", inst); }
    inline coord_system select_structural_item::get_coord_system() { return getEntityInstance("COORD_SYSTEM"); }
    inline void select_structural_item::put_coord_system(coord_system inst) { putEntityInstance("COORD_SYSTEM", inst); }
    inline grid select_structural_item::get_grid() { return getEntityInstance("GRID"); }
    inline void select_structural_item::put_grid(grid inst) { putEntityInstance("GRID", inst); }
    inline grid_intersection select_structural_item::get_grid_intersection() { return getEntityInstance("GRID_INTERSECTION"); }
    inline void select_structural_item::put_grid_intersection(grid_intersection inst) { putEntityInstance("GRID_INTERSECTION", inst); }
    inline grid_offset select_structural_item::get_grid_offset() { return getEntityInstance("GRID_OFFSET"); }
    inline void select_structural_item::put_grid_offset(grid_offset inst) { putEntityInstance("GRID_OFFSET", inst); }
    inline geographical_location select_structural_item::get_geographical_location() { return getEntityInstance("GEOGRAPHICAL_LOCATION"); }
    inline void select_structural_item::put_geographical_location(geographical_location inst) { putEntityInstance("GEOGRAPHICAL_LOCATION", inst); }
    inline item_cost_code select_structural_item::get_item_cost_code() { return getEntityInstance("ITEM_COST_CODE"); }
    inline void select_structural_item::put_item_cost_code(item_cost_code inst) { putEntityInstance("ITEM_COST_CODE", inst); }
    inline item_cost_code_assigned select_structural_item::get_item_cost_code_assigned() { return getEntityInstance("ITEM_COST_CODE_ASSIGNED"); }
    inline void select_structural_item::put_item_cost_code_assigned(item_cost_code_assigned inst) { putEntityInstance("ITEM_COST_CODE_ASSIGNED", inst); }
    inline item_property select_structural_item::get_item_property() { return getEntityInstance("ITEM_PROPERTY"); }
    inline void select_structural_item::put_item_property(item_property inst) { putEntityInstance("ITEM_PROPERTY", inst); }
    inline item_property_assigned select_structural_item::get_item_property_assigned() { return getEntityInstance("ITEM_PROPERTY_ASSIGNED"); }
    inline void select_structural_item::put_item_property_assigned(item_property_assigned inst) { putEntityInstance("ITEM_PROPERTY_ASSIGNED", inst); }
    inline item_reference select_structural_item::get_item_reference() { return getEntityInstance("ITEM_REFERENCE"); }
    inline void select_structural_item::put_item_reference(item_reference inst) { putEntityInstance("ITEM_REFERENCE", inst); }
    inline item_reference_assigned select_structural_item::get_item_reference_assigned() { return getEntityInstance("ITEM_REFERENCE_ASSIGNED"); }
    inline void select_structural_item::put_item_reference_assigned(item_reference_assigned inst) { putEntityInstance("ITEM_REFERENCE_ASSIGNED", inst); }
    inline item_ref_source select_structural_item::get_item_ref_source() { return getEntityInstance("ITEM_REF_SOURCE"); }
    inline void select_structural_item::put_item_ref_source(item_ref_source inst) { putEntityInstance("ITEM_REF_SOURCE", inst); }
    inline item_ref_source_documented select_structural_item::get_item_ref_source_documented() { return getEntityInstance("ITEM_REF_SOURCE_DOCUMENTED"); }
    inline void select_structural_item::put_item_ref_source_documented(item_ref_source_documented inst) { putEntityInstance("ITEM_REF_SOURCE_DOCUMENTED", inst); }
    inline section_properties select_structural_item::get_section_properties() { return getEntityInstance("SECTION_PROPERTIES"); }
    inline void select_structural_item::put_section_properties(section_properties inst) { putEntityInstance("SECTION_PROPERTIES", inst); }
    inline setting_out_point select_structural_item::get_setting_out_point() { return getEntityInstance("SETTING_OUT_POINT"); }
    inline void select_structural_item::put_setting_out_point(setting_out_point inst) { putEntityInstance("SETTING_OUT_POINT", inst); }
    inline structural_frame_item select_structural_item::get_structural_frame_item() { return getEntityInstance("STRUCTURAL_FRAME_ITEM"); }
    inline void select_structural_item::put_structural_frame_item(structural_frame_item inst) { putEntityInstance("STRUCTURAL_FRAME_ITEM", inst); }
    inline structural_frame_item_approved select_structural_item::get_structural_frame_item_approved() { return getEntityInstance("STRUCTURAL_FRAME_ITEM_APPROVED"); }
    inline void select_structural_item::put_structural_frame_item_approved(structural_frame_item_approved inst) { putEntityInstance("STRUCTURAL_FRAME_ITEM_APPROVED", inst); }
    inline structural_frame_item_certified select_structural_item::get_structural_frame_item_certified() { return getEntityInstance("STRUCTURAL_FRAME_ITEM_CERTIFIED"); }
    inline void select_structural_item::put_structural_frame_item_certified(structural_frame_item_certified inst) { putEntityInstance("STRUCTURAL_FRAME_ITEM_CERTIFIED", inst); }
    inline structural_frame_item_documented select_structural_item::get_structural_frame_item_documented() { return getEntityInstance("STRUCTURAL_FRAME_ITEM_DOCUMENTED"); }
    inline void select_structural_item::put_structural_frame_item_documented(structural_frame_item_documented inst) { putEntityInstance("STRUCTURAL_FRAME_ITEM_DOCUMENTED", inst); }
    inline structural_frame_item_priced select_structural_item::get_structural_frame_item_priced() { return getEntityInstance("STRUCTURAL_FRAME_ITEM_PRICED"); }
    inline void select_structural_item::put_structural_frame_item_priced(structural_frame_item_priced inst) { putEntityInstance("STRUCTURAL_FRAME_ITEM_PRICED", inst); }
    inline structural_frame_item_relationship select_structural_item::get_structural_frame_item_relationship() { return getEntityInstance("STRUCTURAL_FRAME_ITEM_RELATIONSHIP"); }
    inline void select_structural_item::put_structural_frame_item_relationship(structural_frame_item_relationship inst) { putEntityInstance("STRUCTURAL_FRAME_ITEM_RELATIONSHIP", inst); }
    inline zone select_structural_item::get_zone() { return getEntityInstance("ZONE"); }
    inline void select_structural_item::put_zone(zone inst) { putEntityInstance("ZONE", inst); }
    inline coord_system select_structural_item_get::get_coord_system() { return getEntityInstance("COORD_SYSTEM"); }
    inline grid select_structural_item_get::get_grid() { return getEntityInstance("GRID"); }
    inline grid_intersection select_structural_item_get::get_grid_intersection() { return getEntityInstance("GRID_INTERSECTION"); }
    inline grid_offset select_structural_item_get::get_grid_offset() { return getEntityInstance("GRID_OFFSET"); }
    inline geographical_location select_structural_item_get::get_geographical_location() { return getEntityInstance("GEOGRAPHICAL_LOCATION"); }
    inline item_cost_code select_structural_item_get::get_item_cost_code() { return getEntityInstance("ITEM_COST_CODE"); }
    inline item_cost_code_assigned select_structural_item_get::get_item_cost_code_assigned() { return getEntityInstance("ITEM_COST_CODE_ASSIGNED"); }
    inline item_property select_structural_item_get::get_item_property() { return getEntityInstance("ITEM_PROPERTY"); }
    inline item_property_assigned select_structural_item_get::get_item_property_assigned() { return getEntityInstance("ITEM_PROPERTY_ASSIGNED"); }
    inline item_reference select_structural_item_get::get_item_reference() { return getEntityInstance("ITEM_REFERENCE"); }
    inline item_reference_assigned select_structural_item_get::get_item_reference_assigned() { return getEntityInstance("ITEM_REFERENCE_ASSIGNED"); }
    inline item_ref_source select_structural_item_get::get_item_ref_source() { return getEntityInstance("ITEM_REF_SOURCE"); }
    inline item_ref_source_documented select_structural_item_get::get_item_ref_source_documented() { return getEntityInstance("ITEM_REF_SOURCE_DOCUMENTED"); }
    inline section_properties select_structural_item_get::get_section_properties() { return getEntityInstance("SECTION_PROPERTIES"); }
    inline setting_out_point select_structural_item_get::get_setting_out_point() { return getEntityInstance("SETTING_OUT_POINT"); }
    inline structural_frame_item select_structural_item_get::get_structural_frame_item() { return getEntityInstance("STRUCTURAL_FRAME_ITEM"); }
    inline structural_frame_item_approved select_structural_item_get::get_structural_frame_item_approved() { return getEntityInstance("STRUCTURAL_FRAME_ITEM_APPROVED"); }
    inline structural_frame_item_certified select_structural_item_get::get_structural_frame_item_certified() { return getEntityInstance("STRUCTURAL_FRAME_ITEM_CERTIFIED"); }
    inline structural_frame_item_documented select_structural_item_get::get_structural_frame_item_documented() { return getEntityInstance("STRUCTURAL_FRAME_ITEM_DOCUMENTED"); }
    inline structural_frame_item_priced select_structural_item_get::get_structural_frame_item_priced() { return getEntityInstance("STRUCTURAL_FRAME_ITEM_PRICED"); }
    inline structural_frame_item_relationship select_structural_item_get::get_structural_frame_item_relationship() { return getEntityInstance("STRUCTURAL_FRAME_ITEM_RELATIONSHIP"); }
    inline zone select_structural_item_get::get_zone() { return getEntityInstance("ZONE"); }
    inline void select_structural_item_put::put_coord_system(coord_system inst) { putEntityInstance("COORD_SYSTEM", inst); }
    inline void select_structural_item_put::put_grid(grid inst) { putEntityInstance("GRID", inst); }
    inline void select_structural_item_put::put_grid_intersection(grid_intersection inst) { putEntityInstance("GRID_INTERSECTION", inst); }
    inline void select_structural_item_put::put_grid_offset(grid_offset inst) { putEntityInstance("GRID_OFFSET", inst); }
    inline void select_structural_item_put::put_geographical_location(geographical_location inst) { putEntityInstance("GEOGRAPHICAL_LOCATION", inst); }
    inline void select_structural_item_put::put_item_cost_code(item_cost_code inst) { putEntityInstance("ITEM_COST_CODE", inst); }
    inline void select_structural_item_put::put_item_cost_code_assigned(item_cost_code_assigned inst) { putEntityInstance("ITEM_COST_CODE_ASSIGNED", inst); }
    inline void select_structural_item_put::put_item_property(item_property inst) { putEntityInstance("ITEM_PROPERTY", inst); }
    inline void select_structural_item_put::put_item_property_assigned(item_property_assigned inst) { putEntityInstance("ITEM_PROPERTY_ASSIGNED", inst); }
    inline void select_structural_item_put::put_item_reference(item_reference inst) { putEntityInstance("ITEM_REFERENCE", inst); }
    inline void select_structural_item_put::put_item_reference_assigned(item_reference_assigned inst) { putEntityInstance("ITEM_REFERENCE_ASSIGNED", inst); }
    inline void select_structural_item_put::put_item_ref_source(item_ref_source inst) { putEntityInstance("ITEM_REF_SOURCE", inst); }
    inline void select_structural_item_put::put_item_ref_source_documented(item_ref_source_documented inst) { putEntityInstance("ITEM_REF_SOURCE_DOCUMENTED", inst); }
    inline void select_structural_item_put::put_section_properties(section_properties inst) { putEntityInstance("SECTION_PROPERTIES", inst); }
    inline void select_structural_item_put::put_setting_out_point(setting_out_point inst) { putEntityInstance("SETTING_OUT_POINT", inst); }
    inline void select_structural_item_put::put_structural_frame_item(structural_frame_item inst) { putEntityInstance("STRUCTURAL_FRAME_ITEM", inst); }
    inline void select_structural_item_put::put_structural_frame_item_approved(structural_frame_item_approved inst) { putEntityInstance("STRUCTURAL_FRAME_ITEM_APPROVED", inst); }
    inline void select_structural_item_put::put_structural_frame_item_certified(structural_frame_item_certified inst) { putEntityInstance("STRUCTURAL_FRAME_ITEM_CERTIFIED", inst); }
    inline void select_structural_item_put::put_structural_frame_item_documented(structural_frame_item_documented inst) { putEntityInstance("STRUCTURAL_FRAME_ITEM_DOCUMENTED", inst); }
    inline void select_structural_item_put::put_structural_frame_item_priced(structural_frame_item_priced inst) { putEntityInstance("STRUCTURAL_FRAME_ITEM_PRICED", inst); }
    inline void select_structural_item_put::put_structural_frame_item_relationship(structural_frame_item_relationship inst) { putEntityInstance("STRUCTURAL_FRAME_ITEM_RELATIONSHIP", inst); }
    inline void select_structural_item_put::put_zone(zone inst) { putEntityInstance("ZONE", inst); }
    inline managed_data_deleted select_data_item::get_managed_data_deleted() { return getEntityInstance("MANAGED_DATA_DELETED"); }
    inline void select_data_item::put_managed_data_deleted(managed_data_deleted inst) { putEntityInstance("MANAGED_DATA_DELETED", inst); }
    inline managed_data_deleted select_data_item_get::get_managed_data_deleted() { return getEntityInstance("MANAGED_DATA_DELETED"); }
    inline void select_data_item_put::put_managed_data_deleted(managed_data_deleted inst) { putEntityInstance("MANAGED_DATA_DELETED", inst); }
    inline managed_application_installation select_data_source::get_managed_application_installation() { return getEntityInstance("MANAGED_APPLICATION_INSTALLATION"); }
    inline void select_data_source::put_managed_application_installation(managed_application_installation inst) { putEntityInstance("MANAGED_APPLICATION_INSTALLATION", inst); }
    inline step_file select_data_source::get_step_file() { return getEntityInstance("STEP_FILE"); }
    inline void select_data_source::put_step_file(step_file inst) { putEntityInstance("STEP_FILE", inst); }
    inline managed_application_installation select_data_source_get::get_managed_application_installation() { return getEntityInstance("MANAGED_APPLICATION_INSTALLATION"); }
    inline step_file select_data_source_get::get_step_file() { return getEntityInstance("STEP_FILE"); }
    inline void select_data_source_put::put_managed_application_installation(managed_application_installation inst) { putEntityInstance("MANAGED_APPLICATION_INSTALLATION", inst); }
    inline void select_data_source_put::put_step_file(step_file inst) { putEntityInstance("STEP_FILE", inst); }
    inline vertex_shell shell::get_vertex_shell() { return getEntityInstance("VERTEX_SHELL"); }
    inline void shell::put_vertex_shell(vertex_shell inst) { putEntityInstance("VERTEX_SHELL", inst); }
    inline wire_shell shell::get_wire_shell() { return getEntityInstance("WIRE_SHELL"); }
    inline void shell::put_wire_shell(wire_shell inst) { putEntityInstance("WIRE_SHELL", inst); }
    inline open_shell shell::get_open_shell() { return getEntityInstance("OPEN_SHELL"); }
    inline void shell::put_open_shell(open_shell inst) { putEntityInstance("OPEN_SHELL", inst); }
    inline closed_shell shell::get_closed_shell() { return getEntityInstance("CLOSED_SHELL"); }
    inline void shell::put_closed_shell(closed_shell inst) { putEntityInstance("CLOSED_SHELL", inst); }
    inline vertex_shell shell_get::get_vertex_shell() { return getEntityInstance("VERTEX_SHELL"); }
    inline wire_shell shell_get::get_wire_shell() { return getEntityInstance("WIRE_SHELL"); }
    inline open_shell shell_get::get_open_shell() { return getEntityInstance("OPEN_SHELL"); }
    inline closed_shell shell_get::get_closed_shell() { return getEntityInstance("CLOSED_SHELL"); }
    inline void shell_put::put_vertex_shell(vertex_shell inst) { putEntityInstance("VERTEX_SHELL", inst); }
    inline void shell_put::put_wire_shell(wire_shell inst) { putEntityInstance("WIRE_SHELL", inst); }
    inline void shell_put::put_open_shell(open_shell inst) { putEntityInstance("OPEN_SHELL", inst); }
    inline void shell_put::put_closed_shell(closed_shell inst) { putEntityInstance("CLOSED_SHELL", inst); }
    inline site site_select::get_site() { return getEntityInstance("SITE"); }
    inline void site_select::put_site(site inst) { putEntityInstance("SITE", inst); }
    inline located_site site_select::get_located_site() { return getEntityInstance("LOCATED_SITE"); }
    inline void site_select::put_located_site(located_site inst) { putEntityInstance("LOCATED_SITE", inst); }
    inline zone_of_site site_select::get_zone_of_site() { return getEntityInstance("ZONE_OF_SITE"); }
    inline void site_select::put_zone_of_site(zone_of_site inst) { putEntityInstance("ZONE_OF_SITE", inst); }
    inline zone_of_building site_select::get_zone_of_building() { return getEntityInstance("ZONE_OF_BUILDING"); }
    inline void site_select::put_zone_of_building(zone_of_building inst) { putEntityInstance("ZONE_OF_BUILDING", inst); }
    inline building_complex site_select::get_building_complex() { return getEntityInstance("BUILDING_COMPLEX"); }
    inline void site_select::put_building_complex(building_complex inst) { putEntityInstance("BUILDING_COMPLEX", inst); }
    inline site site_select_get::get_site() { return getEntityInstance("SITE"); }
    inline located_site site_select_get::get_located_site() { return getEntityInstance("LOCATED_SITE"); }
    inline zone_of_site site_select_get::get_zone_of_site() { return getEntityInstance("ZONE_OF_SITE"); }
    inline zone_of_building site_select_get::get_zone_of_building() { return getEntityInstance("ZONE_OF_BUILDING"); }
    inline building_complex site_select_get::get_building_complex() { return getEntityInstance("BUILDING_COMPLEX"); }
    inline void site_select_put::put_site(site inst) { putEntityInstance("SITE", inst); }
    inline void site_select_put::put_located_site(located_site inst) { putEntityInstance("LOCATED_SITE", inst); }
    inline void site_select_put::put_zone_of_site(zone_of_site inst) { putEntityInstance("ZONE_OF_SITE", inst); }
    inline void site_select_put::put_zone_of_building(zone_of_building inst) { putEntityInstance("ZONE_OF_BUILDING", inst); }
    inline void site_select_put::put_building_complex(building_complex inst) { putEntityInstance("BUILDING_COMPLEX", inst); }
    inline structure structure_select::get_structure() { return getEntityInstance("STRUCTURE"); }
    inline void structure_select::put_structure(structure inst) { putEntityInstance("STRUCTURE", inst); }
    inline located_structure structure_select::get_located_structure() { return getEntityInstance("LOCATED_STRUCTURE"); }
    inline void structure_select::put_located_structure(located_structure inst) { putEntityInstance("LOCATED_STRUCTURE", inst); }
    inline zone_of_structure structure_select::get_zone_of_structure() { return getEntityInstance("ZONE_OF_STRUCTURE"); }
    inline void structure_select::put_zone_of_structure(zone_of_structure inst) { putEntityInstance("ZONE_OF_STRUCTURE", inst); }
    inline zone_of_building structure_select::get_zone_of_building() { return getEntityInstance("ZONE_OF_BUILDING"); }
    inline void structure_select::put_zone_of_building(zone_of_building inst) { putEntityInstance("ZONE_OF_BUILDING", inst); }
    inline located_assembly structure_select::get_located_assembly() { return getEntityInstance("LOCATED_ASSEMBLY"); }
    inline void structure_select::put_located_assembly(located_assembly inst) { putEntityInstance("LOCATED_ASSEMBLY", inst); }
    inline structure structure_select_get::get_structure() { return getEntityInstance("STRUCTURE"); }
    inline located_structure structure_select_get::get_located_structure() { return getEntityInstance("LOCATED_STRUCTURE"); }
    inline zone_of_structure structure_select_get::get_zone_of_structure() { return getEntityInstance("ZONE_OF_STRUCTURE"); }
    inline zone_of_building structure_select_get::get_zone_of_building() { return getEntityInstance("ZONE_OF_BUILDING"); }
    inline located_assembly structure_select_get::get_located_assembly() { return getEntityInstance("LOCATED_ASSEMBLY"); }
    inline void structure_select_put::put_structure(structure inst) { putEntityInstance("STRUCTURE", inst); }
    inline void structure_select_put::put_located_structure(located_structure inst) { putEntityInstance("LOCATED_STRUCTURE", inst); }
    inline void structure_select_put::put_zone_of_structure(zone_of_structure inst) { putEntityInstance("ZONE_OF_STRUCTURE", inst); }
    inline void structure_select_put::put_zone_of_building(zone_of_building inst) { putEntityInstance("ZONE_OF_BUILDING", inst); }
    inline void structure_select_put::put_located_assembly(located_assembly inst) { putEntityInstance("LOCATED_ASSEMBLY", inst); }
    inline shell_based_surface_model surface_model::get_shell_based_surface_model() { return getEntityInstance("SHELL_BASED_SURFACE_MODEL"); }
    inline void surface_model::put_shell_based_surface_model(shell_based_surface_model inst) { putEntityInstance("SHELL_BASED_SURFACE_MODEL", inst); }
    inline face_based_surface_model surface_model::get_face_based_surface_model() { return getEntityInstance("FACE_BASED_SURFACE_MODEL"); }
    inline void surface_model::put_face_based_surface_model(face_based_surface_model inst) { putEntityInstance("FACE_BASED_SURFACE_MODEL", inst); }
    inline shell_based_surface_model surface_model_get::get_shell_based_surface_model() { return getEntityInstance("SHELL_BASED_SURFACE_MODEL"); }
    inline face_based_surface_model surface_model_get::get_face_based_surface_model() { return getEntityInstance("FACE_BASED_SURFACE_MODEL"); }
    inline void surface_model_put::put_shell_based_surface_model(shell_based_surface_model inst) { putEntityInstance("SHELL_BASED_SURFACE_MODEL", inst); }
    inline void surface_model_put::put_face_based_surface_model(face_based_surface_model inst) { putEntityInstance("FACE_BASED_SURFACE_MODEL", inst); }
    inline item_defined_transformation transformation::get_item_defined_transformation() { return getEntityInstance("ITEM_DEFINED_TRANSFORMATION"); }
    inline void transformation::put_item_defined_transformation(item_defined_transformation inst) { putEntityInstance("ITEM_DEFINED_TRANSFORMATION", inst); }
    inline functionally_defined_transformation transformation::get_functionally_defined_transformation() { return getEntityInstance("FUNCTIONALLY_DEFINED_TRANSFORMATION"); }
    inline void transformation::put_functionally_defined_transformation(functionally_defined_transformation inst) { putEntityInstance("FUNCTIONALLY_DEFINED_TRANSFORMATION", inst); }
    inline item_defined_transformation transformation_get::get_item_defined_transformation() { return getEntityInstance("ITEM_DEFINED_TRANSFORMATION"); }
    inline functionally_defined_transformation transformation_get::get_functionally_defined_transformation() { return getEntityInstance("FUNCTIONALLY_DEFINED_TRANSFORMATION"); }
    inline void transformation_put::put_item_defined_transformation(item_defined_transformation inst) { putEntityInstance("ITEM_DEFINED_TRANSFORMATION", inst); }
    inline void transformation_put::put_functionally_defined_transformation(functionally_defined_transformation inst) { putEntityInstance("FUNCTIONALLY_DEFINED_TRANSFORMATION", inst); }
    inline cartesian_point trimming_select::get_cartesian_point() { return getEntityInstance("CARTESIAN_POINT"); }
    inline void trimming_select::put_cartesian_point(cartesian_point inst) { putEntityInstance("CARTESIAN_POINT", inst); }
    inline cartesian_point trimming_select_get::get_cartesian_point() { return getEntityInstance("CARTESIAN_POINT"); }
    inline void trimming_select_put::put_cartesian_point(cartesian_point inst) { putEntityInstance("CARTESIAN_POINT", inst); }
    inline named_unit unit::get_named_unit() { return getEntityInstance("NAMED_UNIT"); }
    inline void unit::put_named_unit(named_unit inst) { putEntityInstance("NAMED_UNIT", inst); }
    inline derived_unit unit::get_derived_unit() { return getEntityInstance("DERIVED_UNIT"); }
    inline void unit::put_derived_unit(derived_unit inst) { putEntityInstance("DERIVED_UNIT", inst); }
    inline named_unit unit_get::get_named_unit() { return getEntityInstance("NAMED_UNIT"); }
    inline derived_unit unit_get::get_derived_unit() { return getEntityInstance("DERIVED_UNIT"); }
    inline void unit_put::put_named_unit(named_unit inst) { putEntityInstance("NAMED_UNIT", inst); }
    inline void unit_put::put_derived_unit(derived_unit inst) { putEntityInstance("DERIVED_UNIT", inst); }
    inline direction vector_or_direction::get_direction() { return getEntityInstance("DIRECTION"); }
    inline void vector_or_direction::put_direction(direction inst) { putEntityInstance("DIRECTION", inst); }
    inline vector vector_or_direction::get_vector() { return getEntityInstance("VECTOR"); }
    inline void vector_or_direction::put_vector(vector inst) { putEntityInstance("VECTOR", inst); }
    inline direction vector_or_direction_get::get_direction() { return getEntityInstance("DIRECTION"); }
    inline vector vector_or_direction_get::get_vector() { return getEntityInstance("VECTOR"); }
    inline void vector_or_direction_put::put_direction(direction inst) { putEntityInstance("DIRECTION", inst); }
    inline void vector_or_direction_put::put_vector(vector inst) { putEntityInstance("VECTOR", inst); }
    inline shell_based_wireframe_model wireframe_model::get_shell_based_wireframe_model() { return getEntityInstance("SHELL_BASED_WIREFRAME_MODEL"); }
    inline void wireframe_model::put_shell_based_wireframe_model(shell_based_wireframe_model inst) { putEntityInstance("SHELL_BASED_WIREFRAME_MODEL", inst); }
    inline edge_based_wireframe_model wireframe_model::get_edge_based_wireframe_model() { return getEntityInstance("EDGE_BASED_WIREFRAME_MODEL"); }
    inline void wireframe_model::put_edge_based_wireframe_model(edge_based_wireframe_model inst) { putEntityInstance("EDGE_BASED_WIREFRAME_MODEL", inst); }
    inline shell_based_wireframe_model wireframe_model_get::get_shell_based_wireframe_model() { return getEntityInstance("SHELL_BASED_WIREFRAME_MODEL"); }
    inline edge_based_wireframe_model wireframe_model_get::get_edge_based_wireframe_model() { return getEntityInstance("EDGE_BASED_WIREFRAME_MODEL"); }
    inline void wireframe_model_put::put_shell_based_wireframe_model(shell_based_wireframe_model inst) { putEntityInstance("SHELL_BASED_WIREFRAME_MODEL", inst); }
    inline void wireframe_model_put::put_edge_based_wireframe_model(edge_based_wireframe_model inst) { putEntityInstance("EDGE_BASED_WIREFRAME_MODEL", inst); }
    inline action_method action::get_chosen_method() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "chosen_method", sdaiINSTANCE, &inst); return inst; }
    inline void action::put_chosen_method(action_method inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "chosen_method", sdaiINSTANCE, (void*) i); }
    inline analysis_method analysis_model::get_method_of_analysis() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "method_of_analysis", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_model::put_method_of_analysis(analysis_method inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "method_of_analysis", sdaiINSTANCE, (void*) i); }
    inline analysis_model analysis_model_child::get_parent_model() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "parent_model", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_model_child::put_parent_model(analysis_model inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "parent_model", sdaiINSTANCE, (void*) i); }
    inline coord_system analysis_model_located::get_model_coord_sys() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "model_coord_sys", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_model_located::put_model_coord_sys(coord_system inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "model_coord_sys", sdaiINSTANCE, (void*) i); }
    inline analysis_model analysis_model_mapping::get_mapped_analysis_model() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "mapped_analysis_model", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_model_mapping::put_mapped_analysis_model(analysis_model inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "mapped_analysis_model", sdaiINSTANCE, (void*) i); }
    inline analysis_model analysis_model_relationship::get_relating_model() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "relating_model", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_model_relationship::put_relating_model(analysis_model inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "relating_model", sdaiINSTANCE, (void*) i); }
    inline analysis_model analysis_model_relationship::get_related_model() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "related_model", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_model_relationship::put_related_model(analysis_model inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "related_model", sdaiINSTANCE, (void*) i); }
    inline analysis_method analysis_result::get_results_for_analysis() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "results_for_analysis", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result::put_results_for_analysis(analysis_method inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "results_for_analysis", sdaiINSTANCE, (void*) i); }
    inline element_curve analysis_result_element_curve::get_result_for_element_curve() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "result_for_element_curve", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_curve::put_result_for_element_curve(element_curve inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "result_for_element_curve", sdaiINSTANCE, (void*) i); }
    inline reaction analysis_result_element_curve::get_result_values() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "result_values", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_curve::put_result_values(reaction inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "result_values", sdaiINSTANCE, (void*) i); }
    inline length_measure_with_unit analysis_result_element_curve::get_result_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "result_position", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_curve::put_result_position(length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "result_position", sdaiINSTANCE, (void*) i); }
    inline element_node_connectivity analysis_result_element_node::get_result_for_element_node() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "result_for_element_node", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_node::put_result_for_element_node(element_node_connectivity inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "result_for_element_node", sdaiINSTANCE, (void*) i); }
    inline reaction analysis_result_element_node::get_result_values() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "result_values", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_node::put_result_values(reaction inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "result_values", sdaiINSTANCE, (void*) i); }
    inline element_point analysis_result_element_point::get_result_for_element_point() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "result_for_element_point", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_point::put_result_for_element_point(element_point inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "result_for_element_point", sdaiINSTANCE, (void*) i); }
    inline reaction analysis_result_element_point::get_result_values() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "result_values", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_point::put_result_values(reaction inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "result_values", sdaiINSTANCE, (void*) i); }
    inline element_surface analysis_result_element_surface::get_result_for_element_surface() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "result_for_element_surface", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_surface::put_result_for_element_surface(element_surface inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "result_for_element_surface", sdaiINSTANCE, (void*) i); }
    inline point analysis_result_element_surface::get_result_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "result_position", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_surface::put_result_position(point inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "result_position", sdaiINSTANCE, (void*) i); }
    inline pressure_measure_with_unit analysis_result_element_surface_stresses::get_direct_stress_sigma_y() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "direct_stress_sigma_y", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_surface_stresses::put_direct_stress_sigma_y(pressure_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "direct_stress_sigma_y", sdaiINSTANCE, (void*) i); }
    inline pressure_measure_with_unit analysis_result_element_surface_stresses::get_membrane_stress_tau_yz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "membrane_stress_tau_yz", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_surface_stresses::put_membrane_stress_tau_yz(pressure_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "membrane_stress_tau_yz", sdaiINSTANCE, (void*) i); }
    inline pressure_measure_with_unit analysis_result_element_surface_stresses::get_direct_stress_sigma_z() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "direct_stress_sigma_z", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_surface_stresses::put_direct_stress_sigma_z(pressure_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "direct_stress_sigma_z", sdaiINSTANCE, (void*) i); }
    inline force_per_length_measure_with_unit analysis_result_element_surface_tractions::get_thrust_tz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "thrust_tz", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_surface_tractions::put_thrust_tz(force_per_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "thrust_tz", sdaiINSTANCE, (void*) i); }
    inline force_measure_with_unit analysis_result_element_surface_tractions::get_bending_traction_my() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "bending_traction_my", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_surface_tractions::put_bending_traction_my(force_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "bending_traction_my", sdaiINSTANCE, (void*) i); }
    inline force_per_length_measure_with_unit analysis_result_element_surface_tractions::get_thrust_ty() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "thrust_ty", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_surface_tractions::put_thrust_ty(force_per_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "thrust_ty", sdaiINSTANCE, (void*) i); }
    inline force_measure_with_unit analysis_result_element_surface_tractions::get_torsional_traction_mzy() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "torsional_traction_mzy", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_surface_tractions::put_torsional_traction_mzy(force_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "torsional_traction_mzy", sdaiINSTANCE, (void*) i); }
    inline force_measure_with_unit analysis_result_element_surface_tractions::get_torsional_traction_myz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "torsional_traction_myz", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_surface_tractions::put_torsional_traction_myz(force_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "torsional_traction_myz", sdaiINSTANCE, (void*) i); }
    inline force_per_length_measure_with_unit analysis_result_element_surface_tractions::get_shear_traction_qz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "shear_traction_qz", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_surface_tractions::put_shear_traction_qz(force_per_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "shear_traction_qz", sdaiINSTANCE, (void*) i); }
    inline force_per_length_measure_with_unit analysis_result_element_surface_tractions::get_shear_traction_qy() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "shear_traction_qy", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_surface_tractions::put_shear_traction_qy(force_per_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "shear_traction_qy", sdaiINSTANCE, (void*) i); }
    inline force_measure_with_unit analysis_result_element_surface_tractions::get_bending_traction_mz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "bending_traction_mz", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_surface_tractions::put_bending_traction_mz(force_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "bending_traction_mz", sdaiINSTANCE, (void*) i); }
    inline element_volume analysis_result_element_volume::get_result_for_element_volume() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "result_for_element_volume", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_volume::put_result_for_element_volume(element_volume inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "result_for_element_volume", sdaiINSTANCE, (void*) i); }
    inline point analysis_result_element_volume::get_result_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "result_position", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_volume::put_result_position(point inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "result_position", sdaiINSTANCE, (void*) i); }
    inline pressure_measure_with_unit analysis_result_element_volume_stress_tensor::get_shear_stress_tau_zy() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "shear_stress_tau_zy", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_volume_stress_tensor::put_shear_stress_tau_zy(pressure_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "shear_stress_tau_zy", sdaiINSTANCE, (void*) i); }
    inline pressure_measure_with_unit analysis_result_element_volume_stress_tensor::get_shear_stress_tau_xz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "shear_stress_tau_xz", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_volume_stress_tensor::put_shear_stress_tau_xz(pressure_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "shear_stress_tau_xz", sdaiINSTANCE, (void*) i); }
    inline pressure_measure_with_unit analysis_result_element_volume_stress_tensor::get_normal_stress_sigma_z() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "normal_stress_sigma_z", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_volume_stress_tensor::put_normal_stress_sigma_z(pressure_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "normal_stress_sigma_z", sdaiINSTANCE, (void*) i); }
    inline pressure_measure_with_unit analysis_result_element_volume_stress_tensor::get_normal_stress_sigma_y() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "normal_stress_sigma_y", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_volume_stress_tensor::put_normal_stress_sigma_y(pressure_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "normal_stress_sigma_y", sdaiINSTANCE, (void*) i); }
    inline pressure_measure_with_unit analysis_result_element_volume_stress_tensor::get_normal_stress_sigma_x() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "normal_stress_sigma_x", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_volume_stress_tensor::put_normal_stress_sigma_x(pressure_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "normal_stress_sigma_x", sdaiINSTANCE, (void*) i); }
    inline pressure_measure_with_unit analysis_result_element_volume_stress_tensor::get_shear_stress_tau_zx() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "shear_stress_tau_zx", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_volume_stress_tensor::put_shear_stress_tau_zx(pressure_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "shear_stress_tau_zx", sdaiINSTANCE, (void*) i); }
    inline pressure_measure_with_unit analysis_result_element_volume_stress_tensor::get_shear_stress_tau_yz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "shear_stress_tau_yz", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_volume_stress_tensor::put_shear_stress_tau_yz(pressure_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "shear_stress_tau_yz", sdaiINSTANCE, (void*) i); }
    inline pressure_measure_with_unit analysis_result_element_volume_stress_tensor::get_shear_stress_tau_yx() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "shear_stress_tau_yx", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_volume_stress_tensor::put_shear_stress_tau_yx(pressure_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "shear_stress_tau_yx", sdaiINSTANCE, (void*) i); }
    inline pressure_measure_with_unit analysis_result_element_volume_stress_tensor::get_shear_stress_tau_xy() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "shear_stress_tau_xy", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_element_volume_stress_tensor::put_shear_stress_tau_xy(pressure_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "shear_stress_tau_xy", sdaiINSTANCE, (void*) i); }
    inline node analysis_result_node::get_result_for_node() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "result_for_node", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_node::put_result_for_node(node inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "result_for_node", sdaiINSTANCE, (void*) i); }
    inline reaction analysis_result_node::get_result_values() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "result_values", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_result_node::put_result_values(reaction inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "result_values", sdaiINSTANCE, (void*) i); }
    inline load_case analysis_results_set_basic::get_basic_load_case() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "basic_load_case", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_results_set_basic::put_basic_load_case(load_case inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "basic_load_case", sdaiINSTANCE, (void*) i); }
    inline loading_combination analysis_results_set_combined::get_loading_combination_ref() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "loading_combination_ref", sdaiINSTANCE, &inst); return inst; }
    inline void analysis_results_set_combined::put_loading_combination_ref(loading_combination inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "loading_combination_ref", sdaiINSTANCE, (void*) i); }
    inline applied_load_static applied_load_dynamic::get_initial_value() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "initial_value", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_dynamic::put_initial_value(applied_load_static inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "initial_value", sdaiINSTANCE, (void*) i); }
    inline applied_load_static applied_load_dynamic::get_final_value() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "final_value", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_dynamic::put_final_value(applied_load_static inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "final_value", sdaiINSTANCE, (void*) i); }
    inline applied_load_static applied_load_dynamic::get_maximum_value() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "maximum_value", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_dynamic::put_maximum_value(applied_load_static inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "maximum_value", sdaiINSTANCE, (void*) i); }
    inline applied_load_static applied_load_dynamic::get_minimum_value() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "minimum_value", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_dynamic::put_minimum_value(applied_load_static inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "minimum_value", sdaiINSTANCE, (void*) i); }
    inline time_measure_with_unit applied_load_dynamic::get_load_duration() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "load_duration", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_dynamic::put_load_duration(time_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "load_duration", sdaiINSTANCE, (void*) i); }
    inline frequency_measure_with_unit applied_load_dynamic::get_load_frequency() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "load_frequency", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_dynamic::put_load_frequency(frequency_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "load_frequency", sdaiINSTANCE, (void*) i); }
    inline linear_acceleration_measure_with_unit applied_load_dynamic_acceleration::get_preset_acceleration_ax() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "preset_acceleration_ax", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_dynamic_acceleration::put_preset_acceleration_ax(linear_acceleration_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "preset_acceleration_ax", sdaiINSTANCE, (void*) i); }
    inline linear_acceleration_measure_with_unit applied_load_dynamic_acceleration::get_preset_acceleration_ay() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "preset_acceleration_ay", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_dynamic_acceleration::put_preset_acceleration_ay(linear_acceleration_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "preset_acceleration_ay", sdaiINSTANCE, (void*) i); }
    inline linear_acceleration_measure_with_unit applied_load_dynamic_acceleration::get_preset_acceleration_az() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "preset_acceleration_az", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_dynamic_acceleration::put_preset_acceleration_az(linear_acceleration_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "preset_acceleration_az", sdaiINSTANCE, (void*) i); }
    inline rotational_acceleration_measure_with_unit applied_load_dynamic_acceleration::get_preset_acceleration_arx() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "preset_acceleration_arx", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_dynamic_acceleration::put_preset_acceleration_arx(rotational_acceleration_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "preset_acceleration_arx", sdaiINSTANCE, (void*) i); }
    inline rotational_acceleration_measure_with_unit applied_load_dynamic_acceleration::get_preset_acceleration_ary() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "preset_acceleration_ary", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_dynamic_acceleration::put_preset_acceleration_ary(rotational_acceleration_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "preset_acceleration_ary", sdaiINSTANCE, (void*) i); }
    inline rotational_acceleration_measure_with_unit applied_load_dynamic_acceleration::get_preset_acceleration_arz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "preset_acceleration_arz", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_dynamic_acceleration::put_preset_acceleration_arz(rotational_acceleration_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "preset_acceleration_arz", sdaiINSTANCE, (void*) i); }
    inline linear_velocity_measure_with_unit applied_load_dynamic_velocity::get_preset_velocity_vx() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "preset_velocity_vx", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_dynamic_velocity::put_preset_velocity_vx(linear_velocity_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "preset_velocity_vx", sdaiINSTANCE, (void*) i); }
    inline linear_velocity_measure_with_unit applied_load_dynamic_velocity::get_preset_velocity_vy() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "preset_velocity_vy", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_dynamic_velocity::put_preset_velocity_vy(linear_velocity_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "preset_velocity_vy", sdaiINSTANCE, (void*) i); }
    inline linear_velocity_measure_with_unit applied_load_dynamic_velocity::get_preset_velocity_vz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "preset_velocity_vz", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_dynamic_velocity::put_preset_velocity_vz(linear_velocity_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "preset_velocity_vz", sdaiINSTANCE, (void*) i); }
    inline rotational_velocity_measure_with_unit applied_load_dynamic_velocity::get_preset_velocity_vrx() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "preset_velocity_vrx", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_dynamic_velocity::put_preset_velocity_vrx(rotational_velocity_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "preset_velocity_vrx", sdaiINSTANCE, (void*) i); }
    inline rotational_velocity_measure_with_unit applied_load_dynamic_velocity::get_preset_velocity_vry() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "preset_velocity_vry", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_dynamic_velocity::put_preset_velocity_vry(rotational_velocity_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "preset_velocity_vry", sdaiINSTANCE, (void*) i); }
    inline rotational_velocity_measure_with_unit applied_load_dynamic_velocity::get_preset_velocity_vrz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "preset_velocity_vrz", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_dynamic_velocity::put_preset_velocity_vrz(rotational_velocity_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "preset_velocity_vrz", sdaiINSTANCE, (void*) i); }
    inline length_measure_with_unit applied_load_static_displacement::get_preset_displacement_dx() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "preset_displacement_dx", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_static_displacement::put_preset_displacement_dx(length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "preset_displacement_dx", sdaiINSTANCE, (void*) i); }
    inline length_measure_with_unit applied_load_static_displacement::get_preset_displacement_dy() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "preset_displacement_dy", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_static_displacement::put_preset_displacement_dy(length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "preset_displacement_dy", sdaiINSTANCE, (void*) i); }
    inline length_measure_with_unit applied_load_static_displacement::get_preset_displacement_dz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "preset_displacement_dz", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_static_displacement::put_preset_displacement_dz(length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "preset_displacement_dz", sdaiINSTANCE, (void*) i); }
    inline plane_angle_measure_with_unit applied_load_static_displacement::get_preset_displacement_rx() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "preset_displacement_rx", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_static_displacement::put_preset_displacement_rx(plane_angle_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "preset_displacement_rx", sdaiINSTANCE, (void*) i); }
    inline plane_angle_measure_with_unit applied_load_static_displacement::get_preset_displacement_ry() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "preset_displacement_ry", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_static_displacement::put_preset_displacement_ry(plane_angle_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "preset_displacement_ry", sdaiINSTANCE, (void*) i); }
    inline plane_angle_measure_with_unit applied_load_static_displacement::get_preset_displacement_rz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "preset_displacement_rz", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_static_displacement::put_preset_displacement_rz(plane_angle_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "preset_displacement_rz", sdaiINSTANCE, (void*) i); }
    inline force_measure_with_unit applied_load_static_force::get_applied_force_fx() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "applied_force_fx", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_static_force::put_applied_force_fx(force_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "applied_force_fx", sdaiINSTANCE, (void*) i); }
    inline force_measure_with_unit applied_load_static_force::get_applied_force_fy() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "applied_force_fy", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_static_force::put_applied_force_fy(force_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "applied_force_fy", sdaiINSTANCE, (void*) i); }
    inline force_measure_with_unit applied_load_static_force::get_applied_force_fz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "applied_force_fz", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_static_force::put_applied_force_fz(force_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "applied_force_fz", sdaiINSTANCE, (void*) i); }
    inline moment_measure_with_unit applied_load_static_force::get_applied_moment_mx() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "applied_moment_mx", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_static_force::put_applied_moment_mx(moment_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "applied_moment_mx", sdaiINSTANCE, (void*) i); }
    inline moment_measure_with_unit applied_load_static_force::get_applied_moment_my() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "applied_moment_my", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_static_force::put_applied_moment_my(moment_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "applied_moment_my", sdaiINSTANCE, (void*) i); }
    inline moment_measure_with_unit applied_load_static_force::get_applied_moment_mz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "applied_moment_mz", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_static_force::put_applied_moment_mz(moment_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "applied_moment_mz", sdaiINSTANCE, (void*) i); }
    inline pressure_measure_with_unit applied_load_static_pressure::get_applied_pressure_px() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "applied_pressure_px", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_static_pressure::put_applied_pressure_px(pressure_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "applied_pressure_px", sdaiINSTANCE, (void*) i); }
    inline pressure_measure_with_unit applied_load_static_pressure::get_applied_pressure_py() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "applied_pressure_py", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_static_pressure::put_applied_pressure_py(pressure_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "applied_pressure_py", sdaiINSTANCE, (void*) i); }
    inline pressure_measure_with_unit applied_load_static_pressure::get_applied_pressure_pz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "applied_pressure_pz", sdaiINSTANCE, &inst); return inst; }
    inline void applied_load_static_pressure::put_applied_pressure_pz(pressure_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "applied_pressure_pz", sdaiINSTANCE, (void*) i); }
    inline approval_status approval::get_status() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "status", sdaiINSTANCE, &inst); return inst; }
    inline void approval::put_status(approval_status inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "status", sdaiINSTANCE, (void*) i); }
    inline dimensional_exponents named_unit::get_dimensions() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "dimensions", sdaiINSTANCE, &inst); return inst; }
    inline void named_unit::put_dimensions(dimensional_exponents inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "dimensions", sdaiINSTANCE, (void*) i); }
    inline organizational_address structural_frame_process::get_place_of_process() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "place_of_process", sdaiINSTANCE, &inst); return inst; }
    inline void structural_frame_process::put_place_of_process(organizational_address inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "place_of_process", sdaiINSTANCE, (void*) i); }
    inline located_assembly assemble::get_resulting_assembly() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "resulting_assembly", sdaiINSTANCE, &inst); return inst; }
    inline void assemble::put_resulting_assembly(located_assembly inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "resulting_assembly", sdaiINSTANCE, (void*) i); }
    inline assembly_design_structural_member assembly_design_structural_connection_external::get_connected_member() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "connected_member", sdaiINSTANCE, &inst); return inst; }
    inline void assembly_design_structural_connection_external::put_connected_member(assembly_design_structural_member inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "connected_member", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit assembly_design_structural_member_linear_cambered_absolute::get_absolute_offset_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "absolute_offset_position", sdaiINSTANCE, &inst); return inst; }
    inline void assembly_design_structural_member_linear_cambered_absolute::put_absolute_offset_position(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "absolute_offset_position", sdaiINSTANCE, (void*) i); }
    inline length_measure_with_unit assembly_design_structural_member_linear_cambered_absolute::get_absolute_offset_y() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "absolute_offset_y", sdaiINSTANCE, &inst); return inst; }
    inline void assembly_design_structural_member_linear_cambered_absolute::put_absolute_offset_y(length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "absolute_offset_y", sdaiINSTANCE, (void*) i); }
    inline length_measure_with_unit assembly_design_structural_member_linear_cambered_absolute::get_absolute_offset_z() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "absolute_offset_z", sdaiINSTANCE, &inst); return inst; }
    inline void assembly_design_structural_member_linear_cambered_absolute::put_absolute_offset_z(length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "absolute_offset_z", sdaiINSTANCE, (void*) i); }
    inline ratio_measure_with_unit assembly_design_structural_member_linear_cambered_relative::get_relative_offset_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "relative_offset_position", sdaiINSTANCE, &inst); return inst; }
    inline void assembly_design_structural_member_linear_cambered_relative::put_relative_offset_position(ratio_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "relative_offset_position", sdaiINSTANCE, (void*) i); }
    inline ratio_measure_with_unit assembly_design_structural_member_linear_cambered_relative::get_relative_offset_y() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "relative_offset_y", sdaiINSTANCE, &inst); return inst; }
    inline void assembly_design_structural_member_linear_cambered_relative::put_relative_offset_y(ratio_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "relative_offset_y", sdaiINSTANCE, (void*) i); }
    inline ratio_measure_with_unit assembly_design_structural_member_linear_cambered_relative::get_relative_offset_z() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "relative_offset_z", sdaiINSTANCE, &inst); return inst; }
    inline void assembly_design_structural_member_linear_cambered_relative::put_relative_offset_z(ratio_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "relative_offset_z", sdaiINSTANCE, (void*) i); }
    inline assembly_manufacturing assembly_manufacturing_child::get_parent_assembly() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "parent_assembly", sdaiINSTANCE, &inst); return inst; }
    inline void assembly_manufacturing_child::put_parent_assembly(assembly_manufacturing inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "parent_assembly", sdaiINSTANCE, (void*) i); }
    inline assembly assembly_map::get_represented_assembly() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "represented_assembly", sdaiINSTANCE, &inst); return inst; }
    inline void assembly_map::put_represented_assembly(assembly inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "represented_assembly", sdaiINSTANCE, (void*) i); }
    inline assembly assembly_relationship::get_related_assembly() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "related_assembly", sdaiINSTANCE, &inst); return inst; }
    inline void assembly_relationship::put_related_assembly(assembly inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "related_assembly", sdaiINSTANCE, (void*) i); }
    inline assembly assembly_relationship::get_relating_assembly() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "relating_assembly", sdaiINSTANCE, &inst); return inst; }
    inline void assembly_relationship::put_relating_assembly(assembly inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "relating_assembly", sdaiINSTANCE, (void*) i); }
    inline shape_representation_with_units assembly_with_shape::get_shape() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "shape", sdaiINSTANCE, &inst); return inst; }
    inline void assembly_with_shape::put_shape(shape_representation_with_units inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "shape", sdaiINSTANCE, (void*) i); }
    inline cartesian_point placement::get_location() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "location", sdaiINSTANCE, &inst); return inst; }
    inline void placement::put_location(cartesian_point inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "location", sdaiINSTANCE, (void*) i); }
    inline direction axis1_placement::get_axis() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "axis", sdaiINSTANCE, &inst); return inst; }
    inline void axis1_placement::put_axis(direction inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "axis", sdaiINSTANCE, (void*) i); }
    inline direction axis2_placement_2d::get_ref_direction() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "ref_direction", sdaiINSTANCE, &inst); return inst; }
    inline void axis2_placement_2d::put_ref_direction(direction inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "ref_direction", sdaiINSTANCE, (void*) i); }
    inline direction axis2_placement_3d::get_axis() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "axis", sdaiINSTANCE, &inst); return inst; }
    inline void axis2_placement_3d::put_axis(direction inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "axis", sdaiINSTANCE, (void*) i); }
    inline direction axis2_placement_3d::get_ref_direction() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "ref_direction", sdaiINSTANCE, &inst); return inst; }
    inline void axis2_placement_3d::put_ref_direction(direction inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "ref_direction", sdaiINSTANCE, (void*) i); }
    inline axis2_placement_3d block::get_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "position", sdaiINSTANCE, &inst); return inst; }
    inline void block::put_position(axis2_placement_3d inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "position", sdaiINSTANCE, (void*) i); }
    inline axis2_placement_3d block_volume::get_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "position", sdaiINSTANCE, &inst); return inst; }
    inline void block_volume::put_position(axis2_placement_3d inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "position", sdaiINSTANCE, (void*) i); }
    inline plane_angle_measure_with_unit boundary_condition_skewed::get_x_skew_angle() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "x_skew_angle", sdaiINSTANCE, &inst); return inst; }
    inline void boundary_condition_skewed::put_x_skew_angle(plane_angle_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "x_skew_angle", sdaiINSTANCE, (void*) i); }
    inline plane_angle_measure_with_unit boundary_condition_skewed::get_y_skew_angle() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "y_skew_angle", sdaiINSTANCE, &inst); return inst; }
    inline void boundary_condition_skewed::put_y_skew_angle(plane_angle_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "y_skew_angle", sdaiINSTANCE, (void*) i); }
    inline plane_angle_measure_with_unit boundary_condition_skewed::get_z_skew_angle() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "z_skew_angle", sdaiINSTANCE, &inst); return inst; }
    inline void boundary_condition_skewed::put_z_skew_angle(plane_angle_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "z_skew_angle", sdaiINSTANCE, (void*) i); }
    inline linear_stiffness_measure_with_unit boundary_condition_spring_linear::get_bc_x_displacement() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "bc_x_displacement", sdaiINSTANCE, &inst); return inst; }
    inline void boundary_condition_spring_linear::put_bc_x_displacement(linear_stiffness_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "bc_x_displacement", sdaiINSTANCE, (void*) i); }
    inline linear_stiffness_measure_with_unit boundary_condition_spring_linear::get_bc_y_displacement() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "bc_y_displacement", sdaiINSTANCE, &inst); return inst; }
    inline void boundary_condition_spring_linear::put_bc_y_displacement(linear_stiffness_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "bc_y_displacement", sdaiINSTANCE, (void*) i); }
    inline linear_stiffness_measure_with_unit boundary_condition_spring_linear::get_bc_z_displacement() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "bc_z_displacement", sdaiINSTANCE, &inst); return inst; }
    inline void boundary_condition_spring_linear::put_bc_z_displacement(linear_stiffness_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "bc_z_displacement", sdaiINSTANCE, (void*) i); }
    inline rotational_stiffness_measure_with_unit boundary_condition_spring_linear::get_bc_x_rotation() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "bc_x_rotation", sdaiINSTANCE, &inst); return inst; }
    inline void boundary_condition_spring_linear::put_bc_x_rotation(rotational_stiffness_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "bc_x_rotation", sdaiINSTANCE, (void*) i); }
    inline rotational_stiffness_measure_with_unit boundary_condition_spring_linear::get_bc_y_rotation() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "bc_y_rotation", sdaiINSTANCE, &inst); return inst; }
    inline void boundary_condition_spring_linear::put_bc_y_rotation(rotational_stiffness_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "bc_y_rotation", sdaiINSTANCE, (void*) i); }
    inline rotational_stiffness_measure_with_unit boundary_condition_spring_linear::get_bc_z_rotation() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "bc_z_rotation", sdaiINSTANCE, &inst); return inst; }
    inline void boundary_condition_spring_linear::put_bc_z_rotation(rotational_stiffness_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "bc_z_rotation", sdaiINSTANCE, (void*) i); }
    inline rotational_stiffness_measure_with_unit boundary_condition_warping::get_bc_warping() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "bc_warping", sdaiINSTANCE, &inst); return inst; }
    inline void boundary_condition_warping::put_bc_warping(rotational_stiffness_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "bc_warping", sdaiINSTANCE, (void*) i); }
    inline surface pcurve::get_basis_surface() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "basis_surface", sdaiINSTANCE, &inst); return inst; }
    inline void pcurve::put_basis_surface(surface inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "basis_surface", sdaiINSTANCE, (void*) i); }
    inline definitional_representation pcurve::get_reference_to_curve() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reference_to_curve", sdaiINSTANCE, &inst); return inst; }
    inline void pcurve::put_reference_to_curve(definitional_representation inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reference_to_curve", sdaiINSTANCE, (void*) i); }
    inline curve surface_curve::get_curve_3d() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "curve_3d", sdaiINSTANCE, &inst); return inst; }
    inline void surface_curve::put_curve_3d(curve inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "curve_3d", sdaiINSTANCE, (void*) i); }
    inline cartesian_point box_domain::get_corner() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "corner", sdaiINSTANCE, &inst); return inst; }
    inline void box_domain::put_corner(cartesian_point inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "corner", sdaiINSTANCE, (void*) i); }
    inline surface half_space_solid::get_base_surface() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "base_surface", sdaiINSTANCE, &inst); return inst; }
    inline void half_space_solid::put_base_surface(surface inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "base_surface", sdaiINSTANCE, (void*) i); }
    inline box_domain boxed_half_space::get_enclosure() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "enclosure", sdaiINSTANCE, &inst); return inst; }
    inline void boxed_half_space::put_enclosure(box_domain inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "enclosure", sdaiINSTANCE, (void*) i); }
    inline face brep_2d::get_extent() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "extent", sdaiINSTANCE, &inst); return inst; }
    inline void brep_2d::put_extent(face inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "extent", sdaiINSTANCE, (void*) i); }
    inline closed_shell manifold_solid_brep::get_outer() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "outer", sdaiINSTANCE, &inst); return inst; }
    inline void manifold_solid_brep::put_outer(closed_shell inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "outer", sdaiINSTANCE, (void*) i); }
    inline person_and_organization building::get_owner() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "owner", sdaiINSTANCE, &inst); return inst; }
    inline void building::put_owner(person_and_organization inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "owner", sdaiINSTANCE, (void*) i); }
    inline site building_complex::get_building_site() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "building_site", sdaiINSTANCE, &inst); return inst; }
    inline void building_complex::put_building_site(site inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "building_site", sdaiINSTANCE, (void*) i); }
    inline shape_representation_with_units building_with_shape::get_shape() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "shape", sdaiINSTANCE, &inst); return inst; }
    inline void building_with_shape::put_shape(shape_representation_with_units inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "shape", sdaiINSTANCE, (void*) i); }
    inline direction cartesian_transformation_operator::get_axis1() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "axis1", sdaiINSTANCE, &inst); return inst; }
    inline void cartesian_transformation_operator::put_axis1(direction inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "axis1", sdaiINSTANCE, (void*) i); }
    inline direction cartesian_transformation_operator::get_axis2() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "axis2", sdaiINSTANCE, &inst); return inst; }
    inline void cartesian_transformation_operator::put_axis2(direction inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "axis2", sdaiINSTANCE, (void*) i); }
    inline cartesian_point cartesian_transformation_operator::get_local_origin() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "local_origin", sdaiINSTANCE, &inst); return inst; }
    inline void cartesian_transformation_operator::put_local_origin(cartesian_point inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "local_origin", sdaiINSTANCE, (void*) i); }
    inline direction cartesian_transformation_operator_3d::get_axis3() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "axis3", sdaiINSTANCE, &inst); return inst; }
    inline void cartesian_transformation_operator_3d::put_axis3(direction inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "axis3", sdaiINSTANCE, (void*) i); }
    inline certification_type certification::get_kind() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "kind", sdaiINSTANCE, &inst); return inst; }
    inline void certification::put_kind(certification_type inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "kind", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit chemical_mechanism::get_layer_thickness() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "layer_thickness", sdaiINSTANCE, &inst); return inst; }
    inline void chemical_mechanism::put_layer_thickness(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "layer_thickness", sdaiINSTANCE, (void*) i); }
    inline pressure_measure_with_unit chemical_mechanism::get_layer_design_strength() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "layer_design_strength", sdaiINSTANCE, &inst); return inst; }
    inline void chemical_mechanism::put_layer_design_strength(pressure_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "layer_design_strength", sdaiINSTANCE, (void*) i); }
    inline cartesian_point circular_area::get_centre() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "centre", sdaiINSTANCE, &inst); return inst; }
    inline void circular_area::put_centre(cartesian_point inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "centre", sdaiINSTANCE, (void*) i); }
    inline curve composite_curve_segment::get_parent_curve() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "parent_curve", sdaiINSTANCE, &inst); return inst; }
    inline void composite_curve_segment::put_parent_curve(curve inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "parent_curve", sdaiINSTANCE, (void*) i); }
    inline axis2_placement_3d elementary_surface::get_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "position", sdaiINSTANCE, &inst); return inst; }
    inline void elementary_surface::put_position(axis2_placement_3d inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "position", sdaiINSTANCE, (void*) i); }
    inline contract_type contract::get_kind() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "kind", sdaiINSTANCE, &inst); return inst; }
    inline void contract::put_kind(contract_type inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "kind", sdaiINSTANCE, (void*) i); }
    inline measure_with_unit conversion_based_unit::get_conversion_factor() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "conversion_factor", sdaiINSTANCE, &inst); return inst; }
    inline void conversion_based_unit::put_conversion_factor(measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "conversion_factor", sdaiINSTANCE, (void*) i); }
    inline axis2_placement_2d coord_system_cartesian_2d::get_axes_definition() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "axes_definition", sdaiINSTANCE, &inst); return inst; }
    inline void coord_system_cartesian_2d::put_axes_definition(axis2_placement_2d inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "axes_definition", sdaiINSTANCE, (void*) i); }
    inline axis2_placement_3d coord_system_cartesian_3d::get_axes_definition() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "axes_definition", sdaiINSTANCE, &inst); return inst; }
    inline void coord_system_cartesian_3d::put_axes_definition(axis2_placement_3d inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "axes_definition", sdaiINSTANCE, (void*) i); }
    inline coord_system coord_system_child::get_parent_coord_system() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "parent_coord_system", sdaiINSTANCE, &inst); return inst; }
    inline void coord_system_child::put_parent_coord_system(coord_system inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "parent_coord_system", sdaiINSTANCE, (void*) i); }
    inline cylindrical_point coord_system_cylindrical::get_origin() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "origin", sdaiINSTANCE, &inst); return inst; }
    inline void coord_system_cylindrical::put_origin(cylindrical_point inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "origin", sdaiINSTANCE, (void*) i); }
    inline spherical_point coord_system_spherical::get_origin() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "origin", sdaiINSTANCE, &inst); return inst; }
    inline void coord_system_spherical::put_origin(spherical_point inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "origin", sdaiINSTANCE, (void*) i); }
    inline currency_unit currency_measure_with_unit::get_unit() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "unit", sdaiINSTANCE, &inst); return inst; }
    inline void currency_measure_with_unit::put_unit(currency_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "unit", sdaiINSTANCE, (void*) i); }
    inline measure_with_unit currency_rate_with_unit::get_per_quantity() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "per_quantity", sdaiINSTANCE, &inst); return inst; }
    inline void currency_rate_with_unit::put_per_quantity(measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "per_quantity", sdaiINSTANCE, (void*) i); }
    inline surface curve_bounded_surface::get_basis_surface() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "basis_surface", sdaiINSTANCE, &inst); return inst; }
    inline void curve_bounded_surface::put_basis_surface(surface inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "basis_surface", sdaiINSTANCE, (void*) i); }
    inline curve curve_replica::get_parent_curve() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "parent_curve", sdaiINSTANCE, &inst); return inst; }
    inline void curve_replica::put_parent_curve(curve inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "parent_curve", sdaiINSTANCE, (void*) i); }
    inline cartesian_transformation_operator curve_replica::get_transformation() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "transformation", sdaiINSTANCE, &inst); return inst; }
    inline void curve_replica::put_transformation(cartesian_transformation_operator inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "transformation", sdaiINSTANCE, (void*) i); }
    inline axis2_placement_3d cyclide_segment_solid::get_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "position", sdaiINSTANCE, &inst); return inst; }
    inline void cyclide_segment_solid::put_position(axis2_placement_3d inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "position", sdaiINSTANCE, (void*) i); }
    inline axis2_placement_3d cylindrical_volume::get_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "position", sdaiINSTANCE, &inst); return inst; }
    inline void cylindrical_volume::put_position(axis2_placement_3d inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "position", sdaiINSTANCE, (void*) i); }
    inline calendar_date date_and_time::get_date_component() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "date_component", sdaiINSTANCE, &inst); return inst; }
    inline void date_and_time::put_date_component(calendar_date inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "date_component", sdaiINSTANCE, (void*) i); }
    inline local_time date_and_time::get_time_component() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "time_component", sdaiINSTANCE, &inst); return inst; }
    inline void date_and_time::put_time_component(local_time inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "time_component", sdaiINSTANCE, (void*) i); }
    inline representation_context representation::get_context_of_items() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "context_of_items", sdaiINSTANCE, &inst); return inst; }
    inline void representation::put_context_of_items(representation_context inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "context_of_items", sdaiINSTANCE, (void*) i); }
    inline surface degenerate_pcurve::get_basis_surface() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "basis_surface", sdaiINSTANCE, &inst); return inst; }
    inline void degenerate_pcurve::put_basis_surface(surface inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "basis_surface", sdaiINSTANCE, (void*) i); }
    inline definitional_representation degenerate_pcurve::get_reference_to_curve() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reference_to_curve", sdaiINSTANCE, &inst); return inst; }
    inline void degenerate_pcurve::put_reference_to_curve(definitional_representation inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reference_to_curve", sdaiINSTANCE, (void*) i); }
    inline named_unit derived_unit_element::get_unit() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "unit", sdaiINSTANCE, &inst); return inst; }
    inline void derived_unit_element::put_unit(named_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "unit", sdaiINSTANCE, (void*) i); }
    inline document_usage_constraint design_criterion_documented::get_documented_reference() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "documented_reference", sdaiINSTANCE, &inst); return inst; }
    inline void design_criterion_documented::put_documented_reference(document_usage_constraint inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "documented_reference", sdaiINSTANCE, (void*) i); }
    inline joint_system design_joint_system::get_design_joint_system_spec() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "design_joint_system_spec", sdaiINSTANCE, &inst); return inst; }
    inline void design_joint_system::put_design_joint_system_spec(joint_system inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "design_joint_system_spec", sdaiINSTANCE, (void*) i); }
    inline part design_part::get_design_part_spec() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "design_part_spec", sdaiINSTANCE, &inst); return inst; }
    inline void design_part::put_design_part_spec(part inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "design_part_spec", sdaiINSTANCE, (void*) i); }
    inline resistance design_result::get_design_resistance() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "design_resistance", sdaiINSTANCE, &inst); return inst; }
    inline void design_result::put_design_resistance(resistance inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "design_resistance", sdaiINSTANCE, (void*) i); }
    inline assembly_design_structural_connection design_result_connection::get_result_for_connection() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "result_for_connection", sdaiINSTANCE, &inst); return inst; }
    inline void design_result_connection::put_result_for_connection(assembly_design_structural_connection inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "result_for_connection", sdaiINSTANCE, (void*) i); }
    inline point design_result_connection::get_result_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "result_position", sdaiINSTANCE, &inst); return inst; }
    inline void design_result_connection::put_result_position(point inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "result_position", sdaiINSTANCE, (void*) i); }
    inline design_joint_system design_result_joint_system::get_result_for_joint_system() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "result_for_joint_system", sdaiINSTANCE, &inst); return inst; }
    inline void design_result_joint_system::put_result_for_joint_system(design_joint_system inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "result_for_joint_system", sdaiINSTANCE, (void*) i); }
    inline analysis_results_set design_result_mapped::get_origin_of_forces() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "origin_of_forces", sdaiINSTANCE, &inst); return inst; }
    inline void design_result_mapped::put_origin_of_forces(analysis_results_set inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "origin_of_forces", sdaiINSTANCE, (void*) i); }
    inline assembly_design_structural_member design_result_member::get_result_for_member() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "result_for_member", sdaiINSTANCE, &inst); return inst; }
    inline void design_result_member::put_result_for_member(assembly_design_structural_member inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "result_for_member", sdaiINSTANCE, (void*) i); }
    inline point design_result_member::get_result_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "result_position", sdaiINSTANCE, &inst); return inst; }
    inline void design_result_member::put_result_position(point inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "result_position", sdaiINSTANCE, (void*) i); }
    inline design_part design_result_part::get_result_for_part() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "result_for_part", sdaiINSTANCE, &inst); return inst; }
    inline void design_result_part::put_result_for_part(design_part inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "result_for_part", sdaiINSTANCE, (void*) i); }
    inline reaction_force design_result_resolved::get_design_forces() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "design_forces", sdaiINSTANCE, &inst); return inst; }
    inline void design_result_resolved::put_design_forces(reaction_force inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "design_forces", sdaiINSTANCE, (void*) i); }
    inline action_directive directed_action::get_directive() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "directive", sdaiINSTANCE, &inst); return inst; }
    inline void directed_action::put_directive(action_directive inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "directive", sdaiINSTANCE, (void*) i); }
    inline organizational_address dispatch::get_dispatch_address() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "dispatch_address", sdaiINSTANCE, &inst); return inst; }
    inline void dispatch::put_dispatch_address(organizational_address inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "dispatch_address", sdaiINSTANCE, (void*) i); }
    inline organizational_address dispatch::get_delivery_address() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "delivery_address", sdaiINSTANCE, &inst); return inst; }
    inline void dispatch::put_delivery_address(organizational_address inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "delivery_address", sdaiINSTANCE, (void*) i); }
    inline calendar_date dispatch::get_dispatch_date() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "dispatch_date", sdaiINSTANCE, &inst); return inst; }
    inline void dispatch::put_dispatch_date(calendar_date inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "dispatch_date", sdaiINSTANCE, (void*) i); }
    inline calendar_date dispatch::get_delivery_date() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "delivery_date", sdaiINSTANCE, &inst); return inst; }
    inline void dispatch::put_delivery_date(calendar_date inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "delivery_date", sdaiINSTANCE, (void*) i); }
    inline document_type document::get_kind() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "kind", sdaiINSTANCE, &inst); return inst; }
    inline void document::put_kind(document_type inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "kind", sdaiINSTANCE, (void*) i); }
    inline document document_relationship::get_relating_document() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "relating_document", sdaiINSTANCE, &inst); return inst; }
    inline void document_relationship::put_relating_document(document inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "relating_document", sdaiINSTANCE, (void*) i); }
    inline document document_relationship::get_related_document() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "related_document", sdaiINSTANCE, &inst); return inst; }
    inline void document_relationship::put_related_document(document inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "related_document", sdaiINSTANCE, (void*) i); }
    inline document document_representation_type::get_represented_document() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "represented_document", sdaiINSTANCE, &inst); return inst; }
    inline void document_representation_type::put_represented_document(document inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "represented_document", sdaiINSTANCE, (void*) i); }
    inline document document_usage_constraint::get_source() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "source", sdaiINSTANCE, &inst); return inst; }
    inline void document_usage_constraint::put_source(document inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "source", sdaiINSTANCE, (void*) i); }
    inline axis2_placement_3d eccentric_cone::get_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "position", sdaiINSTANCE, &inst); return inst; }
    inline void eccentric_cone::put_position(axis2_placement_3d inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "position", sdaiINSTANCE, (void*) i); }
    inline axis2_placement_3d eccentric_conical_volume::get_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "position", sdaiINSTANCE, &inst); return inst; }
    inline void eccentric_conical_volume::put_position(axis2_placement_3d inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "position", sdaiINSTANCE, (void*) i); }
    inline vertex edge::get_edge_start() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "edge_start", sdaiINSTANCE, &inst); return inst; }
    inline void edge::put_edge_start(vertex inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "edge_start", sdaiINSTANCE, (void*) i); }
    inline vertex edge::get_edge_end() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "edge_end", sdaiINSTANCE, &inst); return inst; }
    inline void edge::put_edge_end(vertex inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "edge_end", sdaiINSTANCE, (void*) i); }
    inline curve edge_curve::get_edge_geometry() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "edge_geometry", sdaiINSTANCE, &inst); return inst; }
    inline void edge_curve::put_edge_geometry(curve inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "edge_geometry", sdaiINSTANCE, (void*) i); }
    inline assembly_design_structural_member effective_buckling_length::get_applicable_member() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "applicable_member", sdaiINSTANCE, &inst); return inst; }
    inline void effective_buckling_length::put_applicable_member(assembly_design_structural_member inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "applicable_member", sdaiINSTANCE, (void*) i); }
    inline analysis_model element::get_parent_model() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "parent_model", sdaiINSTANCE, &inst); return inst; }
    inline void element::put_parent_model(analysis_model inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "parent_model", sdaiINSTANCE, (void*) i); }
    inline section_profile element_curve_simple::get_cross_section() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "cross_section", sdaiINSTANCE, &inst); return inst; }
    inline void element_curve_simple::put_cross_section(section_profile inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "cross_section", sdaiINSTANCE, (void*) i); }
    inline length_measure_with_unit element_eccentricity::get_x_eccentricity() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "x_eccentricity", sdaiINSTANCE, &inst); return inst; }
    inline void element_eccentricity::put_x_eccentricity(length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "x_eccentricity", sdaiINSTANCE, (void*) i); }
    inline length_measure_with_unit element_eccentricity::get_y_eccentricity() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "y_eccentricity", sdaiINSTANCE, &inst); return inst; }
    inline void element_eccentricity::put_y_eccentricity(length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "y_eccentricity", sdaiINSTANCE, (void*) i); }
    inline length_measure_with_unit element_eccentricity::get_z_eccentricity() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "z_eccentricity", sdaiINSTANCE, &inst); return inst; }
    inline void element_eccentricity::put_z_eccentricity(length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "z_eccentricity", sdaiINSTANCE, (void*) i); }
    inline element element_mapping::get_mapped_element() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "mapped_element", sdaiINSTANCE, &inst); return inst; }
    inline void element_mapping::put_mapped_element(element inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "mapped_element", sdaiINSTANCE, (void*) i); }
    inline node element_node_connectivity::get_connecting_node() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "connecting_node", sdaiINSTANCE, &inst); return inst; }
    inline void element_node_connectivity::put_connecting_node(node inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "connecting_node", sdaiINSTANCE, (void*) i); }
    inline element element_node_connectivity::get_connecting_element() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "connecting_element", sdaiINSTANCE, &inst); return inst; }
    inline void element_node_connectivity::put_connecting_element(element inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "connecting_element", sdaiINSTANCE, (void*) i); }
    inline element_eccentricity element_node_connectivity::get_eccentricity() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "eccentricity", sdaiINSTANCE, &inst); return inst; }
    inline void element_node_connectivity::put_eccentricity(element_eccentricity inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "eccentricity", sdaiINSTANCE, (void*) i); }
    inline release element_node_connectivity::get_fixity() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "fixity", sdaiINSTANCE, &inst); return inst; }
    inline void element_node_connectivity::put_fixity(release inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "fixity", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit element_surface::get_thickness() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "thickness", sdaiINSTANCE, &inst); return inst; }
    inline void element_surface::put_thickness(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "thickness", sdaiINSTANCE, (void*) i); }
    inline surface element_surface_complex::get_surface_definition() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "surface_definition", sdaiINSTANCE, &inst); return inst; }
    inline void element_surface_complex::put_surface_definition(surface inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "surface_definition", sdaiINSTANCE, (void*) i); }
    inline curve element_surface_profiled::get_profile() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "profile", sdaiINSTANCE, &inst); return inst; }
    inline void element_surface_profiled::put_profile(curve inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "profile", sdaiINSTANCE, (void*) i); }
    inline shape_representation_with_units element_volume_complex::get_shape() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "shape", sdaiINSTANCE, &inst); return inst; }
    inline void element_volume_complex::put_shape(shape_representation_with_units inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "shape", sdaiINSTANCE, (void*) i); }
    inline material element_with_material::get_material_definition() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "material_definition", sdaiINSTANCE, &inst); return inst; }
    inline void element_with_material::put_material_definition(material inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "material_definition", sdaiINSTANCE, (void*) i); }
    inline axis2_placement_3d ellipsoid::get_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "position", sdaiINSTANCE, &inst); return inst; }
    inline void ellipsoid::put_position(axis2_placement_3d inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "position", sdaiINSTANCE, (void*) i); }
    inline axis2_placement_3d ellipsoid_volume::get_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "position", sdaiINSTANCE, &inst); return inst; }
    inline void ellipsoid_volume::put_position(axis2_placement_3d inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "position", sdaiINSTANCE, (void*) i); }
    inline axis2_placement_2d elliptic_area::get_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "position", sdaiINSTANCE, &inst); return inst; }
    inline void elliptic_area::put_position(axis2_placement_2d inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "position", sdaiINSTANCE, (void*) i); }
    inline cartesian_point evaluated_degenerate_pcurve::get_equivalent_point() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "equivalent_point", sdaiINSTANCE, &inst); return inst; }
    inline void evaluated_degenerate_pcurve::put_equivalent_point(cartesian_point inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "equivalent_point", sdaiINSTANCE, (void*) i); }
    inline curve_bounded_surface swept_area_solid::get_swept_area() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "swept_area", sdaiINSTANCE, &inst); return inst; }
    inline void swept_area_solid::put_swept_area(curve_bounded_surface inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "swept_area", sdaiINSTANCE, (void*) i); }
    inline direction extruded_area_solid::get_extruded_direction() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "extruded_direction", sdaiINSTANCE, &inst); return inst; }
    inline void extruded_area_solid::put_extruded_direction(direction inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "extruded_direction", sdaiINSTANCE, (void*) i); }
    inline face_surface swept_face_solid::get_swept_face() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "swept_face", sdaiINSTANCE, &inst); return inst; }
    inline void swept_face_solid::put_swept_face(face_surface inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "swept_face", sdaiINSTANCE, (void*) i); }
    inline direction extruded_face_solid::get_extruded_direction() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "extruded_direction", sdaiINSTANCE, &inst); return inst; }
    inline void extruded_face_solid::put_extruded_direction(direction inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "extruded_direction", sdaiINSTANCE, (void*) i); }
    inline loop face_bound::get_bound() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "bound", sdaiINSTANCE, &inst); return inst; }
    inline void face_bound::put_bound(loop inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "bound", sdaiINSTANCE, (void*) i); }
    inline surface face_surface::get_face_geometry() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "face_geometry", sdaiINSTANCE, &inst); return inst; }
    inline void face_surface::put_face_geometry(surface inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "face_geometry", sdaiINSTANCE, (void*) i); }
    inline shape_representation_with_units fastener_complex::get_fastener_shape() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "fastener_shape", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_complex::put_fastener_shape(shape_representation_with_units inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "fastener_shape", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit fastener_simple::get_nominal_diameter() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "nominal_diameter", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple::put_nominal_diameter(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "nominal_diameter", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit fastener_simple::get_nominal_length() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "nominal_length", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple::put_nominal_length(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "nominal_length", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit fastener_simple_bolt::get_length_of_shank() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "length_of_shank", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_bolt::put_length_of_shank(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "length_of_shank", sdaiINSTANCE, (void*) i); }
    inline force_measure_with_unit fastener_simple_bolt::get_bolt_preload() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "bolt_preload", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_bolt::put_bolt_preload(force_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "bolt_preload", sdaiINSTANCE, (void*) i); }
    inline area_measure_with_unit fastener_simple_bolt::get_full_section_area() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "full_section_area", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_bolt::put_full_section_area(area_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "full_section_area", sdaiINSTANCE, (void*) i); }
    inline area_measure_with_unit fastener_simple_bolt::get_reduced_section_area() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reduced_section_area", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_bolt::put_reduced_section_area(area_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reduced_section_area", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit fastener_simple_bolt_circular_head::get_bolt_head_height() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "bolt_head_height", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_bolt_circular_head::put_bolt_head_height(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "bolt_head_height", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit fastener_simple_bolt_circular_head::get_head_diameter() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "head_diameter", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_bolt_circular_head::put_head_diameter(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "head_diameter", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit fastener_simple_bolt_hexagonal_head::get_bolt_head_height() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "bolt_head_height", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_bolt_hexagonal_head::put_bolt_head_height(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "bolt_head_height", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit fastener_simple_bolt_hexagonal_head::get_distance_across_vertices() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "distance_across_vertices", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_bolt_hexagonal_head::put_distance_across_vertices(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "distance_across_vertices", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit fastener_simple_bolt_hexagonal_head::get_distance_across_flats() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "distance_across_flats", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_bolt_hexagonal_head::put_distance_across_flats(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "distance_across_flats", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit fastener_simple_bolt_square_head::get_bolt_head_height() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "bolt_head_height", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_bolt_square_head::put_bolt_head_height(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "bolt_head_height", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit fastener_simple_bolt_square_head::get_distance_across_flats() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "distance_across_flats", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_bolt_square_head::put_distance_across_flats(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "distance_across_flats", sdaiINSTANCE, (void*) i); }
    inline plane_angle_measure_with_unit fastener_simple_countersunk::get_countersink_angle() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "countersink_angle", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_countersunk::put_countersink_angle(plane_angle_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "countersink_angle", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit fastener_simple_countersunk::get_countersink_depth() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "countersink_depth", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_countersunk::put_countersink_depth(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "countersink_depth", sdaiINSTANCE, (void*) i); }
    inline curve fastener_simple_curved::get_curve_definition() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "curve_definition", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_curved::put_curve_definition(curve inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "curve_definition", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit fastener_simple_nut_circular::get_outside_diameter() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "outside_diameter", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_nut_circular::put_outside_diameter(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "outside_diameter", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit fastener_simple_nut_closed::get_nut_depth() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "nut_depth", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_nut_closed::put_nut_depth(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "nut_depth", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit fastener_simple_nut_hexagonal::get_distance_across_vertices() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "distance_across_vertices", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_nut_hexagonal::put_distance_across_vertices(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "distance_across_vertices", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit fastener_simple_nut_hexagonal::get_distance_across_flats() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "distance_across_flats", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_nut_hexagonal::put_distance_across_flats(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "distance_across_flats", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit fastener_simple_nut_square::get_distance_across_flats() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "distance_across_flats", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_nut_square::put_distance_across_flats(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "distance_across_flats", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit fastener_simple_screw::get_screw_head_height() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "screw_head_height", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_screw::put_screw_head_height(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "screw_head_height", sdaiINSTANCE, (void*) i); }
    inline area_measure_with_unit fastener_simple_screw::get_full_section_area() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "full_section_area", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_screw::put_full_section_area(area_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "full_section_area", sdaiINSTANCE, (void*) i); }
    inline area_measure_with_unit fastener_simple_screw::get_reduced_section_area() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reduced_section_area", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_screw::put_reduced_section_area(area_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reduced_section_area", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit fastener_simple_screw_self_drilling::get_pilot_hole_diameter() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "pilot_hole_diameter", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_screw_self_drilling::put_pilot_hole_diameter(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "pilot_hole_diameter", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit fastener_simple_screw_self_drilling::get_drill_diameter() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "drill_diameter", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_screw_self_drilling::put_drill_diameter(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "drill_diameter", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit fastener_simple_screw_self_tapping::get_pilot_hole_diameter() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "pilot_hole_diameter", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_screw_self_tapping::put_pilot_hole_diameter(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "pilot_hole_diameter", sdaiINSTANCE, (void*) i); }
    inline length_measure_with_unit fastener_simple_screw_tapered::get_absolute_taper() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "absolute_taper", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_screw_tapered::put_absolute_taper(length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "absolute_taper", sdaiINSTANCE, (void*) i); }
    inline ratio_measure_with_unit fastener_simple_screw_tapered::get_relative_taper() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "relative_taper", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_screw_tapered::put_relative_taper(ratio_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "relative_taper", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit fastener_simple_stud::get_thread_length_1() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "thread_length_1", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_stud::put_thread_length_1(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "thread_length_1", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit fastener_simple_stud::get_thread_length_2() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "thread_length_2", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_stud::put_thread_length_2(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "thread_length_2", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit fastener_simple_stud::get_length_of_shank() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "length_of_shank", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_stud::put_length_of_shank(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "length_of_shank", sdaiINSTANCE, (void*) i); }
    inline area_measure_with_unit fastener_simple_stud::get_full_section_area() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "full_section_area", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_stud::put_full_section_area(area_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "full_section_area", sdaiINSTANCE, (void*) i); }
    inline area_measure_with_unit fastener_simple_stud::get_reduced_section_area() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reduced_section_area", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_stud::put_reduced_section_area(area_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reduced_section_area", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit fastener_simple_washer::get_inside_diameter() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "inside_diameter", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_washer::put_inside_diameter(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "inside_diameter", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit fastener_simple_washer::get_external_dimension() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "external_dimension", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_washer::put_external_dimension(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "external_dimension", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit fastener_simple_washer_load_indicating::get_final_gap() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "final_gap", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_washer_load_indicating::put_final_gap(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "final_gap", sdaiINSTANCE, (void*) i); }
    inline ratio_measure_with_unit fastener_simple_washer_tapered::get_taper() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "taper", sdaiINSTANCE, &inst); return inst; }
    inline void fastener_simple_washer_tapered::put_taper(ratio_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "taper", sdaiINSTANCE, (void*) i); }
    inline plane feature_cutting_plane::get_plane_definition() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "plane_definition", sdaiINSTANCE, &inst); return inst; }
    inline void feature_cutting_plane::put_plane_definition(plane inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "plane_definition", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit feature_edge_chamfer_fillet::get_edge_fillet_radius() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "edge_fillet_radius", sdaiINSTANCE, &inst); return inst; }
    inline void feature_edge_chamfer_fillet::put_edge_fillet_radius(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "edge_fillet_radius", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit feature_edge_chamfer_rounding::get_edge_rounding_radius() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "edge_rounding_radius", sdaiINSTANCE, &inst); return inst; }
    inline void feature_edge_chamfer_rounding::put_edge_rounding_radius(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "edge_rounding_radius", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit feature_edge_chamfer_straight::get_edge_chamfer_width() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "edge_chamfer_width", sdaiINSTANCE, &inst); return inst; }
    inline void feature_edge_chamfer_straight::put_edge_chamfer_width(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "edge_chamfer_width", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit feature_edge_chamfer_straight::get_edge_chamfer_depth() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "edge_chamfer_depth", sdaiINSTANCE, &inst); return inst; }
    inline void feature_edge_chamfer_straight::put_edge_chamfer_depth(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "edge_chamfer_depth", sdaiINSTANCE, (void*) i); }
    inline bounded_surface feature_surface_complex::get_feature_boundary() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "feature_boundary", sdaiINSTANCE, &inst); return inst; }
    inline void feature_surface_complex::put_feature_boundary(bounded_surface inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "feature_boundary", sdaiINSTANCE, (void*) i); }
    inline point feature_surface_point::get_feature_point() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "feature_point", sdaiINSTANCE, &inst); return inst; }
    inline void feature_surface_point::put_feature_point(point inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "feature_point", sdaiINSTANCE, (void*) i); }
    inline surface_treatment_hard_stamp feature_surface_point_mark::get_marking_process() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "marking_process", sdaiINSTANCE, &inst); return inst; }
    inline void feature_surface_point_mark::put_marking_process(surface_treatment_hard_stamp inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "marking_process", sdaiINSTANCE, (void*) i); }
    inline surface_treatment feature_surface_treatment::get_treatment_definition() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "treatment_definition", sdaiINSTANCE, &inst); return inst; }
    inline void feature_surface_treatment::put_treatment_definition(surface_treatment inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "treatment_definition", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit feature_thread::get_thread_pitch() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "thread_pitch", sdaiINSTANCE, &inst); return inst; }
    inline void feature_thread::put_thread_pitch(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "thread_pitch", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit feature_thread::get_thread_length() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "thread_length", sdaiINSTANCE, &inst); return inst; }
    inline void feature_thread::put_thread_length(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "thread_length", sdaiINSTANCE, (void*) i); }
    inline shape_representation_with_units feature_thread::get_thread_profile() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "thread_profile", sdaiINSTANCE, &inst); return inst; }
    inline void feature_thread::put_thread_profile(shape_representation_with_units inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "thread_profile", sdaiINSTANCE, (void*) i); }
    inline shape_representation_with_units feature_volume_complex::get_feature_shape() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "feature_shape", sdaiINSTANCE, &inst); return inst; }
    inline void feature_volume_complex::put_feature_shape(shape_representation_with_units inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "feature_shape", sdaiINSTANCE, (void*) i); }
    inline curve feature_volume_curved::get_feature_trace() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "feature_trace", sdaiINSTANCE, &inst); return inst; }
    inline void feature_volume_curved::put_feature_trace(curve inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "feature_trace", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit feature_volume_hole_circular::get_hole_radius() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "hole_radius", sdaiINSTANCE, &inst); return inst; }
    inline void feature_volume_hole_circular::put_hole_radius(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "hole_radius", sdaiINSTANCE, (void*) i); }
    inline feature_thread feature_volume_hole_circular_threaded::get_thread_definition() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "thread_definition", sdaiINSTANCE, &inst); return inst; }
    inline void feature_volume_hole_circular_threaded::put_thread_definition(feature_thread inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "thread_definition", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit feature_volume_hole_rectangular::get_hole_length() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "hole_length", sdaiINSTANCE, &inst); return inst; }
    inline void feature_volume_hole_rectangular::put_hole_length(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "hole_length", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit feature_volume_hole_rectangular::get_hole_height() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "hole_height", sdaiINSTANCE, &inst); return inst; }
    inline void feature_volume_hole_rectangular::put_hole_height(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "hole_height", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit feature_volume_hole_rectangular::get_fillet_radius() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "fillet_radius", sdaiINSTANCE, &inst); return inst; }
    inline void feature_volume_hole_rectangular::put_fillet_radius(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "fillet_radius", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit feature_volume_hole_slotted::get_slot_height() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "slot_height", sdaiINSTANCE, &inst); return inst; }
    inline void feature_volume_hole_slotted::put_slot_height(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "slot_height", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit feature_volume_hole_slotted::get_slot_length() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "slot_length", sdaiINSTANCE, &inst); return inst; }
    inline void feature_volume_hole_slotted::put_slot_length(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "slot_length", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit feature_volume_hole_slotted_curved::get_curve_radius() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "curve_radius", sdaiINSTANCE, &inst); return inst; }
    inline void feature_volume_hole_slotted_curved::put_curve_radius(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "curve_radius", sdaiINSTANCE, (void*) i); }
    inline plane_angle_measure_with_unit feature_volume_hole_slotted_curved::get_sector_angle() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "sector_angle", sdaiINSTANCE, &inst); return inst; }
    inline void feature_volume_hole_slotted_curved::put_sector_angle(plane_angle_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "sector_angle", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit feature_volume_prismatic_chamfer::get_chamfer_length() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "chamfer_length", sdaiINSTANCE, &inst); return inst; }
    inline void feature_volume_prismatic_chamfer::put_chamfer_length(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "chamfer_length", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit feature_volume_prismatic_chamfer::get_chamfer_depth() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "chamfer_depth", sdaiINSTANCE, &inst); return inst; }
    inline void feature_volume_prismatic_chamfer::put_chamfer_depth(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "chamfer_depth", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit feature_volume_prismatic_flange_chamfer::get_flange_chamfer_length() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "flange_chamfer_length", sdaiINSTANCE, &inst); return inst; }
    inline void feature_volume_prismatic_flange_chamfer::put_flange_chamfer_length(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "flange_chamfer_length", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit feature_volume_prismatic_flange_chamfer::get_flange_chamfer_width() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "flange_chamfer_width", sdaiINSTANCE, &inst); return inst; }
    inline void feature_volume_prismatic_flange_chamfer::put_flange_chamfer_width(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "flange_chamfer_width", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit feature_volume_prismatic_flange_notch::get_flange_notch_length() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "flange_notch_length", sdaiINSTANCE, &inst); return inst; }
    inline void feature_volume_prismatic_flange_notch::put_flange_notch_length(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "flange_notch_length", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit feature_volume_prismatic_flange_notch::get_flange_notch_width() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "flange_notch_width", sdaiINSTANCE, &inst); return inst; }
    inline void feature_volume_prismatic_flange_notch::put_flange_notch_width(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "flange_notch_width", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit feature_volume_prismatic_flange_notch::get_flange_notch_radius() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "flange_notch_radius", sdaiINSTANCE, &inst); return inst; }
    inline void feature_volume_prismatic_flange_notch::put_flange_notch_radius(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "flange_notch_radius", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit feature_volume_prismatic_notch::get_notch_length() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "notch_length", sdaiINSTANCE, &inst); return inst; }
    inline void feature_volume_prismatic_notch::put_notch_length(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "notch_length", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit feature_volume_prismatic_notch::get_notch_depth() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "notch_depth", sdaiINSTANCE, &inst); return inst; }
    inline void feature_volume_prismatic_notch::put_notch_depth(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "notch_depth", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit feature_volume_prismatic_notch::get_notch_radius() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "notch_radius", sdaiINSTANCE, &inst); return inst; }
    inline void feature_volume_prismatic_notch::put_notch_radius(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "notch_radius", sdaiINSTANCE, (void*) i); }
    inline plane_angle_measure_with_unit feature_volume_prismatic_skewed_end::get_skew_angle_1() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "skew_angle_1", sdaiINSTANCE, &inst); return inst; }
    inline void feature_volume_prismatic_skewed_end::put_skew_angle_1(plane_angle_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "skew_angle_1", sdaiINSTANCE, (void*) i); }
    inline plane_angle_measure_with_unit feature_volume_prismatic_skewed_end::get_skew_angle_2() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "skew_angle_2", sdaiINSTANCE, &inst); return inst; }
    inline void feature_volume_prismatic_skewed_end::put_skew_angle_2(plane_angle_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "skew_angle_2", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit feature_volume_with_depth::get_penetration_depth() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "penetration_depth", sdaiINSTANCE, &inst); return inst; }
    inline void feature_volume_with_depth::put_penetration_depth(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "penetration_depth", sdaiINSTANCE, (void*) i); }
    inline cut feature_volume_with_process::get_process_definition() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "process_definition", sdaiINSTANCE, &inst); return inst; }
    inline void feature_volume_with_process::put_process_definition(cut inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "process_definition", sdaiINSTANCE, (void*) i); }
    inline curve swept_surface::get_swept_curve() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "swept_curve", sdaiINSTANCE, &inst); return inst; }
    inline void swept_surface::put_swept_curve(curve inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "swept_curve", sdaiINSTANCE, (void*) i); }
    inline curve fixed_reference_swept_surface::get_directrix() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "directrix", sdaiINSTANCE, &inst); return inst; }
    inline void fixed_reference_swept_surface::put_directrix(curve inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "directrix", sdaiINSTANCE, (void*) i); }
    inline direction fixed_reference_swept_surface::get_fixed_reference() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "fixed_reference", sdaiINSTANCE, &inst); return inst; }
    inline void fixed_reference_swept_surface::put_fixed_reference(direction inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "fixed_reference", sdaiINSTANCE, (void*) i); }
    inline group group_assignment::get_assigned_group() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "assigned_group", sdaiINSTANCE, &inst); return inst; }
    inline void group_assignment::put_assigned_group(group inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "assigned_group", sdaiINSTANCE, (void*) i); }
    inline document_usage_constraint functional_role_documented::get_document_reference() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "document_reference", sdaiINSTANCE, &inst); return inst; }
    inline void functional_role_documented::put_document_reference(document_usage_constraint inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "document_reference", sdaiINSTANCE, (void*) i); }
    inline length_measure_with_unit geographical_location::get_height_above_datum() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "height_above_datum", sdaiINSTANCE, &inst); return inst; }
    inline void geographical_location::put_height_above_datum(length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "height_above_datum", sdaiINSTANCE, (void*) i); }
    inline geometric_set geometric_set_replica::get_parent_set() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "parent_set", sdaiINSTANCE, &inst); return inst; }
    inline void geometric_set_replica::put_parent_set(geometric_set inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "parent_set", sdaiINSTANCE, (void*) i); }
    inline cartesian_transformation_operator geometric_set_replica::get_transformation() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "transformation", sdaiINSTANCE, &inst); return inst; }
    inline void geometric_set_replica::put_transformation(cartesian_transformation_operator inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "transformation", sdaiINSTANCE, (void*) i); }
    inline grid_level grid_intersection::get_level() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "level", sdaiINSTANCE, &inst); return inst; }
    inline void grid_intersection::put_level(grid_level inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "level", sdaiINSTANCE, (void*) i); }
    inline geographical_location grid_intersection_resolved::get_resolution_point() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "resolution_point", sdaiINSTANCE, &inst); return inst; }
    inline void grid_intersection_resolved::put_resolution_point(geographical_location inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "resolution_point", sdaiINSTANCE, (void*) i); }
    inline grid grid_level::get_parent_grid() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "parent_grid", sdaiINSTANCE, &inst); return inst; }
    inline void grid_level::put_parent_grid(grid inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "parent_grid", sdaiINSTANCE, (void*) i); }
    inline building grid_of_building::get_grid_for_building() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "grid_for_building", sdaiINSTANCE, &inst); return inst; }
    inline void grid_of_building::put_grid_for_building(building inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "grid_for_building", sdaiINSTANCE, (void*) i); }
    inline site grid_of_site::get_grid_for_site() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "grid_for_site", sdaiINSTANCE, &inst); return inst; }
    inline void grid_of_site::put_grid_for_site(site inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "grid_for_site", sdaiINSTANCE, (void*) i); }
    inline structure grid_of_structure::get_grid_for_structure() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "grid_for_structure", sdaiINSTANCE, &inst); return inst; }
    inline void grid_of_structure::put_grid_for_structure(structure inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "grid_for_structure", sdaiINSTANCE, (void*) i); }
    inline grid_intersection grid_offset::get_intersection() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "intersection", sdaiINSTANCE, &inst); return inst; }
    inline void grid_offset::put_intersection(grid_intersection inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "intersection", sdaiINSTANCE, (void*) i); }
    inline plane_angle_measure_with_unit grid_skewed::get_skew_angle() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "skew_angle", sdaiINSTANCE, &inst); return inst; }
    inline void grid_skewed::put_skew_angle(plane_angle_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "skew_angle", sdaiINSTANCE, (void*) i); }
    inline grid gridline::get_parent_grid() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "parent_grid", sdaiINSTANCE, &inst); return inst; }
    inline void gridline::put_parent_grid(grid inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "parent_grid", sdaiINSTANCE, (void*) i); }
    inline gridline gridline::get_preceding_line() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "preceding_line", sdaiINSTANCE, &inst); return inst; }
    inline void gridline::put_preceding_line(gridline inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "preceding_line", sdaiINSTANCE, (void*) i); }
    inline action group_assignment_actioned::get_assigned_action() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "assigned_action", sdaiINSTANCE, &inst); return inst; }
    inline void group_assignment_actioned::put_assigned_action(action inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "assigned_action", sdaiINSTANCE, (void*) i); }
    inline approval group_assignment_approved::get_assigned_approval() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "assigned_approval", sdaiINSTANCE, &inst); return inst; }
    inline void group_assignment_approved::put_assigned_approval(approval inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "assigned_approval", sdaiINSTANCE, (void*) i); }
    inline group group_relationship::get_relating_group() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "relating_group", sdaiINSTANCE, &inst); return inst; }
    inline void group_relationship::put_relating_group(group inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "relating_group", sdaiINSTANCE, (void*) i); }
    inline group group_relationship::get_related_group() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "related_group", sdaiINSTANCE, &inst); return inst; }
    inline void group_relationship::put_related_group(group inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "related_group", sdaiINSTANCE, (void*) i); }
    inline curve half_space_2d::get_base_curve() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "base_curve", sdaiINSTANCE, &inst); return inst; }
    inline void half_space_2d::put_base_curve(curve inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "base_curve", sdaiINSTANCE, (void*) i); }
    inline item_cost_code item_cost_code_assigned::get_code() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "code", sdaiINSTANCE, &inst); return inst; }
    inline void item_cost_code_assigned::put_code(item_cost_code inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "code", sdaiINSTANCE, (void*) i); }
    inline structural_frame_item item_cost_code_assigned::get_costed_item() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "costed_item", sdaiINSTANCE, &inst); return inst; }
    inline void item_cost_code_assigned::put_costed_item(structural_frame_item inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "costed_item", sdaiINSTANCE, (void*) i); }
    inline item_ref_source item_cost_code_with_source::get_source() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "source", sdaiINSTANCE, &inst); return inst; }
    inline void item_cost_code_with_source::put_source(item_ref_source inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "source", sdaiINSTANCE, (void*) i); }
    inline representation_item item_defined_transformation::get_transform_item_1() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "transform_item_1", sdaiINSTANCE, &inst); return inst; }
    inline void item_defined_transformation::put_transform_item_1(representation_item inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "transform_item_1", sdaiINSTANCE, (void*) i); }
    inline representation_item item_defined_transformation::get_transform_item_2() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "transform_item_2", sdaiINSTANCE, &inst); return inst; }
    inline void item_defined_transformation::put_transform_item_2(representation_item inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "transform_item_2", sdaiINSTANCE, (void*) i); }
    inline item_property item_property_assigned::get_property() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "property", sdaiINSTANCE, &inst); return inst; }
    inline void item_property_assigned::put_property(item_property inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "property", sdaiINSTANCE, (void*) i); }
    inline structural_frame_item item_property_assigned::get_item() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "item", sdaiINSTANCE, &inst); return inst; }
    inline void item_property_assigned::put_item(structural_frame_item inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "item", sdaiINSTANCE, (void*) i); }
    inline item_ref_source item_property_with_source::get_source() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "source", sdaiINSTANCE, &inst); return inst; }
    inline void item_property_with_source::put_source(item_ref_source inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "source", sdaiINSTANCE, (void*) i); }
    inline item_ref_source item_ref_source_documented::get_documented_item_source() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "documented_item_source", sdaiINSTANCE, &inst); return inst; }
    inline void item_ref_source_documented::put_documented_item_source(item_ref_source inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "documented_item_source", sdaiINSTANCE, (void*) i); }
    inline document_usage_constraint item_ref_source_documented::get_document_reference() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "document_reference", sdaiINSTANCE, &inst); return inst; }
    inline void item_ref_source_documented::put_document_reference(document_usage_constraint inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "document_reference", sdaiINSTANCE, (void*) i); }
    inline person_and_organization item_ref_source_library::get_library_owner() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "library_owner", sdaiINSTANCE, &inst); return inst; }
    inline void item_ref_source_library::put_library_owner(person_and_organization inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "library_owner", sdaiINSTANCE, (void*) i); }
    inline calendar_date item_ref_source_library::get_date_of_library() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "date_of_library", sdaiINSTANCE, &inst); return inst; }
    inline void item_ref_source_library::put_date_of_library(calendar_date inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "date_of_library", sdaiINSTANCE, (void*) i); }
    inline organization item_ref_source_proprietary::get_manufacturers_name() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "manufacturers_name", sdaiINSTANCE, &inst); return inst; }
    inline void item_ref_source_proprietary::put_manufacturers_name(organization inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "manufacturers_name", sdaiINSTANCE, (void*) i); }
    inline item_reference item_reference_assigned::get_assigned_reference() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "assigned_reference", sdaiINSTANCE, &inst); return inst; }
    inline void item_reference_assigned::put_assigned_reference(item_reference inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "assigned_reference", sdaiINSTANCE, (void*) i); }
    inline structural_frame_item item_reference_assigned::get_assigned_to_item() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "assigned_to_item", sdaiINSTANCE, &inst); return inst; }
    inline void item_reference_assigned::put_assigned_to_item(structural_frame_item inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "assigned_to_item", sdaiINSTANCE, (void*) i); }
    inline item_ref_source_library item_reference_library::get_source() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "source", sdaiINSTANCE, &inst); return inst; }
    inline void item_reference_library::put_source(item_ref_source_library inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "source", sdaiINSTANCE, (void*) i); }
    inline item_ref_source_proprietary item_reference_proprietary::get_source() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "source", sdaiINSTANCE, &inst); return inst; }
    inline void item_reference_proprietary::put_source(item_ref_source_proprietary inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "source", sdaiINSTANCE, (void*) i); }
    inline item_ref_source_standard item_reference_standard::get_source() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "source", sdaiINSTANCE, &inst); return inst; }
    inline void item_reference_standard::put_source(item_ref_source_standard inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "source", sdaiINSTANCE, (void*) i); }
    inline chemical_mechanism joint_system_amorphous::get_specification() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "specification", sdaiINSTANCE, &inst); return inst; }
    inline void joint_system_amorphous::put_specification(chemical_mechanism inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "specification", sdaiINSTANCE, (void*) i); }
    inline surface joint_system_chemical::get_joining_surface() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "joining_surface", sdaiINSTANCE, &inst); return inst; }
    inline void joint_system_chemical::put_joining_surface(surface inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "joining_surface", sdaiINSTANCE, (void*) i); }
    inline surface joint_system_chemical::get_joined_surface() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "joined_surface", sdaiINSTANCE, &inst); return inst; }
    inline void joint_system_chemical::put_joined_surface(surface inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "joined_surface", sdaiINSTANCE, (void*) i); }
    inline fastener_mechanism joint_system_mechanical::get_mechanism() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "mechanism", sdaiINSTANCE, &inst); return inst; }
    inline void joint_system_mechanical::put_mechanism(fastener_mechanism inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "mechanism", sdaiINSTANCE, (void*) i); }
    inline weld_mechanism joint_system_welded::get_weld_specification() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "weld_specification", sdaiINSTANCE, &inst); return inst; }
    inline void joint_system_welded::put_weld_specification(weld_mechanism inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "weld_specification", sdaiINSTANCE, (void*) i); }
    inline composite_curve joint_system_welded_linear::get_weld_path() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "weld_path", sdaiINSTANCE, &inst); return inst; }
    inline void joint_system_welded_linear::put_weld_path(composite_curve inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "weld_path", sdaiINSTANCE, (void*) i); }
    inline point joint_system_welded_point::get_weld_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "weld_position", sdaiINSTANCE, &inst); return inst; }
    inline void joint_system_welded_point::put_weld_position(point inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "weld_position", sdaiINSTANCE, (void*) i); }
    inline bounded_surface joint_system_welded_surface::get_weld_surface() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "weld_surface", sdaiINSTANCE, &inst); return inst; }
    inline void joint_system_welded_surface::put_weld_surface(bounded_surface inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "weld_surface", sdaiINSTANCE, (void*) i); }
    inline shape_representation_with_units joint_system_welded_with_shape::get_weld_shape() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "weld_shape", sdaiINSTANCE, &inst); return inst; }
    inline void joint_system_welded_with_shape::put_weld_shape(shape_representation_with_units inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "weld_shape", sdaiINSTANCE, (void*) i); }
    inline cartesian_point line::get_pnt() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "pnt", sdaiINSTANCE, &inst); return inst; }
    inline void line::put_pnt(cartesian_point inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "pnt", sdaiINSTANCE, (void*) i); }
    inline vector line::get_dir() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "dir", sdaiINSTANCE, &inst); return inst; }
    inline void line::put_dir(vector inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "dir", sdaiINSTANCE, (void*) i); }
    inline load_case load::get_parent_load_case() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "parent_load_case", sdaiINSTANCE, &inst); return inst; }
    inline void load::put_parent_load_case(load_case inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "parent_load_case", sdaiINSTANCE, (void*) i); }
    inline physical_action load_case::get_time_variation() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "time_variation", sdaiINSTANCE, &inst); return inst; }
    inline void load_case::put_time_variation(physical_action inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "time_variation", sdaiINSTANCE, (void*) i); }
    inline document_usage_constraint load_case_documented::get_code_ref() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "code_ref", sdaiINSTANCE, &inst); return inst; }
    inline void load_case_documented::put_code_ref(document_usage_constraint inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "code_ref", sdaiINSTANCE, (void*) i); }
    inline loading_combination load_combination_occurrence::get_parent_load_combination() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "parent_load_combination", sdaiINSTANCE, &inst); return inst; }
    inline void load_combination_occurrence::put_parent_load_combination(loading_combination inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "parent_load_combination", sdaiINSTANCE, (void*) i); }
    inline load_case load_combination_occurrence::get_component_load_case() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "component_load_case", sdaiINSTANCE, &inst); return inst; }
    inline void load_combination_occurrence::put_component_load_case(load_case inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "component_load_case", sdaiINSTANCE, (void*) i); }
    inline assembly_design_structural_connection load_connection::get_supporting_connection() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "supporting_connection", sdaiINSTANCE, &inst); return inst; }
    inline void load_connection::put_supporting_connection(assembly_design_structural_connection inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "supporting_connection", sdaiINSTANCE, (void*) i); }
    inline applied_load load_connection::get_load_values() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "load_values", sdaiINSTANCE, &inst); return inst; }
    inline void load_connection::put_load_values(applied_load inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "load_values", sdaiINSTANCE, (void*) i); }
    inline element load_element::get_supporting_element() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "supporting_element", sdaiINSTANCE, &inst); return inst; }
    inline void load_element::put_supporting_element(element inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "supporting_element", sdaiINSTANCE, (void*) i); }
    inline point load_element_concentrated::get_load_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "load_position", sdaiINSTANCE, &inst); return inst; }
    inline void load_element_concentrated::put_load_position(point inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "load_position", sdaiINSTANCE, (void*) i); }
    inline applied_load load_element_concentrated::get_load_value() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "load_value", sdaiINSTANCE, &inst); return inst; }
    inline void load_element_concentrated::put_load_value(applied_load inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "load_value", sdaiINSTANCE, (void*) i); }
    inline applied_load load_element_distributed_curve::get_start_load_value() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "start_load_value", sdaiINSTANCE, &inst); return inst; }
    inline void load_element_distributed_curve::put_start_load_value(applied_load inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "start_load_value", sdaiINSTANCE, (void*) i); }
    inline applied_load load_element_distributed_curve::get_end_load_value() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "end_load_value", sdaiINSTANCE, &inst); return inst; }
    inline void load_element_distributed_curve::put_end_load_value(applied_load inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "end_load_value", sdaiINSTANCE, (void*) i); }
    inline curve load_element_distributed_curve::get_curve_definition() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "curve_definition", sdaiINSTANCE, &inst); return inst; }
    inline void load_element_distributed_curve::put_curve_definition(curve inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "curve_definition", sdaiINSTANCE, (void*) i); }
    inline bounded_surface load_element_distributed_surface::get_surface_definition() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "surface_definition", sdaiINSTANCE, &inst); return inst; }
    inline void load_element_distributed_surface::put_surface_definition(bounded_surface inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "surface_definition", sdaiINSTANCE, (void*) i); }
    inline applied_load_static_pressure load_element_distributed_surface_uniform::get_load_value() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "load_value", sdaiINSTANCE, &inst); return inst; }
    inline void load_element_distributed_surface_uniform::put_load_value(applied_load_static_pressure inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "load_value", sdaiINSTANCE, (void*) i); }
    inline assembly_design_structural_member load_member::get_supporting_member() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "supporting_member", sdaiINSTANCE, &inst); return inst; }
    inline void load_member::put_supporting_member(assembly_design_structural_member inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "supporting_member", sdaiINSTANCE, (void*) i); }
    inline point load_member_concentrated::get_load_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "load_position", sdaiINSTANCE, &inst); return inst; }
    inline void load_member_concentrated::put_load_position(point inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "load_position", sdaiINSTANCE, (void*) i); }
    inline applied_load load_member_concentrated::get_load_value() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "load_value", sdaiINSTANCE, &inst); return inst; }
    inline void load_member_concentrated::put_load_value(applied_load inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "load_value", sdaiINSTANCE, (void*) i); }
    inline applied_load load_member_distributed_curve::get_start_load_value() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "start_load_value", sdaiINSTANCE, &inst); return inst; }
    inline void load_member_distributed_curve::put_start_load_value(applied_load inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "start_load_value", sdaiINSTANCE, (void*) i); }
    inline applied_load load_member_distributed_curve::get_end_load_value() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "end_load_value", sdaiINSTANCE, &inst); return inst; }
    inline void load_member_distributed_curve::put_end_load_value(applied_load inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "end_load_value", sdaiINSTANCE, (void*) i); }
    inline curve load_member_distributed_curve::get_curve_definition() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "curve_definition", sdaiINSTANCE, &inst); return inst; }
    inline void load_member_distributed_curve::put_curve_definition(curve inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "curve_definition", sdaiINSTANCE, (void*) i); }
    inline bounded_surface load_member_distributed_surface::get_surface_definition() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "surface_definition", sdaiINSTANCE, &inst); return inst; }
    inline void load_member_distributed_surface::put_surface_definition(bounded_surface inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "surface_definition", sdaiINSTANCE, (void*) i); }
    inline applied_load_static_pressure load_member_distributed_surface_uniform::get_load_value() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "load_value", sdaiINSTANCE, &inst); return inst; }
    inline void load_member_distributed_surface_uniform::put_load_value(applied_load_static_pressure inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "load_value", sdaiINSTANCE, (void*) i); }
    inline node load_node::get_supporting_node() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "supporting_node", sdaiINSTANCE, &inst); return inst; }
    inline void load_node::put_supporting_node(node inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "supporting_node", sdaiINSTANCE, (void*) i); }
    inline applied_load load_node::get_load_values() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "load_values", sdaiINSTANCE, &inst); return inst; }
    inline void load_node::put_load_values(applied_load inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "load_values", sdaiINSTANCE, (void*) i); }
    inline structural_frame_product loaded_product::get_product() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "product", sdaiINSTANCE, &inst); return inst; }
    inline void loaded_product::put_product(structural_frame_product inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "product", sdaiINSTANCE, (void*) i); }
    inline applied_load loaded_product::get_load_definition() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "load_definition", sdaiINSTANCE, &inst); return inst; }
    inline void loaded_product::put_load_definition(applied_load inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "load_definition", sdaiINSTANCE, (void*) i); }
    inline physical_action loaded_product::get_time_variation() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "time_variation", sdaiINSTANCE, &inst); return inst; }
    inline void loaded_product::put_time_variation(physical_action inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "time_variation", sdaiINSTANCE, (void*) i); }
    inline analysis_model loading_combination::get_loaded_model() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "loaded_model", sdaiINSTANCE, &inst); return inst; }
    inline void loading_combination::put_loaded_model(analysis_model inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "loaded_model", sdaiINSTANCE, (void*) i); }
    inline coordinated_universal_time_offset local_time::get_zone() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "zone", sdaiINSTANCE, &inst); return inst; }
    inline void local_time::put_zone(coordinated_universal_time_offset inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "zone", sdaiINSTANCE, (void*) i); }
    inline coord_system located_item::get_location() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "location", sdaiINSTANCE, &inst); return inst; }
    inline void located_item::put_location(coord_system inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "location", sdaiINSTANCE, (void*) i); }
    inline assembly located_assembly::get_descriptive_assembly() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "descriptive_assembly", sdaiINSTANCE, &inst); return inst; }
    inline void located_assembly::put_descriptive_assembly(assembly inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "descriptive_assembly", sdaiINSTANCE, (void*) i); }
    inline feature located_feature::get_descriptive_feature() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "descriptive_feature", sdaiINSTANCE, &inst); return inst; }
    inline void located_feature::put_descriptive_feature(feature inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "descriptive_feature", sdaiINSTANCE, (void*) i); }
    inline assembly located_feature_for_assembly::get_modified_assembly() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "modified_assembly", sdaiINSTANCE, &inst); return inst; }
    inline void located_feature_for_assembly::put_modified_assembly(assembly inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "modified_assembly", sdaiINSTANCE, (void*) i); }
    inline design_part located_feature_for_design_part::get_modified_part() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "modified_part", sdaiINSTANCE, &inst); return inst; }
    inline void located_feature_for_design_part::put_modified_part(design_part inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "modified_part", sdaiINSTANCE, (void*) i); }
    inline located_assembly located_feature_for_located_assembly::get_modified_assembly() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "modified_assembly", sdaiINSTANCE, &inst); return inst; }
    inline void located_feature_for_located_assembly::put_modified_assembly(located_assembly inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "modified_assembly", sdaiINSTANCE, (void*) i); }
    inline located_part located_feature_for_located_part::get_modified_part() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "modified_part", sdaiINSTANCE, &inst); return inst; }
    inline void located_feature_for_located_part::put_modified_part(located_part inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "modified_part", sdaiINSTANCE, (void*) i); }
    inline part located_feature_for_part::get_modified_part() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "modified_part", sdaiINSTANCE, &inst); return inst; }
    inline void located_feature_for_part::put_modified_part(part inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "modified_part", sdaiINSTANCE, (void*) i); }
    inline located_joint_system located_feature_joint_dependent::get_feature_for_joint() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "feature_for_joint", sdaiINSTANCE, &inst); return inst; }
    inline void located_feature_joint_dependent::put_feature_for_joint(located_joint_system inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "feature_for_joint", sdaiINSTANCE, (void*) i); }
    inline joint_system located_joint_system::get_descriptive_joint_system() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "descriptive_joint_system", sdaiINSTANCE, &inst); return inst; }
    inline void located_joint_system::put_descriptive_joint_system(joint_system inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "descriptive_joint_system", sdaiINSTANCE, (void*) i); }
    inline located_assembly located_joint_system::get_parent_assembly() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "parent_assembly", sdaiINSTANCE, &inst); return inst; }
    inline void located_joint_system::put_parent_assembly(located_assembly inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "parent_assembly", sdaiINSTANCE, (void*) i); }
    inline part located_part::get_descriptive_part() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "descriptive_part", sdaiINSTANCE, &inst); return inst; }
    inline void located_part::put_descriptive_part(part inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "descriptive_part", sdaiINSTANCE, (void*) i); }
    inline located_assembly located_part::get_parent_assembly() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "parent_assembly", sdaiINSTANCE, &inst); return inst; }
    inline void located_part::put_parent_assembly(located_assembly inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "parent_assembly", sdaiINSTANCE, (void*) i); }
    inline site located_site::get_descriptive_site() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "descriptive_site", sdaiINSTANCE, &inst); return inst; }
    inline void located_site::put_descriptive_site(site inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "descriptive_site", sdaiINSTANCE, (void*) i); }
    inline structure located_structure::get_descriptive_structure() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "descriptive_structure", sdaiINSTANCE, &inst); return inst; }
    inline void located_structure::put_descriptive_structure(structure inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "descriptive_structure", sdaiINSTANCE, (void*) i); }
    inline organization managed_application_installation::get_application_vendor() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "application_vendor", sdaiINSTANCE, &inst); return inst; }
    inline void managed_application_installation::put_application_vendor(organization inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "application_vendor", sdaiINSTANCE, (void*) i); }
    inline organization managed_application_installation::get_installation_owner() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "installation_owner", sdaiINSTANCE, &inst); return inst; }
    inline void managed_application_installation::put_installation_owner(organization inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "installation_owner", sdaiINSTANCE, (void*) i); }
    inline managed_application_installation managed_data_transaction::get_application() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "application", sdaiINSTANCE, &inst); return inst; }
    inline void managed_data_transaction::put_application(managed_application_installation inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "application", sdaiINSTANCE, (void*) i); }
    inline person_and_organization managed_data_transaction::get_user() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "user", sdaiINSTANCE, &inst); return inst; }
    inline void managed_data_transaction::put_user(person_and_organization inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "user", sdaiINSTANCE, (void*) i); }
    inline date_and_time managed_data_transaction::get_processing_date() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "processing_date", sdaiINSTANCE, &inst); return inst; }
    inline void managed_data_transaction::put_processing_date(date_and_time inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "processing_date", sdaiINSTANCE, (void*) i); }
    inline managed_application_installation managed_data_item::get_originating_application() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "originating_application", sdaiINSTANCE, &inst); return inst; }
    inline void managed_data_item::put_originating_application(managed_application_installation inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "originating_application", sdaiINSTANCE, (void*) i); }
    inline length_measure_with_unit map_location::get_eastings() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "eastings", sdaiINSTANCE, &inst); return inst; }
    inline void map_location::put_eastings(length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "eastings", sdaiINSTANCE, (void*) i); }
    inline length_measure_with_unit map_location::get_northings() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "northings", sdaiINSTANCE, &inst); return inst; }
    inline void map_location::put_northings(length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "northings", sdaiINSTANCE, (void*) i); }
    inline representation_map mapped_item::get_mapping_source() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "mapping_source", sdaiINSTANCE, &inst); return inst; }
    inline void mapped_item::put_mapping_source(representation_map inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "mapping_source", sdaiINSTANCE, (void*) i); }
    inline representation_item mapped_item::get_mapping_target() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "mapping_target", sdaiINSTANCE, &inst); return inst; }
    inline void mapped_item::put_mapping_target(representation_item inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "mapping_target", sdaiINSTANCE, (void*) i); }
    inline material material_constituent::get_parent_material() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "parent_material", sdaiINSTANCE, &inst); return inst; }
    inline void material_constituent::put_parent_material(material inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "parent_material", sdaiINSTANCE, (void*) i); }
    inline ratio_measure_with_unit material_constituent::get_constituent_amount() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "constituent_amount", sdaiINSTANCE, &inst); return inst; }
    inline void material_constituent::put_constituent_amount(ratio_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "constituent_amount", sdaiINSTANCE, (void*) i); }
    inline material_representation material_isotropic::get_definition() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "definition", sdaiINSTANCE, &inst); return inst; }
    inline void material_isotropic::put_definition(material_representation inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "definition", sdaiINSTANCE, (void*) i); }
    inline material_representation material_orthotropic::get_in_plane_properties() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "in_plane_properties", sdaiINSTANCE, &inst); return inst; }
    inline void material_orthotropic::put_in_plane_properties(material_representation inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "in_plane_properties", sdaiINSTANCE, (void*) i); }
    inline material_representation material_orthotropic::get_out_of_plane_properties() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "out_of_plane_properties", sdaiINSTANCE, &inst); return inst; }
    inline void material_orthotropic::put_out_of_plane_properties(material_representation inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "out_of_plane_properties", sdaiINSTANCE, (void*) i); }
    inline measure_with_unit measure_qualification::get_qualified_measure() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "qualified_measure", sdaiINSTANCE, &inst); return inst; }
    inline void measure_qualification::put_qualified_measure(measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "qualified_measure", sdaiINSTANCE, (void*) i); }
    inline date_and_time media_file::get_file_date() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "file_date", sdaiINSTANCE, &inst); return inst; }
    inline void media_file::put_file_date(date_and_time inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "file_date", sdaiINSTANCE, (void*) i); }
    inline person_and_organization media_file_drawing::get_current_revision_by() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "current_revision_by", sdaiINSTANCE, &inst); return inst; }
    inline void media_file_drawing::put_current_revision_by(person_and_organization inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "current_revision_by", sdaiINSTANCE, (void*) i); }
    inline date_and_time media_file_drawing::get_current_revision_date() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "current_revision_date", sdaiINSTANCE, &inst); return inst; }
    inline void media_file_drawing::put_current_revision_date(date_and_time inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "current_revision_date", sdaiINSTANCE, (void*) i); }
    inline placement move::get_initial_location() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "initial_location", sdaiINSTANCE, &inst); return inst; }
    inline void move::put_initial_location(placement inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "initial_location", sdaiINSTANCE, (void*) i); }
    inline placement move::get_final_location() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "final_location", sdaiINSTANCE, &inst); return inst; }
    inline void move::put_final_location(placement inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "final_location", sdaiINSTANCE, (void*) i); }
    inline curve move::get_path() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "path", sdaiINSTANCE, &inst); return inst; }
    inline void move::put_path(curve inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "path", sdaiINSTANCE, (void*) i); }
    inline point node::get_node_coords() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "node_coords", sdaiINSTANCE, &inst); return inst; }
    inline void node::put_node_coords(point inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "node_coords", sdaiINSTANCE, (void*) i); }
    inline boundary_condition node::get_restraints() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "restraints", sdaiINSTANCE, &inst); return inst; }
    inline void node::put_restraints(boundary_condition inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "restraints", sdaiINSTANCE, (void*) i); }
    inline analysis_model node::get_parent_model() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "parent_model", sdaiINSTANCE, &inst); return inst; }
    inline void node::put_parent_model(analysis_model inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "parent_model", sdaiINSTANCE, (void*) i); }
    inline node node_dependency::get_master_node() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "master_node", sdaiINSTANCE, &inst); return inst; }
    inline void node_dependency::put_master_node(node inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "master_node", sdaiINSTANCE, (void*) i); }
    inline node node_dependency::get_slave_node() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "slave_node", sdaiINSTANCE, &inst); return inst; }
    inline void node_dependency::put_slave_node(node inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "slave_node", sdaiINSTANCE, (void*) i); }
    inline curve offset_curve_2d::get_basis_curve() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "basis_curve", sdaiINSTANCE, &inst); return inst; }
    inline void offset_curve_2d::put_basis_curve(curve inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "basis_curve", sdaiINSTANCE, (void*) i); }
    inline curve offset_curve_3d::get_basis_curve() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "basis_curve", sdaiINSTANCE, &inst); return inst; }
    inline void offset_curve_3d::put_basis_curve(curve inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "basis_curve", sdaiINSTANCE, (void*) i); }
    inline direction offset_curve_3d::get_ref_direction() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "ref_direction", sdaiINSTANCE, &inst); return inst; }
    inline void offset_curve_3d::put_ref_direction(direction inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "ref_direction", sdaiINSTANCE, (void*) i); }
    inline surface offset_surface::get_basis_surface() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "basis_surface", sdaiINSTANCE, &inst); return inst; }
    inline void offset_surface::put_basis_surface(surface inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "basis_surface", sdaiINSTANCE, (void*) i); }
    inline organization organization_relationship::get_relating_organization() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "relating_organization", sdaiINSTANCE, &inst); return inst; }
    inline void organization_relationship::put_relating_organization(organization inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "relating_organization", sdaiINSTANCE, (void*) i); }
    inline organization organization_relationship::get_related_organization() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "related_organization", sdaiINSTANCE, &inst); return inst; }
    inline void organization_relationship::put_related_organization(organization inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "related_organization", sdaiINSTANCE, (void*) i); }
    inline contract organization_relationship_contractual::get_assigned_contract() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "assigned_contract", sdaiINSTANCE, &inst); return inst; }
    inline void organization_relationship_contractual::put_assigned_contract(contract inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "assigned_contract", sdaiINSTANCE, (void*) i); }
    inline date_and_time organization_relationship_contractual::get_effective_start_date() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "effective_start_date", sdaiINSTANCE, &inst); return inst; }
    inline void organization_relationship_contractual::put_effective_start_date(date_and_time inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "effective_start_date", sdaiINSTANCE, (void*) i); }
    inline date_and_time organization_relationship_contractual::get_effective_end_date() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "effective_end_date", sdaiINSTANCE, &inst); return inst; }
    inline void organization_relationship_contractual::put_effective_end_date(date_and_time inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "effective_end_date", sdaiINSTANCE, (void*) i); }
    inline closed_shell oriented_closed_shell::get_closed_shell_element() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "closed_shell_element", sdaiINSTANCE, &inst); return inst; }
    inline void oriented_closed_shell::put_closed_shell_element(closed_shell inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "closed_shell_element", sdaiINSTANCE, (void*) i); }
    inline edge oriented_edge::get_edge_element() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "edge_element", sdaiINSTANCE, &inst); return inst; }
    inline void oriented_edge::put_edge_element(edge inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "edge_element", sdaiINSTANCE, (void*) i); }
    inline face oriented_face::get_face_element() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "face_element", sdaiINSTANCE, &inst); return inst; }
    inline void oriented_face::put_face_element(face inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "face_element", sdaiINSTANCE, (void*) i); }
    inline open_shell oriented_open_shell::get_open_shell_element() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "open_shell_element", sdaiINSTANCE, &inst); return inst; }
    inline void oriented_open_shell::put_open_shell_element(open_shell inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "open_shell_element", sdaiINSTANCE, (void*) i); }
    inline path oriented_path::get_path_element() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "path_element", sdaiINSTANCE, &inst); return inst; }
    inline void oriented_path::put_path_element(path inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "path_element", sdaiINSTANCE, (void*) i); }
    inline shape_representation_with_units part_complex::get_part_shape() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "part_shape", sdaiINSTANCE, &inst); return inst; }
    inline void part_complex::put_part_shape(shape_representation_with_units inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "part_shape", sdaiINSTANCE, (void*) i); }
    inline part part_derived::get_made_from() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "made_from", sdaiINSTANCE, &inst); return inst; }
    inline void part_derived::put_made_from(part inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "made_from", sdaiINSTANCE, (void*) i); }
    inline part part_map::get_represented_part() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "represented_part", sdaiINSTANCE, &inst); return inst; }
    inline void part_map::put_represented_part(part inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "represented_part", sdaiINSTANCE, (void*) i); }
    inline length_measure_with_unit part_prismatic_complex_tapered::get_absolute_taper_1() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "absolute_taper_1", sdaiINSTANCE, &inst); return inst; }
    inline void part_prismatic_complex_tapered::put_absolute_taper_1(length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "absolute_taper_1", sdaiINSTANCE, (void*) i); }
    inline length_measure_with_unit part_prismatic_complex_tapered::get_absolute_taper_2() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "absolute_taper_2", sdaiINSTANCE, &inst); return inst; }
    inline void part_prismatic_complex_tapered::put_absolute_taper_2(length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "absolute_taper_2", sdaiINSTANCE, (void*) i); }
    inline ratio_measure_with_unit part_prismatic_complex_tapered::get_relative_taper_1() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "relative_taper_1", sdaiINSTANCE, &inst); return inst; }
    inline void part_prismatic_complex_tapered::put_relative_taper_1(ratio_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "relative_taper_1", sdaiINSTANCE, (void*) i); }
    inline ratio_measure_with_unit part_prismatic_complex_tapered::get_relative_taper_2() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "relative_taper_2", sdaiINSTANCE, &inst); return inst; }
    inline void part_prismatic_complex_tapered::put_relative_taper_2(ratio_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "relative_taper_2", sdaiINSTANCE, (void*) i); }
    inline section_profile part_prismatic_simple::get_profile() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "profile", sdaiINSTANCE, &inst); return inst; }
    inline void part_prismatic_simple::put_profile(section_profile inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "profile", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit part_prismatic_simple::get_cut_length() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "cut_length", sdaiINSTANCE, &inst); return inst; }
    inline void part_prismatic_simple::put_cut_length(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "cut_length", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit part_prismatic_simple::get_stock_length() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "stock_length", sdaiINSTANCE, &inst); return inst; }
    inline void part_prismatic_simple::put_stock_length(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "stock_length", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit part_prismatic_simple::get_x_offset() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "x_offset", sdaiINSTANCE, &inst); return inst; }
    inline void part_prismatic_simple::put_x_offset(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "x_offset", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit part_prismatic_simple_cambered_absolute::get_absolute_offset_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "absolute_offset_position", sdaiINSTANCE, &inst); return inst; }
    inline void part_prismatic_simple_cambered_absolute::put_absolute_offset_position(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "absolute_offset_position", sdaiINSTANCE, (void*) i); }
    inline length_measure_with_unit part_prismatic_simple_cambered_absolute::get_absolute_offset_y() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "absolute_offset_y", sdaiINSTANCE, &inst); return inst; }
    inline void part_prismatic_simple_cambered_absolute::put_absolute_offset_y(length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "absolute_offset_y", sdaiINSTANCE, (void*) i); }
    inline length_measure_with_unit part_prismatic_simple_cambered_absolute::get_absolute_offset_z() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "absolute_offset_z", sdaiINSTANCE, &inst); return inst; }
    inline void part_prismatic_simple_cambered_absolute::put_absolute_offset_z(length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "absolute_offset_z", sdaiINSTANCE, (void*) i); }
    inline ratio_measure_with_unit part_prismatic_simple_cambered_relative::get_relative_offset_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "relative_offset_position", sdaiINSTANCE, &inst); return inst; }
    inline void part_prismatic_simple_cambered_relative::put_relative_offset_position(ratio_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "relative_offset_position", sdaiINSTANCE, (void*) i); }
    inline ratio_measure_with_unit part_prismatic_simple_cambered_relative::get_relative_offset_y() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "relative_offset_y", sdaiINSTANCE, &inst); return inst; }
    inline void part_prismatic_simple_cambered_relative::put_relative_offset_y(ratio_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "relative_offset_y", sdaiINSTANCE, (void*) i); }
    inline ratio_measure_with_unit part_prismatic_simple_cambered_relative::get_relative_offset_z() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "relative_offset_z", sdaiINSTANCE, &inst); return inst; }
    inline void part_prismatic_simple_cambered_relative::put_relative_offset_z(ratio_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "relative_offset_z", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit part_prismatic_simple_castellated::get_end_post_width_1() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "end_post_width_1", sdaiINSTANCE, &inst); return inst; }
    inline void part_prismatic_simple_castellated::put_end_post_width_1(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "end_post_width_1", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit part_prismatic_simple_castellated::get_end_post_width_2() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "end_post_width_2", sdaiINSTANCE, &inst); return inst; }
    inline void part_prismatic_simple_castellated::put_end_post_width_2(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "end_post_width_2", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit part_prismatic_simple_castellated::get_castellation_spacing() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "castellation_spacing", sdaiINSTANCE, &inst); return inst; }
    inline void part_prismatic_simple_castellated::put_castellation_spacing(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "castellation_spacing", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit part_prismatic_simple_castellated::get_castellation_height() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "castellation_height", sdaiINSTANCE, &inst); return inst; }
    inline void part_prismatic_simple_castellated::put_castellation_height(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "castellation_height", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit part_prismatic_simple_castellated::get_castellation_width() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "castellation_width", sdaiINSTANCE, &inst); return inst; }
    inline void part_prismatic_simple_castellated::put_castellation_width(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "castellation_width", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit part_prismatic_simple_castellated::get_castellation_depth() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "castellation_depth", sdaiINSTANCE, &inst); return inst; }
    inline void part_prismatic_simple_castellated::put_castellation_depth(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "castellation_depth", sdaiINSTANCE, (void*) i); }
    inline curve part_prismatic_simple_curved::get_axis_definition() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "axis_definition", sdaiINSTANCE, &inst); return inst; }
    inline void part_prismatic_simple_curved::put_axis_definition(curve inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "axis_definition", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit part_sheet::get_sheet_thickness() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "sheet_thickness", sdaiINSTANCE, &inst); return inst; }
    inline void part_sheet::put_sheet_thickness(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "sheet_thickness", sdaiINSTANCE, (void*) i); }
    inline bounded_surface part_sheet_bounded_complex::get_sheet_boundary() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "sheet_boundary", sdaiINSTANCE, &inst); return inst; }
    inline void part_sheet_bounded_complex::put_sheet_boundary(bounded_surface inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "sheet_boundary", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit part_sheet_bounded_simple::get_cut_y_dimension() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "cut_y_dimension", sdaiINSTANCE, &inst); return inst; }
    inline void part_sheet_bounded_simple::put_cut_y_dimension(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "cut_y_dimension", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit part_sheet_bounded_simple::get_cut_z_dimension() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "cut_z_dimension", sdaiINSTANCE, &inst); return inst; }
    inline void part_sheet_bounded_simple::put_cut_z_dimension(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "cut_z_dimension", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit part_sheet_bounded_simple::get_stock_y_dimension() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "stock_y_dimension", sdaiINSTANCE, &inst); return inst; }
    inline void part_sheet_bounded_simple::put_stock_y_dimension(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "stock_y_dimension", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit part_sheet_bounded_simple::get_stock_z_dimension() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "stock_z_dimension", sdaiINSTANCE, &inst); return inst; }
    inline void part_sheet_bounded_simple::put_stock_z_dimension(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "stock_z_dimension", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit part_sheet_bounded_simple::get_y_offset() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "y_offset", sdaiINSTANCE, &inst); return inst; }
    inline void part_sheet_bounded_simple::put_y_offset(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "y_offset", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit part_sheet_bounded_simple::get_z_offset() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "z_offset", sdaiINSTANCE, &inst); return inst; }
    inline void part_sheet_bounded_simple::put_z_offset(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "z_offset", sdaiINSTANCE, (void*) i); }
    inline curve part_sheet_profiled::get_sheet_profile() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "sheet_profile", sdaiINSTANCE, &inst); return inst; }
    inline void part_sheet_profiled::put_sheet_profile(curve inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "sheet_profile", sdaiINSTANCE, (void*) i); }
    inline section_properties part_sheet_profiled::get_profile_properties() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "profile_properties", sdaiINSTANCE, &inst); return inst; }
    inline void part_sheet_profiled::put_profile_properties(section_properties inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "profile_properties", sdaiINSTANCE, (void*) i); }
    inline person person_and_organization::get_the_person() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "the_person", sdaiINSTANCE, &inst); return inst; }
    inline void person_and_organization::put_the_person(person inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "the_person", sdaiINSTANCE, (void*) i); }
    inline organization person_and_organization::get_the_organization() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "the_organization", sdaiINSTANCE, &inst); return inst; }
    inline void person_and_organization::put_the_organization(organization inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "the_organization", sdaiINSTANCE, (void*) i); }
    inline measure_with_unit physical_action::get_basic_magnitude() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "basic_magnitude", sdaiINSTANCE, &inst); return inst; }
    inline void physical_action::put_basic_magnitude(measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "basic_magnitude", sdaiINSTANCE, (void*) i); }
    inline measure_with_unit physical_action::get_derived_magnitude() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "derived_magnitude", sdaiINSTANCE, &inst); return inst; }
    inline void physical_action::put_derived_magnitude(measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "derived_magnitude", sdaiINSTANCE, (void*) i); }
    inline volume point_in_volume::get_basis_volume() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "basis_volume", sdaiINSTANCE, &inst); return inst; }
    inline void point_in_volume::put_basis_volume(volume inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "basis_volume", sdaiINSTANCE, (void*) i); }
    inline curve point_on_curve::get_basis_curve() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "basis_curve", sdaiINSTANCE, &inst); return inst; }
    inline void point_on_curve::put_basis_curve(curve inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "basis_curve", sdaiINSTANCE, (void*) i); }
    inline surface point_on_surface::get_basis_surface() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "basis_surface", sdaiINSTANCE, &inst); return inst; }
    inline void point_on_surface::put_basis_surface(surface inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "basis_surface", sdaiINSTANCE, (void*) i); }
    inline point point_replica::get_parent_pt() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "parent_pt", sdaiINSTANCE, &inst); return inst; }
    inline void point_replica::put_parent_pt(point inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "parent_pt", sdaiINSTANCE, (void*) i); }
    inline cartesian_transformation_operator point_replica::get_transformation() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "transformation", sdaiINSTANCE, &inst); return inst; }
    inline void point_replica::put_transformation(cartesian_transformation_operator inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "transformation", sdaiINSTANCE, (void*) i); }
    inline person_and_organization procure::get_vendors() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "vendors", sdaiINSTANCE, &inst); return inst; }
    inline void procure::put_vendors(person_and_organization inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "vendors", sdaiINSTANCE, (void*) i); }
    inline person_and_organization procure::get_purchaser() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "purchaser", sdaiINSTANCE, &inst); return inst; }
    inline void procure::put_purchaser(person_and_organization inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "purchaser", sdaiINSTANCE, (void*) i); }
    inline contract procure::get_sales_contract() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "sales_contract", sdaiINSTANCE, &inst); return inst; }
    inline void procure::put_sales_contract(contract inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "sales_contract", sdaiINSTANCE, (void*) i); }
    inline project project_data_group::get_parent_project() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "parent_project", sdaiINSTANCE, &inst); return inst; }
    inline void project_data_group::put_parent_project(project inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "parent_project", sdaiINSTANCE, (void*) i); }
    inline person_and_organization project_organization::get_project_participant() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "project_participant", sdaiINSTANCE, &inst); return inst; }
    inline void project_organization::put_project_participant(person_and_organization inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "project_participant", sdaiINSTANCE, (void*) i); }
    inline project project_organization::get_related_project() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "related_project", sdaiINSTANCE, &inst); return inst; }
    inline void project_organization::put_related_project(project inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "related_project", sdaiINSTANCE, (void*) i); }
    inline person_and_organization_role project_organization::get_role() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "role", sdaiINSTANCE, &inst); return inst; }
    inline void project_organization::put_role(person_and_organization_role inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "role", sdaiINSTANCE, (void*) i); }
    inline project_organization project_plan::get_project_plan_author() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "project_plan_author", sdaiINSTANCE, &inst); return inst; }
    inline void project_plan::put_project_plan_author(project_organization inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "project_plan_author", sdaiINSTANCE, (void*) i); }
    inline date_and_time project_plan::get_project_plan_date() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "project_plan_date", sdaiINSTANCE, &inst); return inst; }
    inline void project_plan::put_project_plan_date(date_and_time inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "project_plan_date", sdaiINSTANCE, (void*) i); }
    inline project project_plan::get_related_project() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "related_project", sdaiINSTANCE, &inst); return inst; }
    inline void project_plan::put_related_project(project inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "related_project", sdaiINSTANCE, (void*) i); }
    inline project_plan project_plan_item::get_item_for_plan() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "item_for_plan", sdaiINSTANCE, &inst); return inst; }
    inline void project_plan_item::put_item_for_plan(project_plan inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "item_for_plan", sdaiINSTANCE, (void*) i); }
    inline date_and_time project_plan_item::get_start_date() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "start_date", sdaiINSTANCE, &inst); return inst; }
    inline void project_plan_item::put_start_date(date_and_time inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "start_date", sdaiINSTANCE, (void*) i); }
    inline date_and_time project_plan_item::get_end_date() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "end_date", sdaiINSTANCE, &inst); return inst; }
    inline void project_plan_item::put_end_date(date_and_time inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "end_date", sdaiINSTANCE, (void*) i); }
    inline time_measure_with_unit project_plan_item::get_item_duration() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "item_duration", sdaiINSTANCE, &inst); return inst; }
    inline void project_plan_item::put_item_duration(time_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "item_duration", sdaiINSTANCE, (void*) i); }
    inline project_plan_item project_plan_item_relationship::get_related_plan_item() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "related_plan_item", sdaiINSTANCE, &inst); return inst; }
    inline void project_plan_item_relationship::put_related_plan_item(project_plan_item inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "related_plan_item", sdaiINSTANCE, (void*) i); }
    inline project_plan_item project_plan_item_relationship::get_relating_plan_item() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "relating_plan_item", sdaiINSTANCE, &inst); return inst; }
    inline void project_plan_item_relationship::put_relating_plan_item(project_plan_item inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "relating_plan_item", sdaiINSTANCE, (void*) i); }
    inline structural_frame_process project_process_item::get_scheduled_process() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "scheduled_process", sdaiINSTANCE, &inst); return inst; }
    inline void project_process_item::put_scheduled_process(structural_frame_process inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "scheduled_process", sdaiINSTANCE, (void*) i); }
    inline axis2_placement_3d pyramid_volume::get_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "position", sdaiINSTANCE, &inst); return inst; }
    inline void pyramid_volume::put_position(axis2_placement_3d inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "position", sdaiINSTANCE, (void*) i); }
    inline linear_acceleration_measure_with_unit reaction_acceleration::get_reaction_acceleration_ax() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reaction_acceleration_ax", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_acceleration::put_reaction_acceleration_ax(linear_acceleration_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reaction_acceleration_ax", sdaiINSTANCE, (void*) i); }
    inline linear_acceleration_measure_with_unit reaction_acceleration::get_reaction_acceleration_ay() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reaction_acceleration_ay", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_acceleration::put_reaction_acceleration_ay(linear_acceleration_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reaction_acceleration_ay", sdaiINSTANCE, (void*) i); }
    inline linear_acceleration_measure_with_unit reaction_acceleration::get_reaction_acceleration_az() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reaction_acceleration_az", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_acceleration::put_reaction_acceleration_az(linear_acceleration_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reaction_acceleration_az", sdaiINSTANCE, (void*) i); }
    inline rotational_acceleration_measure_with_unit reaction_acceleration::get_reaction_acceleration_arx() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reaction_acceleration_arx", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_acceleration::put_reaction_acceleration_arx(rotational_acceleration_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reaction_acceleration_arx", sdaiINSTANCE, (void*) i); }
    inline rotational_acceleration_measure_with_unit reaction_acceleration::get_reaction_acceleration_ary() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reaction_acceleration_ary", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_acceleration::put_reaction_acceleration_ary(rotational_acceleration_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reaction_acceleration_ary", sdaiINSTANCE, (void*) i); }
    inline rotational_acceleration_measure_with_unit reaction_acceleration::get_reaction_acceleration_arz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reaction_acceleration_arz", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_acceleration::put_reaction_acceleration_arz(rotational_acceleration_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reaction_acceleration_arz", sdaiINSTANCE, (void*) i); }
    inline length_measure_with_unit reaction_displacement::get_reaction_displacement_dx() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reaction_displacement_dx", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_displacement::put_reaction_displacement_dx(length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reaction_displacement_dx", sdaiINSTANCE, (void*) i); }
    inline length_measure_with_unit reaction_displacement::get_reaction_displacement_dy() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reaction_displacement_dy", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_displacement::put_reaction_displacement_dy(length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reaction_displacement_dy", sdaiINSTANCE, (void*) i); }
    inline length_measure_with_unit reaction_displacement::get_reaction_displacement_dz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reaction_displacement_dz", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_displacement::put_reaction_displacement_dz(length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reaction_displacement_dz", sdaiINSTANCE, (void*) i); }
    inline plane_angle_measure_with_unit reaction_displacement::get_reaction_displacement_rx() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reaction_displacement_rx", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_displacement::put_reaction_displacement_rx(plane_angle_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reaction_displacement_rx", sdaiINSTANCE, (void*) i); }
    inline plane_angle_measure_with_unit reaction_displacement::get_reaction_displacement_ry() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reaction_displacement_ry", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_displacement::put_reaction_displacement_ry(plane_angle_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reaction_displacement_ry", sdaiINSTANCE, (void*) i); }
    inline plane_angle_measure_with_unit reaction_displacement::get_reaction_displacement_rz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reaction_displacement_rz", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_displacement::put_reaction_displacement_rz(plane_angle_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reaction_displacement_rz", sdaiINSTANCE, (void*) i); }
    inline plane_angle_measure_with_unit reaction_dynamic::get_phase_angle() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "phase_angle", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_dynamic::put_phase_angle(plane_angle_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "phase_angle", sdaiINSTANCE, (void*) i); }
    inline length_measure_with_unit reaction_dynamic::get_response_amplitude() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "response_amplitude", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_dynamic::put_response_amplitude(length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "response_amplitude", sdaiINSTANCE, (void*) i); }
    inline frequency_measure_with_unit reaction_dynamic::get_natural_frequency() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "natural_frequency", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_dynamic::put_natural_frequency(frequency_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "natural_frequency", sdaiINSTANCE, (void*) i); }
    inline ratio_measure_with_unit reaction_equilibrium::get_equilibrium_dx() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "equilibrium_dx", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_equilibrium::put_equilibrium_dx(ratio_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "equilibrium_dx", sdaiINSTANCE, (void*) i); }
    inline ratio_measure_with_unit reaction_equilibrium::get_equilibrium_dy() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "equilibrium_dy", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_equilibrium::put_equilibrium_dy(ratio_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "equilibrium_dy", sdaiINSTANCE, (void*) i); }
    inline ratio_measure_with_unit reaction_equilibrium::get_equilibrium_dz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "equilibrium_dz", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_equilibrium::put_equilibrium_dz(ratio_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "equilibrium_dz", sdaiINSTANCE, (void*) i); }
    inline ratio_measure_with_unit reaction_equilibrium::get_equilibrium_mx() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "equilibrium_mx", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_equilibrium::put_equilibrium_mx(ratio_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "equilibrium_mx", sdaiINSTANCE, (void*) i); }
    inline ratio_measure_with_unit reaction_equilibrium::get_equilibrium_my() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "equilibrium_my", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_equilibrium::put_equilibrium_my(ratio_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "equilibrium_my", sdaiINSTANCE, (void*) i); }
    inline ratio_measure_with_unit reaction_equilibrium::get_equilibrium_mz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "equilibrium_mz", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_equilibrium::put_equilibrium_mz(ratio_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "equilibrium_mz", sdaiINSTANCE, (void*) i); }
    inline force_measure_with_unit reaction_force::get_reaction_force_fx() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reaction_force_fx", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_force::put_reaction_force_fx(force_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reaction_force_fx", sdaiINSTANCE, (void*) i); }
    inline force_measure_with_unit reaction_force::get_reaction_force_fy() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reaction_force_fy", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_force::put_reaction_force_fy(force_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reaction_force_fy", sdaiINSTANCE, (void*) i); }
    inline force_measure_with_unit reaction_force::get_reaction_force_fz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reaction_force_fz", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_force::put_reaction_force_fz(force_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reaction_force_fz", sdaiINSTANCE, (void*) i); }
    inline moment_measure_with_unit reaction_force::get_reaction_force_mx() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reaction_force_mx", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_force::put_reaction_force_mx(moment_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reaction_force_mx", sdaiINSTANCE, (void*) i); }
    inline moment_measure_with_unit reaction_force::get_reaction_force_my() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reaction_force_my", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_force::put_reaction_force_my(moment_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reaction_force_my", sdaiINSTANCE, (void*) i); }
    inline moment_measure_with_unit reaction_force::get_reaction_force_mz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reaction_force_mz", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_force::put_reaction_force_mz(moment_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reaction_force_mz", sdaiINSTANCE, (void*) i); }
    inline linear_velocity_measure_with_unit reaction_velocity::get_reaction_velocity_vx() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reaction_velocity_vx", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_velocity::put_reaction_velocity_vx(linear_velocity_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reaction_velocity_vx", sdaiINSTANCE, (void*) i); }
    inline linear_velocity_measure_with_unit reaction_velocity::get_reaction_velocity_vy() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reaction_velocity_vy", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_velocity::put_reaction_velocity_vy(linear_velocity_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reaction_velocity_vy", sdaiINSTANCE, (void*) i); }
    inline linear_velocity_measure_with_unit reaction_velocity::get_reaction_velocity_vz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reaction_velocity_vz", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_velocity::put_reaction_velocity_vz(linear_velocity_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reaction_velocity_vz", sdaiINSTANCE, (void*) i); }
    inline rotational_velocity_measure_with_unit reaction_velocity::get_reaction_velocity_vrx() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reaction_velocity_vrx", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_velocity::put_reaction_velocity_vrx(rotational_velocity_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reaction_velocity_vrx", sdaiINSTANCE, (void*) i); }
    inline rotational_velocity_measure_with_unit reaction_velocity::get_reaction_velocity_vry() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reaction_velocity_vry", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_velocity::put_reaction_velocity_vry(rotational_velocity_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reaction_velocity_vry", sdaiINSTANCE, (void*) i); }
    inline rotational_velocity_measure_with_unit reaction_velocity::get_reaction_velocity_vrz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reaction_velocity_vrz", sdaiINSTANCE, &inst); return inst; }
    inline void reaction_velocity::put_reaction_velocity_vrz(rotational_velocity_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reaction_velocity_vrz", sdaiINSTANCE, (void*) i); }
    inline axis2_placement_2d rectangular_area::get_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "position", sdaiINSTANCE, &inst); return inst; }
    inline void rectangular_area::put_position(axis2_placement_2d inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "position", sdaiINSTANCE, (void*) i); }
    inline axis2_placement_3d rectangular_pyramid::get_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "position", sdaiINSTANCE, &inst); return inst; }
    inline void rectangular_pyramid::put_position(axis2_placement_3d inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "position", sdaiINSTANCE, (void*) i); }
    inline surface rectangular_trimmed_surface::get_basis_surface() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "basis_surface", sdaiINSTANCE, &inst); return inst; }
    inline void rectangular_trimmed_surface::put_basis_surface(surface inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "basis_surface", sdaiINSTANCE, (void*) i); }
    inline linear_stiffness_measure_with_unit release_spring_linear::get_release_axial_force() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "release_axial_force", sdaiINSTANCE, &inst); return inst; }
    inline void release_spring_linear::put_release_axial_force(linear_stiffness_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "release_axial_force", sdaiINSTANCE, (void*) i); }
    inline linear_stiffness_measure_with_unit release_spring_linear::get_release_y_force() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "release_y_force", sdaiINSTANCE, &inst); return inst; }
    inline void release_spring_linear::put_release_y_force(linear_stiffness_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "release_y_force", sdaiINSTANCE, (void*) i); }
    inline linear_stiffness_measure_with_unit release_spring_linear::get_release_z_force() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "release_z_force", sdaiINSTANCE, &inst); return inst; }
    inline void release_spring_linear::put_release_z_force(linear_stiffness_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "release_z_force", sdaiINSTANCE, (void*) i); }
    inline rotational_stiffness_measure_with_unit release_spring_linear::get_release_torsional_moment() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "release_torsional_moment", sdaiINSTANCE, &inst); return inst; }
    inline void release_spring_linear::put_release_torsional_moment(rotational_stiffness_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "release_torsional_moment", sdaiINSTANCE, (void*) i); }
    inline rotational_stiffness_measure_with_unit release_spring_linear::get_release_y_bending_moment() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "release_y_bending_moment", sdaiINSTANCE, &inst); return inst; }
    inline void release_spring_linear::put_release_y_bending_moment(rotational_stiffness_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "release_y_bending_moment", sdaiINSTANCE, (void*) i); }
    inline rotational_stiffness_measure_with_unit release_spring_linear::get_release_z_bending_moment() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "release_z_bending_moment", sdaiINSTANCE, &inst); return inst; }
    inline void release_spring_linear::put_release_z_bending_moment(rotational_stiffness_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "release_z_bending_moment", sdaiINSTANCE, (void*) i); }
    inline rotational_stiffness_measure_with_unit release_warping::get_release_warping_moment() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "release_warping_moment", sdaiINSTANCE, &inst); return inst; }
    inline void release_warping::put_release_warping_moment(rotational_stiffness_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "release_warping_moment", sdaiINSTANCE, (void*) i); }
    inline representation_item representation_map::get_mapping_origin() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "mapping_origin", sdaiINSTANCE, &inst); return inst; }
    inline void representation_map::put_mapping_origin(representation_item inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "mapping_origin", sdaiINSTANCE, (void*) i); }
    inline representation representation_map::get_mapped_representation() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "mapped_representation", sdaiINSTANCE, &inst); return inst; }
    inline void representation_map::put_mapped_representation(representation inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "mapped_representation", sdaiINSTANCE, (void*) i); }
    inline representation representation_relationship::get_rep_1() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "rep_1", sdaiINSTANCE, &inst); return inst; }
    inline void representation_relationship::put_rep_1(representation inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "rep_1", sdaiINSTANCE, (void*) i); }
    inline representation representation_relationship::get_rep_2() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "rep_2", sdaiINSTANCE, &inst); return inst; }
    inline void representation_relationship::put_rep_2(representation inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "rep_2", sdaiINSTANCE, (void*) i); }
    inline force_measure_with_unit resistance_axial::get_tensile_resistance_ptx() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "tensile_resistance_ptx", sdaiINSTANCE, &inst); return inst; }
    inline void resistance_axial::put_tensile_resistance_ptx(force_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "tensile_resistance_ptx", sdaiINSTANCE, (void*) i); }
    inline force_measure_with_unit resistance_axial::get_compressive_resistance_pcx() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "compressive_resistance_pcx", sdaiINSTANCE, &inst); return inst; }
    inline void resistance_axial::put_compressive_resistance_pcx(force_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "compressive_resistance_pcx", sdaiINSTANCE, (void*) i); }
    inline moment_measure_with_unit resistance_bending::get_torsional_resistance_mx() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "torsional_resistance_mx", sdaiINSTANCE, &inst); return inst; }
    inline void resistance_bending::put_torsional_resistance_mx(moment_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "torsional_resistance_mx", sdaiINSTANCE, (void*) i); }
    inline moment_measure_with_unit resistance_bending::get_bending_resistance_my() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "bending_resistance_my", sdaiINSTANCE, &inst); return inst; }
    inline void resistance_bending::put_bending_resistance_my(moment_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "bending_resistance_my", sdaiINSTANCE, (void*) i); }
    inline moment_measure_with_unit resistance_bending::get_bending_resistance_mz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "bending_resistance_mz", sdaiINSTANCE, &inst); return inst; }
    inline void resistance_bending::put_bending_resistance_mz(moment_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "bending_resistance_mz", sdaiINSTANCE, (void*) i); }
    inline moment_measure_with_unit resistance_bending::get_buckling_resistance_mb() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "buckling_resistance_mb", sdaiINSTANCE, &inst); return inst; }
    inline void resistance_bending::put_buckling_resistance_mb(moment_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "buckling_resistance_mb", sdaiINSTANCE, (void*) i); }
    inline force_measure_with_unit resistance_shear::get_normal_shear_resistance_pv() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "normal_shear_resistance_pv", sdaiINSTANCE, &inst); return inst; }
    inline void resistance_shear::put_normal_shear_resistance_pv(force_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "normal_shear_resistance_pv", sdaiINSTANCE, (void*) i); }
    inline force_measure_with_unit resistance_shear::get_buckling_shear_resistance_pbv() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "buckling_shear_resistance_pbv", sdaiINSTANCE, &inst); return inst; }
    inline void resistance_shear::put_buckling_shear_resistance_pbv(force_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "buckling_shear_resistance_pbv", sdaiINSTANCE, (void*) i); }
    inline point restraint::get_restraint_location() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "restraint_location", sdaiINSTANCE, &inst); return inst; }
    inline void restraint::put_restraint_location(point inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "restraint_location", sdaiINSTANCE, (void*) i); }
    inline assembly_design_structural_member restraint::get_restrained_mbr() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "restrained_mbr", sdaiINSTANCE, &inst); return inst; }
    inline void restraint::put_restrained_mbr(assembly_design_structural_member inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "restrained_mbr", sdaiINSTANCE, (void*) i); }
    inline linear_stiffness_measure_with_unit restraint_spring::get_restraint_x_displacement() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "restraint_x_displacement", sdaiINSTANCE, &inst); return inst; }
    inline void restraint_spring::put_restraint_x_displacement(linear_stiffness_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "restraint_x_displacement", sdaiINSTANCE, (void*) i); }
    inline linear_stiffness_measure_with_unit restraint_spring::get_restraint_y_displacement() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "restraint_y_displacement", sdaiINSTANCE, &inst); return inst; }
    inline void restraint_spring::put_restraint_y_displacement(linear_stiffness_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "restraint_y_displacement", sdaiINSTANCE, (void*) i); }
    inline linear_stiffness_measure_with_unit restraint_spring::get_restraint_z_displacement() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "restraint_z_displacement", sdaiINSTANCE, &inst); return inst; }
    inline void restraint_spring::put_restraint_z_displacement(linear_stiffness_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "restraint_z_displacement", sdaiINSTANCE, (void*) i); }
    inline rotational_stiffness_measure_with_unit restraint_spring::get_restraint_x_rotation() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "restraint_x_rotation", sdaiINSTANCE, &inst); return inst; }
    inline void restraint_spring::put_restraint_x_rotation(rotational_stiffness_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "restraint_x_rotation", sdaiINSTANCE, (void*) i); }
    inline rotational_stiffness_measure_with_unit restraint_spring::get_restraint_y_rotation() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "restraint_y_rotation", sdaiINSTANCE, &inst); return inst; }
    inline void restraint_spring::put_restraint_y_rotation(rotational_stiffness_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "restraint_y_rotation", sdaiINSTANCE, (void*) i); }
    inline rotational_stiffness_measure_with_unit restraint_spring::get_restraint_z_rotation() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "restraint_z_rotation", sdaiINSTANCE, &inst); return inst; }
    inline void restraint_spring::put_restraint_z_rotation(rotational_stiffness_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "restraint_z_rotation", sdaiINSTANCE, (void*) i); }
    inline rotational_stiffness_measure_with_unit restraint_warping::get_restraint_w_rotation() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "restraint_w_rotation", sdaiINSTANCE, &inst); return inst; }
    inline void restraint_warping::put_restraint_w_rotation(rotational_stiffness_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "restraint_w_rotation", sdaiINSTANCE, (void*) i); }
    inline axis1_placement revolved_area_solid::get_axis() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "axis", sdaiINSTANCE, &inst); return inst; }
    inline void revolved_area_solid::put_axis(axis1_placement inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "axis", sdaiINSTANCE, (void*) i); }
    inline axis1_placement revolved_face_solid::get_axis() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "axis", sdaiINSTANCE, &inst); return inst; }
    inline void revolved_face_solid::put_axis(axis1_placement inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "axis", sdaiINSTANCE, (void*) i); }
    inline axis2_placement_3d right_angular_wedge::get_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "position", sdaiINSTANCE, &inst); return inst; }
    inline void right_angular_wedge::put_position(axis2_placement_3d inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "position", sdaiINSTANCE, (void*) i); }
    inline axis1_placement right_circular_cone::get_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "position", sdaiINSTANCE, &inst); return inst; }
    inline void right_circular_cone::put_position(axis1_placement inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "position", sdaiINSTANCE, (void*) i); }
    inline axis1_placement right_circular_cylinder::get_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "position", sdaiINSTANCE, &inst); return inst; }
    inline void right_circular_cylinder::put_position(axis1_placement inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "position", sdaiINSTANCE, (void*) i); }
    inline object_role role_association::get_role() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "role", sdaiINSTANCE, &inst); return inst; }
    inline void role_association::put_role(object_role inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "role", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_angle::get_depth() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "depth", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_angle::put_depth(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "depth", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_angle::get_width() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "width", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_angle::put_width(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "width", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_angle::get_thickness() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "thickness", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_angle::put_thickness(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "thickness", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_angle::get_internal_fillet_radius() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "internal_fillet_radius", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_angle::put_internal_fillet_radius(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "internal_fillet_radius", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_angle::get_edge_fillet_radius() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "edge_fillet_radius", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_angle::put_edge_fillet_radius(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "edge_fillet_radius", sdaiINSTANCE, (void*) i); }
    inline ratio_measure_with_unit section_profile_angle::get_leg_slope() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "leg_slope", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_angle::put_leg_slope(ratio_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "leg_slope", sdaiINSTANCE, (void*) i); }
    inline curve section_profile_centreline::get_centreline() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "centreline", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_centreline::put_centreline(curve inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "centreline", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_centreline::get_thickness() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "thickness", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_centreline::put_thickness(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "thickness", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_channel::get_overall_depth() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "overall_depth", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_channel::put_overall_depth(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "overall_depth", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_channel::get_flange_width() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "flange_width", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_channel::put_flange_width(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "flange_width", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_channel::get_flange_thickness() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "flange_thickness", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_channel::put_flange_thickness(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "flange_thickness", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_channel::get_web_thickness() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "web_thickness", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_channel::put_web_thickness(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "web_thickness", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_channel::get_root_radius() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "root_radius", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_channel::put_root_radius(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "root_radius", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_channel::get_fillet_radius() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "fillet_radius", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_channel::put_fillet_radius(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "fillet_radius", sdaiINSTANCE, (void*) i); }
    inline ratio_measure_with_unit section_profile_channel::get_flange_slope() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "flange_slope", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_channel::put_flange_slope(ratio_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "flange_slope", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_circle::get_external_radius() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "external_radius", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_circle::put_external_radius(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "external_radius", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_circle_hollow::get_wall_thickness() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "wall_thickness", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_circle_hollow::put_wall_thickness(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "wall_thickness", sdaiINSTANCE, (void*) i); }
    inline section_profile section_profile_derived::get_original_section() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "original_section", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_derived::put_original_section(section_profile inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "original_section", sdaiINSTANCE, (void*) i); }
    inline bounded_curve section_profile_edge_defined::get_external_edge() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "external_edge", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_edge_defined::put_external_edge(bounded_curve inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "external_edge", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_i_type::get_overall_depth() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "overall_depth", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_i_type::put_overall_depth(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "overall_depth", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_i_type::get_overall_width() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "overall_width", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_i_type::put_overall_width(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "overall_width", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_i_type::get_web_thickness() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "web_thickness", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_i_type::put_web_thickness(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "web_thickness", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_i_type::get_flange_thickness() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "flange_thickness", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_i_type::put_flange_thickness(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "flange_thickness", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_i_type::get_internal_depth() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "internal_depth", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_i_type::put_internal_depth(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "internal_depth", sdaiINSTANCE, (void*) i); }
    inline ratio_measure_with_unit section_profile_i_type::get_flange_slope() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "flange_slope", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_i_type::put_flange_slope(ratio_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "flange_slope", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_i_type::get_root_radius() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "root_radius", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_i_type::put_root_radius(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "root_radius", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_i_type::get_edge_radius() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "edge_radius", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_i_type::put_edge_radius(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "edge_radius", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_i_type_asymmetric::get_top_flange_width() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "top_flange_width", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_i_type_asymmetric::put_top_flange_width(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "top_flange_width", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_i_type_asymmetric::get_bottom_flange_width() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "bottom_flange_width", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_i_type_asymmetric::put_bottom_flange_width(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "bottom_flange_width", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_i_type_asymmetric::get_bottom_flange_thickness() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "bottom_flange_thickness", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_i_type_asymmetric::put_bottom_flange_thickness(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "bottom_flange_thickness", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_i_type_asymmetric::get_bottom_root_radius() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "bottom_root_radius", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_i_type_asymmetric::put_bottom_root_radius(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "bottom_root_radius", sdaiINSTANCE, (void*) i); }
    inline ratio_measure_with_unit section_profile_i_type_asymmetric::get_bottom_flange_slope() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "bottom_flange_slope", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_i_type_asymmetric::put_bottom_flange_slope(ratio_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "bottom_flange_slope", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_i_type_asymmetric::get_bottom_flange_edge_radius() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "bottom_flange_edge_radius", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_i_type_asymmetric::put_bottom_flange_edge_radius(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "bottom_flange_edge_radius", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_i_type_rail::get_top_edge_radius() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "top_edge_radius", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_i_type_rail::put_top_edge_radius(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "top_edge_radius", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_i_type_rail::get_bottom_edge_radius() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "bottom_edge_radius", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_i_type_rail::put_bottom_edge_radius(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "bottom_edge_radius", sdaiINSTANCE, (void*) i); }
    inline ratio_measure_with_unit section_profile_i_type_rail::get_top_flange_inner_slope() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "top_flange_inner_slope", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_i_type_rail::put_top_flange_inner_slope(ratio_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "top_flange_inner_slope", sdaiINSTANCE, (void*) i); }
    inline ratio_measure_with_unit section_profile_i_type_rail::get_bottom_flange_inner_slope() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "bottom_flange_inner_slope", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_i_type_rail::put_bottom_flange_inner_slope(ratio_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "bottom_flange_inner_slope", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_i_type_rail::get_transition_radius_top() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "transition_radius_top", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_i_type_rail::put_transition_radius_top(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "transition_radius_top", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_i_type_rail::get_transition_radius_bottom() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "transition_radius_bottom", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_i_type_rail::put_transition_radius_bottom(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "transition_radius_bottom", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_rectangle::get_overall_depth() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "overall_depth", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_rectangle::put_overall_depth(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "overall_depth", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_rectangle::get_overall_width() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "overall_width", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_rectangle::put_overall_width(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "overall_width", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_rectangle::get_external_fillet_radius() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "external_fillet_radius", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_rectangle::put_external_fillet_radius(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "external_fillet_radius", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_rectangle_hollow::get_wall_thickness() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "wall_thickness", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_rectangle_hollow::put_wall_thickness(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "wall_thickness", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_rectangle_hollow::get_internal_fillet_radius() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "internal_fillet_radius", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_rectangle_hollow::put_internal_fillet_radius(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "internal_fillet_radius", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_t_type::get_overall_depth() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "overall_depth", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_t_type::put_overall_depth(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "overall_depth", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_t_type::get_flange_width() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "flange_width", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_t_type::put_flange_width(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "flange_width", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_t_type::get_flange_thickness() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "flange_thickness", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_t_type::put_flange_thickness(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "flange_thickness", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_t_type::get_web_thickness() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "web_thickness", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_t_type::put_web_thickness(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "web_thickness", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_t_type::get_root_radius() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "root_radius", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_t_type::put_root_radius(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "root_radius", sdaiINSTANCE, (void*) i); }
    inline ratio_measure_with_unit section_profile_t_type::get_flange_slope() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "flange_slope", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_t_type::put_flange_slope(ratio_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "flange_slope", sdaiINSTANCE, (void*) i); }
    inline ratio_measure_with_unit section_profile_t_type::get_web_slope() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "web_slope", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_t_type::put_web_slope(ratio_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "web_slope", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_profile_t_type::get_edge_radius() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "edge_radius", sdaiINSTANCE, &inst); return inst; }
    inline void section_profile_t_type::put_edge_radius(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "edge_radius", sdaiINSTANCE, (void*) i); }
    inline section_profile section_properties::get_profile() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "profile", sdaiINSTANCE, &inst); return inst; }
    inline void section_properties::put_profile(section_profile inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "profile", sdaiINSTANCE, (void*) i); }
    inline inertia_measure_with_unit section_properties::get_torsional_constant_Ix() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "torsional_constant_Ix", sdaiINSTANCE, &inst); return inst; }
    inline void section_properties::put_torsional_constant_Ix(inertia_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "torsional_constant_Ix", sdaiINSTANCE, (void*) i); }
    inline inertia_measure_with_unit section_properties::get_inertia_moment_Iy() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "inertia_moment_Iy", sdaiINSTANCE, &inst); return inst; }
    inline void section_properties::put_inertia_moment_Iy(inertia_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "inertia_moment_Iy", sdaiINSTANCE, (void*) i); }
    inline inertia_measure_with_unit section_properties::get_inertia_moment_Iz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "inertia_moment_Iz", sdaiINSTANCE, &inst); return inst; }
    inline void section_properties::put_inertia_moment_Iz(inertia_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "inertia_moment_Iz", sdaiINSTANCE, (void*) i); }
    inline area_measure_with_unit section_properties::get_section_area_Ax() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "section_area_Ax", sdaiINSTANCE, &inst); return inst; }
    inline void section_properties::put_section_area_Ax(area_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "section_area_Ax", sdaiINSTANCE, (void*) i); }
    inline area_measure_with_unit section_properties::get_shear_area_Asy() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "shear_area_Asy", sdaiINSTANCE, &inst); return inst; }
    inline void section_properties::put_shear_area_Asy(area_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "shear_area_Asy", sdaiINSTANCE, (void*) i); }
    inline area_measure_with_unit section_properties::get_shear_area_Asz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "shear_area_Asz", sdaiINSTANCE, &inst); return inst; }
    inline void section_properties::put_shear_area_Asz(area_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "shear_area_Asz", sdaiINSTANCE, (void*) i); }
    inline area_measure_with_unit section_properties::get_shear_deformation_area_Ay() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "shear_deformation_area_Ay", sdaiINSTANCE, &inst); return inst; }
    inline void section_properties::put_shear_deformation_area_Ay(area_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "shear_deformation_area_Ay", sdaiINSTANCE, (void*) i); }
    inline area_measure_with_unit section_properties::get_shear_deformation_area_Az() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "shear_deformation_area_Az", sdaiINSTANCE, &inst); return inst; }
    inline void section_properties::put_shear_deformation_area_Az(area_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "shear_deformation_area_Az", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_properties::get_surface_per_length() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "surface_per_length", sdaiINSTANCE, &inst); return inst; }
    inline void section_properties::put_surface_per_length(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "surface_per_length", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_properties::get_radius_of_gyration_ry() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "radius_of_gyration_ry", sdaiINSTANCE, &inst); return inst; }
    inline void section_properties::put_radius_of_gyration_ry(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "radius_of_gyration_ry", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_properties::get_radius_of_gyration_rz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "radius_of_gyration_rz", sdaiINSTANCE, &inst); return inst; }
    inline void section_properties::put_radius_of_gyration_rz(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "radius_of_gyration_rz", sdaiINSTANCE, (void*) i); }
    inline modulus_measure_with_unit section_properties::get_plastic_modulus_Sy() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "plastic_modulus_Sy", sdaiINSTANCE, &inst); return inst; }
    inline void section_properties::put_plastic_modulus_Sy(modulus_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "plastic_modulus_Sy", sdaiINSTANCE, (void*) i); }
    inline modulus_measure_with_unit section_properties::get_plastic_modulus_Sz() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "plastic_modulus_Sz", sdaiINSTANCE, &inst); return inst; }
    inline void section_properties::put_plastic_modulus_Sz(modulus_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "plastic_modulus_Sz", sdaiINSTANCE, (void*) i); }
    inline derived_measure_with_unit section_properties::get_warping_constant() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "warping_constant", sdaiINSTANCE, &inst); return inst; }
    inline void section_properties::put_warping_constant(derived_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "warping_constant", sdaiINSTANCE, (void*) i); }
    inline mass_per_length_measure_with_unit section_properties::get_nominal_mass() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "nominal_mass", sdaiINSTANCE, &inst); return inst; }
    inline void section_properties::put_nominal_mass(mass_per_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "nominal_mass", sdaiINSTANCE, (void*) i); }
    inline mass_per_length_measure_with_unit section_properties::get_actual_mass() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "actual_mass", sdaiINSTANCE, &inst); return inst; }
    inline void section_properties::put_actual_mass(mass_per_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "actual_mass", sdaiINSTANCE, (void*) i); }
    inline plane_angle_measure_with_unit section_properties_asymmetric::get_theta_angle_z_axis_v_axis() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "theta_angle_z_axis_v_axis", sdaiINSTANCE, &inst); return inst; }
    inline void section_properties_asymmetric::put_theta_angle_z_axis_v_axis(plane_angle_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "theta_angle_z_axis_v_axis", sdaiINSTANCE, (void*) i); }
    inline inertia_measure_with_unit section_properties_asymmetric::get_inertia_moment_Iu() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "inertia_moment_Iu", sdaiINSTANCE, &inst); return inst; }
    inline void section_properties_asymmetric::put_inertia_moment_Iu(inertia_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "inertia_moment_Iu", sdaiINSTANCE, (void*) i); }
    inline inertia_measure_with_unit section_properties_asymmetric::get_inertia_moment_Iv() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "inertia_moment_Iv", sdaiINSTANCE, &inst); return inst; }
    inline void section_properties_asymmetric::put_inertia_moment_Iv(inertia_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "inertia_moment_Iv", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_properties_asymmetric::get_radius_of_gyration_ru() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "radius_of_gyration_ru", sdaiINSTANCE, &inst); return inst; }
    inline void section_properties_asymmetric::put_radius_of_gyration_ru(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "radius_of_gyration_ru", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit section_properties_asymmetric::get_radius_of_gyration_rv() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "radius_of_gyration_rv", sdaiINSTANCE, &inst); return inst; }
    inline void section_properties_asymmetric::put_radius_of_gyration_rv(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "radius_of_gyration_rv", sdaiINSTANCE, (void*) i); }
    inline site setting_out_point::get_set_out_site() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "set_out_site", sdaiINSTANCE, &inst); return inst; }
    inline void setting_out_point::put_set_out_site(site inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "set_out_site", sdaiINSTANCE, (void*) i); }
    inline geographical_location setting_out_point::get_location() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "location", sdaiINSTANCE, &inst); return inst; }
    inline void setting_out_point::put_location(geographical_location inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "location", sdaiINSTANCE, (void*) i); }
    inline address site::get_site_address() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "site_address", sdaiINSTANCE, &inst); return inst; }
    inline void site::put_site_address(address inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "site_address", sdaiINSTANCE, (void*) i); }
    inline shape_representation_with_units site_with_shape::get_shape() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "shape", sdaiINSTANCE, &inst); return inst; }
    inline void site_with_shape::put_shape(shape_representation_with_units inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "shape", sdaiINSTANCE, (void*) i); }
    inline solid_model solid_replica::get_parent_solid() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "parent_solid", sdaiINSTANCE, &inst); return inst; }
    inline void solid_replica::put_parent_solid(solid_model inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "parent_solid", sdaiINSTANCE, (void*) i); }
    inline cartesian_transformation_operator_3d solid_replica::get_transformation() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "transformation", sdaiINSTANCE, &inst); return inst; }
    inline void solid_replica::put_transformation(cartesian_transformation_operator_3d inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "transformation", sdaiINSTANCE, (void*) i); }
    inline point sphere::get_centre() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "centre", sdaiINSTANCE, &inst); return inst; }
    inline void sphere::put_centre(point inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "centre", sdaiINSTANCE, (void*) i); }
    inline axis2_placement_3d spherical_volume::get_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "position", sdaiINSTANCE, &inst); return inst; }
    inline void spherical_volume::put_position(axis2_placement_3d inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "position", sdaiINSTANCE, (void*) i); }
    inline structural_frame_item structural_frame_item_approved::get_approved_item() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "approved_item", sdaiINSTANCE, &inst); return inst; }
    inline void structural_frame_item_approved::put_approved_item(structural_frame_item inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "approved_item", sdaiINSTANCE, (void*) i); }
    inline approval structural_frame_item_approved::get_assigned_approval() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "assigned_approval", sdaiINSTANCE, &inst); return inst; }
    inline void structural_frame_item_approved::put_assigned_approval(approval inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "assigned_approval", sdaiINSTANCE, (void*) i); }
    inline structural_frame_item structural_frame_item_certified::get_certified_item() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "certified_item", sdaiINSTANCE, &inst); return inst; }
    inline void structural_frame_item_certified::put_certified_item(structural_frame_item inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "certified_item", sdaiINSTANCE, (void*) i); }
    inline certification structural_frame_item_certified::get_assigned_certification() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "assigned_certification", sdaiINSTANCE, &inst); return inst; }
    inline void structural_frame_item_certified::put_assigned_certification(certification inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "assigned_certification", sdaiINSTANCE, (void*) i); }
    inline structural_frame_item structural_frame_item_documented::get_documented_item() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "documented_item", sdaiINSTANCE, &inst); return inst; }
    inline void structural_frame_item_documented::put_documented_item(structural_frame_item inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "documented_item", sdaiINSTANCE, (void*) i); }
    inline document_usage_constraint structural_frame_item_documented::get_document_reference() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "document_reference", sdaiINSTANCE, &inst); return inst; }
    inline void structural_frame_item_documented::put_document_reference(document_usage_constraint inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "document_reference", sdaiINSTANCE, (void*) i); }
    inline structural_frame_item structural_frame_item_priced::get_priced_item() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "priced_item", sdaiINSTANCE, &inst); return inst; }
    inline void structural_frame_item_priced::put_priced_item(structural_frame_item inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "priced_item", sdaiINSTANCE, (void*) i); }
    inline currency_measure_with_unit structural_frame_item_priced::get_assigned_price() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "assigned_price", sdaiINSTANCE, &inst); return inst; }
    inline void structural_frame_item_priced::put_assigned_price(currency_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "assigned_price", sdaiINSTANCE, (void*) i); }
    inline structural_frame_item structural_frame_item_relationship::get_related_item() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "related_item", sdaiINSTANCE, &inst); return inst; }
    inline void structural_frame_item_relationship::put_related_item(structural_frame_item inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "related_item", sdaiINSTANCE, (void*) i); }
    inline structural_frame_item structural_frame_item_relationship::get_relating_item() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "relating_item", sdaiINSTANCE, &inst); return inst; }
    inline void structural_frame_item_relationship::put_relating_item(structural_frame_item inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "relating_item", sdaiINSTANCE, (void*) i); }
    inline material structural_frame_product_with_material::get_material_definition() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "material_definition", sdaiINSTANCE, &inst); return inst; }
    inline void structural_frame_product_with_material::put_material_definition(material inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "material_definition", sdaiINSTANCE, (void*) i); }
    inline mass_measure_with_unit structural_frame_product_with_material::get_nominal_mass() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "nominal_mass", sdaiINSTANCE, &inst); return inst; }
    inline void structural_frame_product_with_material::put_nominal_mass(mass_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "nominal_mass", sdaiINSTANCE, (void*) i); }
    inline mass_measure_with_unit structural_frame_product_with_material::get_actual_mass() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "actual_mass", sdaiINSTANCE, &inst); return inst; }
    inline void structural_frame_product_with_material::put_actual_mass(mass_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "actual_mass", sdaiINSTANCE, (void*) i); }
    inline edge subedge::get_parent_edge() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "parent_edge", sdaiINSTANCE, &inst); return inst; }
    inline void subedge::put_parent_edge(edge inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "parent_edge", sdaiINSTANCE, (void*) i); }
    inline face subface::get_parent_face() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "parent_face", sdaiINSTANCE, &inst); return inst; }
    inline void subface::put_parent_face(face inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "parent_face", sdaiINSTANCE, (void*) i); }
    inline curve surface_curve_swept_area_solid::get_directrix() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "directrix", sdaiINSTANCE, &inst); return inst; }
    inline void surface_curve_swept_area_solid::put_directrix(curve inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "directrix", sdaiINSTANCE, (void*) i); }
    inline surface surface_curve_swept_area_solid::get_reference_surface() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reference_surface", sdaiINSTANCE, &inst); return inst; }
    inline void surface_curve_swept_area_solid::put_reference_surface(surface inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reference_surface", sdaiINSTANCE, (void*) i); }
    inline curve surface_curve_swept_face_solid::get_directrix() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "directrix", sdaiINSTANCE, &inst); return inst; }
    inline void surface_curve_swept_face_solid::put_directrix(curve inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "directrix", sdaiINSTANCE, (void*) i); }
    inline surface surface_curve_swept_face_solid::get_reference_surface() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reference_surface", sdaiINSTANCE, &inst); return inst; }
    inline void surface_curve_swept_face_solid::put_reference_surface(surface inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reference_surface", sdaiINSTANCE, (void*) i); }
    inline curve surface_curve_swept_surface::get_directrix() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "directrix", sdaiINSTANCE, &inst); return inst; }
    inline void surface_curve_swept_surface::put_directrix(curve inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "directrix", sdaiINSTANCE, (void*) i); }
    inline surface surface_curve_swept_surface::get_reference_surface() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "reference_surface", sdaiINSTANCE, &inst); return inst; }
    inline void surface_curve_swept_surface::put_reference_surface(surface inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "reference_surface", sdaiINSTANCE, (void*) i); }
    inline vector surface_of_linear_extrusion::get_extrusion_axis() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "extrusion_axis", sdaiINSTANCE, &inst); return inst; }
    inline void surface_of_linear_extrusion::put_extrusion_axis(vector inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "extrusion_axis", sdaiINSTANCE, (void*) i); }
    inline axis1_placement surface_of_revolution::get_axis_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "axis_position", sdaiINSTANCE, &inst); return inst; }
    inline void surface_of_revolution::put_axis_position(axis1_placement inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "axis_position", sdaiINSTANCE, (void*) i); }
    inline bounded_surface surface_patch::get_parent_surface() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "parent_surface", sdaiINSTANCE, &inst); return inst; }
    inline void surface_patch::put_parent_surface(bounded_surface inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "parent_surface", sdaiINSTANCE, (void*) i); }
    inline surface surface_replica::get_parent_surface() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "parent_surface", sdaiINSTANCE, &inst); return inst; }
    inline void surface_replica::put_parent_surface(surface inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "parent_surface", sdaiINSTANCE, (void*) i); }
    inline cartesian_transformation_operator_3d surface_replica::get_transformation() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "transformation", sdaiINSTANCE, &inst); return inst; }
    inline void surface_replica::put_transformation(cartesian_transformation_operator_3d inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "transformation", sdaiINSTANCE, (void*) i); }
    inline length_measure_with_unit surface_treatment_grind::get_finished_surface_irregularity() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "finished_surface_irregularity", sdaiINSTANCE, &inst); return inst; }
    inline void surface_treatment_grind::put_finished_surface_irregularity(length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "finished_surface_irregularity", sdaiINSTANCE, (void*) i); }
    inline thermodynamic_temperature_measure_with_unit surface_treatment_thermal::get_initial_temperature() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "initial_temperature", sdaiINSTANCE, &inst); return inst; }
    inline void surface_treatment_thermal::put_initial_temperature(thermodynamic_temperature_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "initial_temperature", sdaiINSTANCE, (void*) i); }
    inline thermodynamic_temperature_measure_with_unit surface_treatment_thermal::get_final_temperature() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "final_temperature", sdaiINSTANCE, &inst); return inst; }
    inline void surface_treatment_thermal::put_final_temperature(thermodynamic_temperature_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "final_temperature", sdaiINSTANCE, (void*) i); }
    inline thermodynamic_temperature_measure_with_unit surface_treatment_thermal::get_maximum_temperature() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "maximum_temperature", sdaiINSTANCE, &inst); return inst; }
    inline void surface_treatment_thermal::put_maximum_temperature(thermodynamic_temperature_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "maximum_temperature", sdaiINSTANCE, (void*) i); }
    inline time_measure_with_unit surface_treatment_thermal_timed::get_time_to_maximum() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "time_to_maximum", sdaiINSTANCE, &inst); return inst; }
    inline void surface_treatment_thermal_timed::put_time_to_maximum(time_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "time_to_maximum", sdaiINSTANCE, (void*) i); }
    inline time_measure_with_unit surface_treatment_thermal_timed::get_time_at_maximum() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "time_at_maximum", sdaiINSTANCE, &inst); return inst; }
    inline void surface_treatment_thermal_timed::put_time_at_maximum(time_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "time_at_maximum", sdaiINSTANCE, (void*) i); }
    inline time_measure_with_unit surface_treatment_thermal_timed::get_time_to_final() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "time_to_final", sdaiINSTANCE, &inst); return inst; }
    inline void surface_treatment_thermal_timed::put_time_to_final(time_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "time_to_final", sdaiINSTANCE, (void*) i); }
    inline cartesian_point tetrahedron_volume::get_point_1() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "point_1", sdaiINSTANCE, &inst); return inst; }
    inline void tetrahedron_volume::put_point_1(cartesian_point inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "point_1", sdaiINSTANCE, (void*) i); }
    inline cartesian_point tetrahedron_volume::get_point_2() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "point_2", sdaiINSTANCE, &inst); return inst; }
    inline void tetrahedron_volume::put_point_2(cartesian_point inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "point_2", sdaiINSTANCE, (void*) i); }
    inline cartesian_point tetrahedron_volume::get_point_3() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "point_3", sdaiINSTANCE, &inst); return inst; }
    inline void tetrahedron_volume::put_point_3(cartesian_point inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "point_3", sdaiINSTANCE, (void*) i); }
    inline cartesian_point tetrahedron_volume::get_point_4() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "point_4", sdaiINSTANCE, &inst); return inst; }
    inline void tetrahedron_volume::put_point_4(cartesian_point inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "point_4", sdaiINSTANCE, (void*) i); }
    inline axis2_placement_3d toroidal_volume::get_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "position", sdaiINSTANCE, &inst); return inst; }
    inline void toroidal_volume::put_position(axis2_placement_3d inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "position", sdaiINSTANCE, (void*) i); }
    inline axis1_placement torus::get_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "position", sdaiINSTANCE, &inst); return inst; }
    inline void torus::put_position(axis1_placement inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "position", sdaiINSTANCE, (void*) i); }
    inline curve trimmed_curve::get_basis_curve() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "basis_curve", sdaiINSTANCE, &inst); return inst; }
    inline void trimmed_curve::put_basis_curve(curve inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "basis_curve", sdaiINSTANCE, (void*) i); }
    inline volume trimmed_volume::get_basis_volume() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "basis_volume", sdaiINSTANCE, &inst); return inst; }
    inline void trimmed_volume::put_basis_volume(volume inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "basis_volume", sdaiINSTANCE, (void*) i); }
    inline direction vector::get_orientation() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "orientation", sdaiINSTANCE, &inst); return inst; }
    inline void vector::put_orientation(direction inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "orientation", sdaiINSTANCE, (void*) i); }
    inline vertex vertex_loop::get_loop_vertex() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "loop_vertex", sdaiINSTANCE, &inst); return inst; }
    inline void vertex_loop::put_loop_vertex(vertex inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "loop_vertex", sdaiINSTANCE, (void*) i); }
    inline point vertex_point::get_vertex_geometry() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "vertex_geometry", sdaiINSTANCE, &inst); return inst; }
    inline void vertex_point::put_vertex_geometry(point inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "vertex_geometry", sdaiINSTANCE, (void*) i); }
    inline vertex_loop vertex_shell::get_vertex_shell_extent() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "vertex_shell_extent", sdaiINSTANCE, &inst); return inst; }
    inline void vertex_shell::put_vertex_shell_extent(vertex_loop inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "vertex_shell_extent", sdaiINSTANCE, (void*) i); }
    inline axis2_placement_3d wedge_volume::get_position() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "position", sdaiINSTANCE, &inst); return inst; }
    inline void wedge_volume::put_position(axis2_placement_3d inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "position", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit weld_mechanism::get_weld_dimension() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "weld_dimension", sdaiINSTANCE, &inst); return inst; }
    inline void weld_mechanism::put_weld_dimension(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "weld_dimension", sdaiINSTANCE, (void*) i); }
    inline pressure_measure_with_unit weld_mechanism::get_weld_design_strength() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "weld_design_strength", sdaiINSTANCE, &inst); return inst; }
    inline void weld_mechanism::put_weld_design_strength(pressure_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "weld_design_strength", sdaiINSTANCE, (void*) i); }
    inline shape_representation_with_units weld_mechanism_complex::get_weld_shape() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "weld_shape", sdaiINSTANCE, &inst); return inst; }
    inline void weld_mechanism_complex::put_weld_shape(shape_representation_with_units inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "weld_shape", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit weld_mechanism_fillet::get_leg_length_y() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "leg_length_y", sdaiINSTANCE, &inst); return inst; }
    inline void weld_mechanism_fillet::put_leg_length_y(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "leg_length_y", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit weld_mechanism_fillet::get_leg_length_z() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "leg_length_z", sdaiINSTANCE, &inst); return inst; }
    inline void weld_mechanism_fillet::put_leg_length_z(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "leg_length_z", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit weld_mechanism_fillet_intermittent::get_fillet_weld_length() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "fillet_weld_length", sdaiINSTANCE, &inst); return inst; }
    inline void weld_mechanism_fillet_intermittent::put_fillet_weld_length(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "fillet_weld_length", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit weld_mechanism_fillet_intermittent::get_fillet_weld_spacing() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "fillet_weld_spacing", sdaiINSTANCE, &inst); return inst; }
    inline void weld_mechanism_fillet_intermittent::put_fillet_weld_spacing(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "fillet_weld_spacing", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit weld_mechanism_groove::get_root_gap() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "root_gap", sdaiINSTANCE, &inst); return inst; }
    inline void weld_mechanism_groove::put_root_gap(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "root_gap", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit weld_mechanism_groove::get_root_face() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "root_face", sdaiINSTANCE, &inst); return inst; }
    inline void weld_mechanism_groove::put_root_face(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "root_face", sdaiINSTANCE, (void*) i); }
    inline plane_angle_measure_with_unit weld_mechanism_groove_beveled::get_groove_angle() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "groove_angle", sdaiINSTANCE, &inst); return inst; }
    inline void weld_mechanism_groove_beveled::put_groove_angle(plane_angle_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "groove_angle", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit weld_mechanism_groove_beveled::get_groove_depth() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "groove_depth", sdaiINSTANCE, &inst); return inst; }
    inline void weld_mechanism_groove_beveled::put_groove_depth(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "groove_depth", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit weld_mechanism_groove_beveled::get_groove_radius() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "groove_radius", sdaiINSTANCE, &inst); return inst; }
    inline void weld_mechanism_groove_beveled::put_groove_radius(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "groove_radius", sdaiINSTANCE, (void*) i); }
    inline plane_angle_measure_with_unit weld_mechanism_groove_beveled::get_taper_angle() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "taper_angle", sdaiINSTANCE, &inst); return inst; }
    inline void weld_mechanism_groove_beveled::put_taper_angle(plane_angle_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "taper_angle", sdaiINSTANCE, (void*) i); }
    inline building zone_of_building::get_zone_for_building() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "zone_for_building", sdaiINSTANCE, &inst); return inst; }
    inline void zone_of_building::put_zone_for_building(building inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "zone_for_building", sdaiINSTANCE, (void*) i); }
    inline positive_length_measure_with_unit zone_of_building_storey::get_storey_height() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "storey_height", sdaiINSTANCE, &inst); return inst; }
    inline void zone_of_building_storey::put_storey_height(positive_length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "storey_height", sdaiINSTANCE, (void*) i); }
    inline length_measure_with_unit zone_of_building_storey::get_storey_level() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "storey_level", sdaiINSTANCE, &inst); return inst; }
    inline void zone_of_building_storey::put_storey_level(length_measure_with_unit inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "storey_level", sdaiINSTANCE, (void*) i); }
    inline project zone_of_project::get_zone_for_project() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "zone_for_project", sdaiINSTANCE, &inst); return inst; }
    inline void zone_of_project::put_zone_for_project(project inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "zone_for_project", sdaiINSTANCE, (void*) i); }
    inline site zone_of_site::get_zone_for_site() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "zone_for_site", sdaiINSTANCE, &inst); return inst; }
    inline void zone_of_site::put_zone_for_site(site inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "zone_for_site", sdaiINSTANCE, (void*) i); }
    inline structure zone_of_structure::get_zone_for_structure() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "zone_for_structure", sdaiINSTANCE, &inst); return inst; }
    inline void zone_of_structure::put_zone_for_structure(structure inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "zone_for_structure", sdaiINSTANCE, (void*) i); }
    inline zone_of_structure zone_of_structure_sequence::get_parent_zone() { SdaiInstance inst = 0; sdaiGetAttrBN(m_instance, "parent_zone", sdaiINSTANCE, &inst); return inst; }
    inline void zone_of_structure_sequence::put_parent_zone(zone_of_structure inst) { SdaiInstance i = inst;  sdaiPutAttrBN(m_instance, "parent_zone", sdaiINSTANCE, (void*) i); }

}

#endif //__RDF_LTD__CIS2_H
